\documentclass[12pt,a4paper]{amsart}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{tikz}
\usepackage{algorithm,algcompatible,amssymb,amsmath}
\renewcommand{\COMMENT}[2][.5\linewidth]{%
  \leavevmode\hfill\makebox[#1][l]{//~#2}}
\algnewcommand\algorithmicto{\textbf{to}}
\algnewcommand\TO{\textbf{ to }}
\algnewcommand\AND{\textbf{ and }}
\algnewcommand\RETURN{\State \textbf{return} }
\usepackage{float}
\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{caption}
\usepackage[hidelinks,bookmarksnumbered,bookmarksopen]{hyperref}
\usepackage{xeCJK}
\setCJKmainfont{LXGW WenKai}
\usepackage{amssymb}
\renewcommand{\arraystretch}{1.5}

\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}

% 代码高亮设置
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{gray!10},
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showstringspaces=false,
    showtabs=false
}

% 定理环境
\newtheorem{definition}{定义}[section]
\newtheorem{theorem}{定理}[section]
\newtheorem{example}{例题}[section]
\newtheorem{property}{性质}[section]

% TikZ库
\usetikzlibrary{positioning,arrows,automata,calc,shapes,patterns}

\title{\textbf{数据结构 - 排序技术复习资料}}
\author{详细版本}
\date{\today}

\begin{document}

% \maketitle
% \tableofcontents
% \newpage

\section{排序的基本概念}

\subsection{排序的定义}

\begin{definition}[排序]
给定一个记录序列$(r_1, r_2, \ldots, r_n)$，其相应的关键码分别为$(k_1, k_2, \ldots, k_n)$，排序(sort)是将这些记录排列成顺序为$(r_{s1}, r_{s2}, \ldots, r_{sn})$的序列，使得相应的关键码满足$k_{s1} \leq k_{s2} \leq \cdots \leq k_{sn}$（升序）或$k_{s1} \geq k_{s2} \geq \cdots \geq k_{sn}$（降序）。
\end{definition}

\subsection{排序算法的分类}

\begin{enumerate}
\item \textbf{按存储位置分类}
\begin{itemize}
\item \textbf{内排序}：排序过程中，待排序的所有记录全部被放置在内存中
\item \textbf{外排序}：待排序记录太多，需要在内外存之间多次交换数据
\end{itemize}

\item \textbf{按比较方式分类}
\begin{itemize}
\item \textbf{基于比较的排序}：通过关键码之间的比较和记录的移动来实现
\item \textbf{不基于比较的排序}：如基数排序、计数排序等
\end{itemize}
\end{enumerate}

\subsection{排序算法的性能指标}

\begin{definition}[排序算法的稳定性]
假定在待排序的记录序列中，存在多个具有相同关键码的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，$k_i = k_j$且$r_i$在$r_j$之前，在排序后的序列中，$r_i$仍在$r_j$之前，则称这种排序算法是\textbf{稳定的}(stable)；否则称为\textbf{不稳定的}(unstable)。
\end{definition}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 原始序列
    \node at (-2, 2) {原始序列:};
    \foreach \i/\val/\col in {0/3/blue, 1/5/red, 2/3/green, 3/2/black, 4/5/orange} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1, 2) {\val};
        \node[below, font=\tiny] at (\i*1, 1.4) {\col};
    }
    
    % 稳定排序结果
    \node at (-2, 0) {稳定排序:};
    \foreach \i/\val/\col in {0/2/black, 1/3/blue, 2/3/green, 3/5/red, 4/5/orange} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1, 0) {\val};
        \node[below, font=\tiny] at (\i*1, -0.6) {\col};
    }
    
    % 不稳定排序结果
    \node at (-2, -2) {不稳定排序:};
    \foreach \i/\val/\col in {0/2/black, 1/3/green, 2/3/blue, 3/5/orange, 4/5/red} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1, -2) {\val};
        \node[below, font=\tiny] at (\i*1, -2.6) {\col};
    }
    
    \node at (0, -4) {\textbf{稳定性示意图}};
\end{tikzpicture}
\end{center}

\section{插入排序}

\subsection{直接插入排序}

\begin{definition}[直接插入排序]
直接插入排序(Straight Insertion Sort)的基本思想是：依次将待排序序列中的每一个记录插入到已排好序的序列中，直到全部记录都排好序。
\end{definition}

\begin{algorithm}[H]
\caption{直接插入排序}
\begin{algorithmic}[1]
\REQUIRE 待排序数组$data[0..n-1]$
\ENSURE 排序后的数组
\FOR{$i = 1$ \TO $n-1$}
    \STATE $temp = data[i]$ \COMMENT{暂存待插入记录}
    \STATE $j = i - 1$
    \WHILE{$j \geq 0$ \AND $temp < data[j]$}
        \STATE $data[j+1] = data[j]$ \COMMENT{记录后移}
        \STATE $j = j - 1$
    \ENDWHILE
    \STATE $data[j+1] = temp$ \COMMENT{插入到正确位置}
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{lstlisting}[caption=直接插入排序实现]
void InsertSort(int data[], int n) {
    int i, j, temp;
    for (i = 1; i < n; i++) {
        temp = data[i];  // 暂存待插入记录
        for (j = i-1; j >= 0 && temp < data[j]; j--) {
            data[j+1] = data[j];  // 记录后移
        }
        data[j+1] = temp;  // 插入到正确位置
    }
}
\end{lstlisting}

\begin{example}[直接插入排序过程]
对于记录序列 $\{12, 30, 25, 9, 18\}$，直接插入排序的执行过程如下表所示。灰色背景的单元格代表当前趟排序后的有序区。
\begin{center}
\captionof{table}{直接插入排序过程示例}
\label{tab:insertion_sort_example}
\begin{tabular}{l|c c c c c}
\toprule
\textbf{过程} & \multicolumn{5}{c}{\textbf{序列状态}} \\
\midrule
待排序序列 & 12 & 30 & 25 & 9 & 18 \\
初始有序区 & \cellcolor{gray!25}12 & 30 & 25 & 9 & 18 \\
第1趟结果 & \cellcolor{gray!25}12 & \cellcolor{gray!25}30 & 25 & 9 & 18 \\
第2趟结果 & \cellcolor{gray!25}12 & \cellcolor{gray!25}25 & \cellcolor{gray!25}30 & 9 & 18 \\
第3趟结果 & \cellcolor{gray!25}9 & \cellcolor{gray!25}12 & \cellcolor{gray!25}25 & \cellcolor{gray!25}30 & 18 \\
第4趟结果 & \cellcolor{gray!25}9 & \cellcolor{gray!25}12 & \cellcolor{gray!25}18 & \cellcolor{gray!25}25 & \cellcolor{gray!25}30 \\
\bottomrule
\end{tabular}
\end{center}
过程解释：
\begin{itemize}
    \item \textbf{初始状态}: 有序区只包含第一个元素 $\{12\}$。
    \item \textbf{第1趟}: 将 $30$ 插入有序区。$30 > 12$，位置不变。有序区为 $\{12, 30\}$。
    \item \textbf{第2趟}: 将 $25$ 插入有序区。$25 < 30$，将 $30$ 后移，$25$ 插入。有序区为 $\{12, 25, 30\}$。
    \item \textbf{第3趟}: 将 $9$ 插入有序区。$9$ 比所有已排序元素都小，将 $\{12, 25, 30\}$ 全部后移。有序区为 $\{9, 12, 25, 30\}$。
    \item \textbf{第4趟}: 将 $18$ 插入有序区。$18$ 插入到 $12$ 和 $25$ 之间。最终有序区为 $\{9, 12, 18, 25, 30\}$。
\end{itemize}
\end{example}

\begin{theorem}[直接插入排序的性能]
    \indent
\begin{itemize}
\item \textbf{时间复杂度}：
    \begin{itemize}
    \item 最好情况（正序）：$O(n)$
    \item 最坏情况（逆序）：$O(n^2)$
    \item 平均情况：$O(n^2)$
    \end{itemize}
\item \textbf{空间复杂度}：$O(1)$
\item \textbf{稳定性}：稳定
\end{itemize}
\end{theorem}

\subsection{希尔排序}

\begin{definition}[希尔排序]
希尔排序(Shell Sort)是对直接插入排序的改进，基本思想是：先将整个待排序记录序列分割成若干个子序列，在子序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。

\textbf{核心思想：}
\begin{itemize}
\item 选择一个增量序列$d_1, d_2, \ldots, d_k$，其中$d_1 > d_2 > \cdots > d_k = 1$
\item 对每个增量$d_i$，将序列分成$d_i$个子序列，每个子序列包含间隔为$d_i$的元素
\item 对每个子序列进行直接插入排序
\item 当增量减小到1时，整个序列已基本有序，最后一次插入排序的工作量很小
\end{itemize}
\end{definition}

\textbf{详细工作过程：}

以序列$[59, 20, 17, 36, 98, 14, 23, 83, 13, 28]$为例，使用增量序列$d = \{5, 2, 1\}$：

\begin{center}
\begin{tikzpicture}[scale=1]
    % 原始序列
    \node[anchor=east] at (-1, 5) {原始序列:};
    \foreach \i/\val in {0/59, 1/20, 2/17, 3/36, 4/98, 5/14, 6/23, 7/83, 8/13, 9/28} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm] at (\i*1.1, 5) {\val};
        \node[font=\tiny] at (\i*1.1, 4.4) {\i};
    }
    
    % d=5时的分组
    \node[anchor=east] at (-1, 3.5) {$d=5$分组:};
    % 第一组 (0,5)
    \foreach \i/\val in {0/59, 5/14} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=red!30] at (\i*1.1, 3.5) {\val};
    }
    % 第二组 (1,6)
    \foreach \i/\val in {1/20, 6/23} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=blue!30] at (\i*1.1, 3.5) {\val};
    }
    % 第三组 (2,7)
    \foreach \i/\val in {2/17, 7/83} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=green!30] at (\i*1.1, 3.5) {\val};
    }
    % 第四组 (3,8)
    \foreach \i/\val in {3/36, 8/13} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=yellow!30] at (\i*1.1, 3.5) {\val};
    }
    % 第五组 (4,9)
    \foreach \i/\val in {4/98, 9/28} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=purple!30] at (\i*1.1, 3.5) {\val};
    }
    
    % d=5排序后
    \node[anchor=east] at (-1, 2.5) {$d=5$排序后:};
    \foreach \i/\val in {0/14, 1/20, 2/17, 3/13, 4/28, 5/59, 6/23, 7/83, 8/36, 9/98} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm] at (\i*1.1, 2.5) {\val};
    }
    
    % d=2时的分组
    \node[anchor=east] at (-1, 1.5) {$d=2$分组:};
    % 偶数位置
    \foreach \i/\val in {0/14, 2/17, 4/28, 6/23, 8/36} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=red!30] at (\i*1.1, 1.5) {\val};
    }
    % 奇数位置
    \foreach \i/\val in {1/20, 3/13, 5/59, 7/83, 9/98} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=blue!30] at (\i*1.1, 1.5) {\val};
    }
    
    % d=2排序后
    \node[anchor=east] at (-1, 0.5) {$d=2$排序后:};
    \foreach \i/\val in {0/14, 1/13, 2/17, 3/20, 4/23, 5/59, 6/28, 7/83, 8/36, 9/98} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm] at (\i*1.1, 0.5) {\val};
    }
    
    % d=1最终排序
    \node[anchor=east] at (-1, -0.5) {$d=1$最终结果:};
    \foreach \i/\val in {0/13, 1/14, 2/17, 3/20, 4/23, 5/28, 6/36, 7/59, 8/83, 9/98} {
        \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=green!20] at (\i*1.1, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{分组规则详解：}
\begin{itemize}
\item 当$d=5$时，将数组分成5个子序列：
    \begin{itemize}
    \item 子序列1：$data[0], data[5]$ → $[59, 14]$ → 排序后 $[14, 59]$
    \item 子序列2：$data[1], data[6]$ → $[20, 23]$ → 排序后 $[20, 23]$
    \item 子序列3：$data[2], data[7]$ → $[17, 83]$ → 排序后 $[17, 83]$
    \item 子序列4：$data[3], data[8]$ → $[36, 13]$ → 排序后 $[13, 36]$
    \item 子序列5：$data[4], data[9]$ → $[98, 28]$ → 排序后 $[28, 98]$
    \end{itemize}
\item 当$d=2$时，将数组分成2个子序列：
    \begin{itemize}
    \item 子序列1：$data[0], data[2], data[4], data[6], data[8]$ → $[14, 17, 28, 23, 36]$
    \item 子序列2：$data[1], data[3], data[5], data[7], data[9]$ → $[20, 13, 59, 83, 98]$
    \end{itemize}
\item 当$d=1$时，对整个序列进行最后的插入排序
\end{itemize}

\begin{algorithm}[H]
\caption{希尔排序}
\begin{algorithmic}[1]
\REQUIRE 待排序数组$data[0..n-1]$
\ENSURE 排序后的数组
\STATE 初始化增量$d = \lfloor n/2 \rfloor$
\WHILE{$d \geq 1$}
    \FOR{$i = d$ \TO $n-1$}
        \STATE $temp = data[i]$ \COMMENT{暂存待插入记录}
        \STATE $j = i - d$
        \WHILE{$j \geq 0$ \AND $temp < data[j]$}
            \STATE $data[j+d] = data[j]$ \COMMENT{记录后移d个位置}
            \STATE $j = j - d$
        \ENDWHILE
        \STATE $data[j+d] = temp$ \COMMENT{插入到正确位置}
    \ENDFOR
    \STATE $d = \lfloor d/2 \rfloor$ \COMMENT{缩小增量}
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{lstlisting}[caption=希尔排序实现]
void ShellSort(int data[], int n) {
    int d, i, j, temp;
    // 增量序列：n/2, n/4, ..., 1
    for (d = n/2; d >= 1; d = d/2) {
        // 对每个增量d，进行插入排序
        for (i = d; i < n; i++) {
            temp = data[i];  // 暂存待插入记录
            // 在子序列中寻找插入位置
            for (j = i-d; j >= 0 && temp < data[j]; j = j-d) {
                data[j+d] = data[j];  // 记录后移d个位置
            }
            data[j+d] = temp;  // 插入到正确位置
        }
    }
}
\end{lstlisting}

\textbf{算法执行过程示例：}

对于数组$[59, 20, 17, 36, 98, 14, 23, 83, 13, 28]$：

\begin{enumerate}
\item \textbf{第一轮($d=5$)}：
    \begin{itemize}
    \item $i=5$: $temp=14$，与$data[0]=59$比较，$14<59$，交换 → $[14, 20, 17, 36, 98, 59, 23, 83, 13, 28]$
    \item $i=6$: $temp=23$，与$data[1]=20$比较，$23>20$，不交换
    \item $i=7$: $temp=83$，与$data[2]=17$比较，$83>17$，不交换
    \item $i=8$: $temp=13$，与$data[3]=36$比较，$13<36$，交换 → $[14, 20, 17, 13, 98, 59, 23, 83, 36, 28]$
    \item $i=9$: $temp=28$，与$data[4]=98$比较，$28<98$，交换 → $[14, 20, 17, 13, 28, 59, 23, 83, 36, 98]$
    \end{itemize}

\item \textbf{第二轮($d=2$)}：对两个子序列分别进行插入排序

\item \textbf{第三轮($d=1$)}：对整个序列进行最终的插入排序
\end{enumerate}

\begin{theorem}[希尔排序的性能]
\indent
\begin{itemize}
\item \textbf{时间复杂度}：
    \begin{itemize}
    \item 最好情况：$O(n\log n)$
    \item 最坏情况：$O(n^2)$（使用$\{n/2, n/4, \ldots, 1\}$增量序列）
    \item 平均情况：$O(n^{1.3})$（经验值，取决于增量序列的选择）
    \end{itemize}
\item \textbf{空间复杂度}：$O(1)$
\item \textbf{稳定性}：不稳定（相同元素可能被分到不同子序列中）
\item \textbf{增量序列的选择}：
    \begin{itemize}
    \item Shell增量：$\{n/2, n/4, \ldots, 1\}$
    \item Hibbard增量：$\{2^k-1, 2^{k-1}-1, \ldots, 1\}$
    \item Knuth增量：$\{(3^k-1)/2\}$
    \end{itemize}
\end{itemize}
\end{theorem}

\section{交换排序}
\subsection{起泡排序}

\begin{definition}[起泡排序]
起泡排序(Bubble Sort)的基本思想是：通过重复遍历待排序序列，两两比较相邻记录的关键字，如果发现逆序则交换位置，使较大的记录像气泡一样逐渐"浮"到序列的末端，直到整个序列有序为止。
\end{definition}

\textbf{算法核心思想：}
\begin{itemize}
\item 每一趟排序都会将当前未排序部分的最大元素移动到正确位置
\item 通过多趟扫描，逐步缩小未排序区间
\item 利用exchange变量记录最后一次交换位置，优化算法性能
\end{itemize}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 起泡排序过程示意图
    \node at (0, 4) {\textbf{起泡排序执行过程}};
    
    % 初始状态
    \node[left] at (-1, 3) {初始:};
    \foreach \i/\val in {0/64, 1/34, 2/25, 3/12, 4/22, 5/11, 6/90} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm] at (\i*0.7, 3) {\val};
    }
    
    % 第一趟
    \node[left] at (-1, 2) {第1趟:};
    \foreach \i/\val in {0/34, 1/25, 2/12, 3/22, 4/11, 5/64, 6/90} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm] at (\i*0.7, 2) {\val};
    }
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!30] at (5*0.7, 2) {64};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!30] at (6*0.7, 2) {90};
    
    % 第二趟
    \node[left] at (-1, 1) {第2趟:};
    \foreach \i/\val in {0/25, 1/12, 2/22, 3/11, 4/34, 5/64, 6/90} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm] at (\i*0.7, 1) {\val};
    }
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!30] at (4*0.7, 1) {34};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!30] at (5*0.7, 1) {64};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!30] at (6*0.7, 1) {90};
    
    % 最终结果
    \node[left] at (-1, 0) {最终:};
    \foreach \i/\val in {0/11, 1/12, 2/22, 3/25, 4/34, 5/64, 6/90} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (\i*0.7, 0) {\val};
    }
    
    \node at (2.5, -1) {红色表示已排序部分，绿色表示最终排序结果};
\end{tikzpicture}
\end{center}

\begin{algorithm}[H]
\caption{起泡排序算法}
\begin{algorithmic}[1]
\REQUIRE 待排序数组$data[0..n-1]$，数组长度$n$
\ENSURE 按升序排列的数组
\STATE $exchange \leftarrow n-1$ \COMMENT{初始化未排序区间的右边界}
\WHILE{$exchange \neq 0$}
\STATE $bound \leftarrow exchange$ \COMMENT{保存本趟排序的右边界}
\STATE $exchange \leftarrow 0$ \COMMENT{重置交换标志}
\FOR{$j \leftarrow 0$ \TO $bound-1$}
\IF{$data[j] > data[j+1]$}
\STATE 交换$data[j]$和$data[j+1]$
\STATE $exchange \leftarrow j$ \COMMENT{记录最后交换位置}
\ENDIF
\ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{lstlisting}[caption=起泡排序完整实现]
void BubbleSort(int data[], int n) {
    int j, exchange, bound, temp;
    exchange = n-1;  // 第一趟起泡排序的区间是[0~n-1]
    
    while (exchange != 0) {  // 当还有元素需要排序时继续
        bound = exchange;    // 保存本趟排序的右边界
        exchange = 0;        // 重置交换标志，假设本趟无交换
        
        // 从左到右扫描未排序区间
        for (j = 0; j < bound; j++) {
            if (data[j] > data[j+1]) {  // 发现逆序对
                // 交换相邻元素
                temp = data[j]; 
                data[j] = data[j+1]; 
                data[j+1] = temp;
                exchange = j;  // 记录最后一次交换的位置
            }
        }
        // exchange记录了最后一次交换的位置
        // 说明exchange之后的元素已经有序
    }
}
\end{lstlisting}

\textbf{算法执行过程详解：}

对于数组$[64, 34, 25, 12, 22, 11, 90]$的排序过程：

\begin{enumerate}
\item \textbf{第一趟($bound=6$)}：
    \begin{itemize}
    \item 比较64和34：$64>34$，交换 → $[34, 64, 25, 12, 22, 11, 90]$，$exchange=0$
    \item 比较64和25：$64>25$，交换 → $[34, 25, 64, 12, 22, 11, 90]$，$exchange=1$
    \item 比较64和12：$64>12$，交换 → $[34, 25, 12, 64, 22, 11, 90]$，$exchange=2$
    \item 比较64和22：$64>22$，交换 → $[34, 25, 12, 22, 64, 11, 90]$，$exchange=3$
    \item 比较64和11：$64>11$，交换 → $[34, 25, 12, 22, 11, 64, 90]$，$exchange=4$
    \item 比较64和90：$64<90$，不交换
    \end{itemize}
    第一趟结束，$exchange=4$，最大元素90已在正确位置

\item \textbf{第二趟($bound=4$)}：
    \begin{itemize}
    \item 继续对前5个元素进行排序
    \item 最终将64移动到倒数第二个位置
    \end{itemize}

\item \textbf{后续趟数}：重复上述过程，直到$exchange=0$
\end{enumerate}

\begin{theorem}[起泡排序的性能分析]
\indent
\begin{itemize}
\item \textbf{时间复杂度}：
    \begin{itemize}
    \item 最好情况：$O(n)$（序列已有序，只需一趟扫描）
    \item 最坏情况：$O(n^2)$（序列完全逆序）
    \item 平均情况：$O(n^2)$
    \end{itemize}
\item \textbf{空间复杂度}：$O(1)$（只需常数个辅助变量）
\item \textbf{稳定性}：稳定（相等元素的相对位置不会改变）
\item \textbf{适用性}：适用于顺序存储和链式存储
\item \textbf{优化特点}：
    \begin{itemize}
    \item 使用exchange变量记录最后交换位置，避免不必要的比较
    \item 当某趟排序无交换发生时，说明序列已有序，可提前结束
    \end{itemize}
\end{itemize}
\end{theorem}

\textbf{算法优缺点：}
\begin{itemize}
\item \textbf{优点}：
    \begin{itemize}
    \item 实现简单，容易理解
    \item 稳定排序算法
    \item 原地排序，空间复杂度低
    \item 对于小规模或基本有序的数据效果较好
    \end{itemize}
\item \textbf{缺点}：
    \begin{itemize}
    \item 时间复杂度较高，不适合大规模数据排序
    \item 比较次数多，效率相对较低
    \end{itemize}
\end{itemize}

\subsection{快速排序}

\begin{definition}[快速排序]
快速排序(Quick Sort)的基本思想是：首先选定一个轴值(pivot)，将待排序记录划分成两部分，左侧记录均小于或等于轴值，右侧记录均大于或等于轴值，然后分别对这两部分重复上述过程，直到整个序列有序。
\end{definition}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 一次划分示意图
    \node at (0, 3) {选择轴值};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=green!30] at (0, 2) {38};
    
    \node at (-3, 0.5) {$\leq 38$};
    \node at (3, 0.5) {$> 38$};
    
    \foreach \i/\val in {0/27, 1/3, 2/9, 3/10} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=blue!20] at (-3.5+\i*0.9, -0.5) {\val};
    }
    
    \foreach \i/\val in {0/43, 1/82} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=red!20] at (2.5+\i*0.9, -0.5) {\val};
    }
    
    \draw[->] (0, 1.5) -- (-2, 0);
    \draw[->] (0, 1.5) -- (2, 0);
    
    \node at (0, -2) {\textbf{快速排序划分示意图}};
\end{tikzpicture}
\end{center}

\textbf{快速排序详细工作过程：}

以序列$[38, 27, 43, 3, 9, 82, 10]$为例，详细演示快速排序的执行过程：

\textbf{快速排序完整划分过程：}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 第一轮划分
    \node[anchor=east] at (-2, 8) {初始序列:};
    \foreach \i/\val in {0/38, 1/27, 2/43, 3/3, 4/9, 5/82, 6/10} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm] at (\i*0.8, 8) {\val};
    }
    
    \node[anchor=east] at (-2, 7) {第一轮划分:};
    \foreach \i/\val in {0/10, 1/27, 2/9, 3/3} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=blue!20] at (\i*0.8, 7) {\val};
    }
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (3.2, 7) {38};
    \foreach \i/\val in {5/82, 6/43} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!20] at (\i*0.8, 7) {\val};
    }
    
    % 第二轮划分左侧
    \node[anchor=east] at (-2, 6) {第二轮左侧:};
    \foreach \i/\val in {0/3, 1/9} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=blue!20] at (\i*0.8, 6) {\val};
    }
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (1.6, 6) {10};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!20] at (2.4, 6) {27};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (3.2, 6) {38};
    \foreach \i/\val in {5/43, 6/82} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=red!20] at (\i*0.8, 6) {\val};
    }
    
    % 第二轮划分右侧
    \node[anchor=east] at (-2, 5) {第二轮右侧:};
    \foreach \i/\val in {0/3, 1/9} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=blue!20] at (\i*0.8, 5) {\val};
    }
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (1.6, 5) {10};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (2.4, 5) {27};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (3.2, 5) {38};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=blue!20] at (4, 5) {43};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (4.8, 5) {82};
    
    % 第三轮划分
    \node[anchor=east] at (-2, 4) {第三轮划分:};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (0, 4) {3};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (0.8, 4) {9};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (1.6, 4) {10};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (2.4, 4) {27};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (3.2, 4) {38};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (4, 4) {43};
    \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (4.8, 4) {82};
    
    \node[anchor=east] at (-2, 3) {最终结果:};
    \foreach \i/\val in {0/3, 1/9, 2/10, 3/27, 4/38, 5/43, 6/82} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm, fill=green!30] at (\i*0.8, 3) {\val};
    }
    
    % 添加说明
    \node[font=\small] at (2.4, 2) {轴值：绿色 \quad 左子数组：蓝色 \quad 右子数组：红色};
\end{tikzpicture}
\end{center}

\textbf{划分过程说明：}
\begin{enumerate}
\item \textbf{第一轮}：选择38作为轴值，划分为$[10,27,9,3] \mid 38 \mid [82,43]$
\item \textbf{第二轮}：
    \begin{itemize}
    \item 左侧：选择10作为轴值，划分为$[3,9] \mid 10 \mid [27]$
    \item 右侧：选择82作为轴值，划分为$[43] \mid 82 \mid []$
    \end{itemize}
\item \textbf{第三轮}：
    \begin{itemize}
    \item 对$[3,9]$：选择3作为轴值，划分为$[] \mid 3 \mid [9]$
    \item $[27]$、$[43]$、$[9]$均为单元素，无需划分
    \end{itemize}
\item \textbf{最终结果}：所有元素都已排序完成
\end{enumerate}

\textbf{递归处理过程：}

\begin{enumerate}
\item \textbf{处理左子数组$[10, 27, 9, 3]$（选择10作为轴值）}：
    \begin{itemize}
    \item 初始状态：$[10, 27, 9, 3]$，$i=0$，$j=3$
    \item 从右向左扫描：找到$3 < 10$，交换$data[0]$和$data[3]$：$[3, 27, 9, 10]$
    \item 从左向右扫描：找到$27 > 10$，交换$data[1]$和$data[3]$：$[3, 10, 9, 27]$
    \item 继续从右向左扫描：找到$9 < 10$，交换$data[1]$和$data[2]$：$[3, 9, 10, 27]$
    \item $i$和$j$相遇，10已在正确位置，划分结果：$[3, 9] | 10 | [27]$
    \item 递归处理$[3, 9]$：选择3作为轴值，结果为$[] | 3 | [9]$
    \item 递归处理$[9]$：只有一个元素，无需排序
    \item 递归处理$[27]$：只有一个元素，无需排序
    \item 左子数组最终结果：$[3, 9, 10, 27]$
    \end{itemize}

\item \textbf{处理右子数组$[82, 43]$（选择82作为轴值）}：
    \begin{itemize}
    \item 初始状态：$[82, 43]$，$i=0$，$j=1$
    \item 从右向左扫描：找到$43 < 82$，交换$data[0]$和$data[1]$：$[43, 82]$
    \item $i$和$j$相遇，82已在正确位置，划分结果：$[43] | 82 | []$
    \item 递归处理$[43]$：只有一个元素，无需排序
    \item 右子数组最终结果：$[43, 82]$
    \end{itemize}

\item \textbf{合并结果}：$[3, 9, 10, 27] + [38] + [43, 82] = [3, 9, 10, 27, 38, 43, 82]$
\end{enumerate}

\textbf{算法详细步骤分析：}

\begin{algorithm}[H]
\caption{快速排序划分过程详解}
\begin{algorithmic}[1]
\REQUIRE 数组$data[]$，左边界$first$，右边界$last$
\ENSURE 返回轴值的最终位置
\STATE $i \leftarrow first$，$j \leftarrow last$ \COMMENT{初始化左右指针}
\STATE $pivot \leftarrow data[first]$ \COMMENT{选择第一个元素作为轴值}
\WHILE{$i < j$}
    \WHILE{$i < j$ AND $data[j] \geq pivot$} 
        \STATE $j \leftarrow j - 1$ \COMMENT{从右向左扫描}
    \ENDWHILE
    \IF{$i < j$}
        \STATE $data[i] \leftarrow data[j]$ \COMMENT{将小元素移到左边}
        \STATE $i \leftarrow i + 1$
    \ENDIF
    \WHILE{$i < j$ AND $data[i] \leq pivot$} 
        \STATE $i \leftarrow i + 1$ \COMMENT{从左向右扫描} 
    \ENDWHILE
    \IF{$i < j$}
        \STATE $data[j] \leftarrow data[i]$ \COMMENT{将大元素移到右边}
        \STATE $j \leftarrow j - 1$
    \ENDIF
\ENDWHILE
\STATE $data[i] \leftarrow pivot$ \COMMENT{将轴值放到最终位置}
\RETURN $i$ \COMMENT{返回轴值位置}
\end{algorithmic}
\end{algorithm}

\begin{lstlisting}[caption=快速排序实现]
int Partition(int data[], int first, int last) {
    int i = first, j = last, temp;
    while (i < j) {
        while (i < j && data[i] <= data[j]) j--;  // 右侧扫描
        if (i < j) {
            temp = data[i]; data[i] = data[j]; data[j] = temp;
            i++;
        }
        while (i < j && data[i] <= data[j]) i++;  // 左侧扫描
        if (i < j) {
            temp = data[i]; data[i] = data[j]; data[j] = temp;
            j--;
        }
    }
    return i;  // 返回轴值位置
}

void QuickSort(int data[], int first, int last) {
    if (first >= last) return;  // 递归结束条件
    int pivot = Partition(data, first, last);
    QuickSort(data, first, pivot-1);  // 递归排序左子序列
    QuickSort(data, pivot+1, last);   // 递归排序右子序列
}
\end{lstlisting}

\begin{theorem}[快速排序的性能]
\indent
\begin{itemize}
\item \textbf{时间复杂度}：
    \begin{itemize}
    \item 最好情况：$O(n\log n)$
    \item 最坏情况：$O(n^2)$
    \item 平均情况：$O(n\log n)$
    \end{itemize}
\item \textbf{空间复杂度}：$O(\log n) \sim O(n)$（递归栈空间）
\item \textbf{稳定性}：不稳定
\end{itemize}
\end{theorem}

\section{选择排序}

\subsection{简单选择排序}

\begin{definition}[简单选择排序]
简单选择排序(Simple Selection Sort)的基本思想是：第$i$趟排序在待排序序列$r_i \sim r_n$中选取最小的记录，并和第$i$个记录交换作为有序序列的第$i$个记录。
\end{definition}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 选择排序过程示意
    \node at (-2, 3) {初始序列:};
    \foreach \i/\val in {0/38, 1/27, 2/50, 3/13, 4/45} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (\i*1, 3) {\val};
    }
    
    \node at (-2, 2) {第1趟:};
    \foreach \i/\val/\col in {0/13/red, 1/27/gray, 2/50/gray, 3/38/gray, 4/45/gray} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1, 2) {\val};
    }
    
    \node at (-2, 1) {第2趟:};
    \foreach \i/\val/\col in {0/13/red, 1/27/red, 2/50/gray, 3/38/gray, 4/45/gray} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1, 1) {\val};
    }
    
    \node at (-2, 0) {第3趟:};
    \foreach \i/\val/\col in {0/13/red, 1/27/red, 2/38/red, 3/50/gray, 4/45/gray} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1, 0) {\val};
    }
    
    \node at (-2, -1) {第4趟:};
    \foreach \i/\val/\col in {0/13/red, 1/27/red, 2/38/red, 3/45/red, 4/50/red} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1, -1) {\val};
    }
    
    \node at (0, -2) {\textbf{简单选择排序过程}};
    \node at (0, -2.5) {红色表示已排序部分};
\end{tikzpicture}
\end{center}

\textbf{简单选择排序详细工作过程：}

以序列$[64, 25, 12, 22, 11]$为例，详细演示简单选择排序的执行过程：

\begin{center}
\begin{tikzpicture}[scale=1]
    % 初始状态
    \node[anchor=east] at (-1.5, 6) {初始序列:};
    \foreach \i/\val in {0/64, 1/25, 2/12, 3/22, 4/11} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (\i*1.2, 6) {\val};
        \node[below, font=\tiny] at (\i*1.2, 5.4) {\i};
    }
    
    % 第一趟排序
    \node[anchor=east] at (-1.5, 5) {第1趟:};
    \foreach \i/\val/\col in {0/11/green, 1/25/gray, 2/12/gray, 3/22/gray, 4/64/gray} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1.2, 5) {\val};
    }
    
    \node[right, font=\small] at (6, 5) {在位置0-4中找最小值11，与位置0交换};
    
    % 第二趟排序
    \node[anchor=east] at (-1.5, 3.5) {第2趟:};
    \foreach \i/\val/\col in {0/11/green, 1/12/green, 2/25/gray, 3/22/gray, 4/64/gray} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1.2, 3.5) {\val};
    }
    
    \node[right, font=\small] at (6, 3.5) {在位置1-4中找最小值12，与位置1交换};
    
    % 第三趟排序
    \node[anchor=east] at (-1.5, 2) {第3趟:};
    \foreach \i/\val/\col in {0/11/green, 1/12/green, 2/22/green, 3/25/gray, 4/64/gray} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1.2, 2) {\val};
    }
    \node[right, font=\small] at (6, 2) {在位置2-4中找最小值22，与位置2交换};
    
    % 第四趟排序
    \node[anchor=east] at (-1.5, 0.5) {第4趟:};
    \foreach \i/\val/\col in {0/11/green, 1/12/green, 2/22/green, 3/25/green, 4/64/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (\i*1.2, 0.5) {\val};
    }
    
    \node[right, font=\small] at (6, 0.5) {在位置3-4中找最小值25，不需交换};
    
    \node at (2, -1.2) {\textbf{绿色表示已排序部分，灰色表示待排序部分}};
\end{tikzpicture}
\end{center}

\textbf{算法执行详细分析：}

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{趟数} & \textbf{当前位置i} & \textbf{扫描范围} & \textbf{找到的最小值} & \textbf{操作} \\
\hline
1 & 0 & [0,4] & 11(位置4) & 交换data[0]和data[4] \\
\hline
2 & 1 & [1,4] & 12(位置2) & 交换data[1]和data[2] \\
\hline
3 & 2 & [2,4] & 22(位置3) & 交换data[2]和data[3] \\
\hline
4 & 3 & [3,4] & 25(位置3) & 不需要交换 \\
\hline
\end{tabular}
\end{center}

\textbf{算法核心思想：}
\begin{enumerate}
\item 第$i$趟排序$(i=0,1,\ldots,n-2)$：在未排序的元素$data[i] \sim data[n-1]$中找到最小元素
\item 将找到的最小元素与$data[i]$交换位置
\item 排序后，前$i+1$个元素已经有序
\item 重复上述过程，直到整个数组有序
\end{enumerate}

\textbf{详细步骤解析：}

\begin{algorithm}[H]
\caption{简单选择排序详细过程}
\begin{algorithmic}[1]
\REQUIRE 待排序数组$data[0..n-1]$，数组长度$n$
\ENSURE 按升序排列的数组
\FOR{$i \leftarrow 0$ \TO $n-2$} \COMMENT{外层循环，确定第i个位置的元素}
\STATE $minIndex \leftarrow i$ \COMMENT{假设当前位置是最小值位置}
\FOR{$j \leftarrow i+1$ \TO $n-1$} \COMMENT{内层循环，在剩余元素中找最小值}
\IF{$data[j] < data[minIndex]$}
\STATE $minIndex \leftarrow j$ \COMMENT{更新最小值位置}
\ENDIF
\ENDFOR
\IF{$minIndex \neq i$} \COMMENT{如果最小值不在当前位置}
\STATE 交换$data[i]$和$data[minIndex]$ \COMMENT{将最小值放到正确位置}
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\textbf{每趟具体操作流程：}

\begin{itemize}
\item \textbf{第1趟$(i=0)$}：
    \begin{itemize}
    \item 扫描$data[0] \sim data[4]$：$[64, 25, 12, 22, 11]$
    \item 找到最小值$11$（位置4）
    \item 交换$data[0]$和$data[4]$：$[11, 25, 12, 22, 64]$
    \end{itemize}

\item \textbf{第2趟$(i=1)$}：
    \begin{itemize}
    \item 扫描$data[1] \sim data[4]$：$[25, 12, 22, 64]$
    \item 找到最小值$12$（位置2）
    \item 交换$data[1]$和$data[2]$：$[11, 12, 25, 22, 64]$
    \end{itemize}

\item \textbf{第3趟$(i=2)$}：
    \begin{itemize}
    \item 扫描$data[2] \sim data[4]$：$[25, 22, 64]$
    \item 找到最小值$22$（位置3）
    \item 交换$data[2]$和$data[3]$：$[11, 12, 22, 25, 64]$
    \end{itemize}

\item \textbf{第4趟$(i=3)$}：
    \begin{itemize}
    \item 扫描$data[3] \sim data[4]$：$[25, 64]$
    \item 找到最小值$25$（位置3）
    \item 不需要交换：$[11, 12, 22, 25, 64]$
    \end{itemize}
\end{itemize}

\begin{lstlisting}[caption=简单选择排序实现]
void SelectSort(int data[], int n) {
    int i, j, index, temp;
    for (i = 0; i < n-1; i++) {
        index = i;  // 假设第i个位置是最小值位置
        // 在剩余未排序部分找最小值
        for (j = i+1; j < n; j++) {
            if (data[j] < data[index]) 
                index = j;  // 更新最小值位置
        }
        // 如果找到更小的元素，进行交换
        if (index != i) {
            temp = data[i]; 
            data[i] = data[index]; 
            data[index] = temp;
        }
    }
}
\end{lstlisting}

\subsection{堆排序}

\begin{definition}[堆]
堆(Heap)是具有下列性质的完全二叉树：每个结点的值都小于或等于其左右孩子结点的值（小根堆）；或者每个结点的值都大于或等于其左右孩子结点的值（大根堆）。
\end{definition}

\begin{center}
\begin{tikzpicture}[level distance=1.2cm,
level 1/.style={sibling distance=3cm},
level 2/.style={sibling distance=1.5cm},
level 3/.style={sibling distance=0.8cm}]
% 大根堆示例
\node [circle,draw] {50}
    child {node [circle,draw] {45}
        child {node [circle,draw] {40}}
        child {node [circle,draw] {32}}}
    child {node [circle,draw] {36}
        child {node [circle,draw] {30}}
        child {node [circle,draw] {22}}};
\node at (0,-4) {\textbf{大根堆示例}};
\end{tikzpicture}
\end{center}

\begin{algorithm}[H]
\caption{堆调整算法}
\begin{algorithmic}[1]
\REQUIRE 待调整的结点$k$，最后一个结点位置$last$
\ENSURE 调整后的堆
\STATE $i = k$, $j = 2*i+1$ \COMMENT{$j$是$i$的左孩子}
\WHILE{$j \leq last$}
    \IF{$j < last$ \AND $data[j] < data[j+1]$}
        \STATE $j = j + 1$ \COMMENT{$j$指向较大的孩子}
    \ENDIF
    \IF{$data[i] > data[j]$}
        \STATE \textbf{break} \COMMENT{已经是堆}
    \ELSE
        \STATE 交换$data[i]$和$data[j]$
        \STATE $i = j$, $j = 2*i+1$
    \ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{lstlisting}[caption=堆排序实现]
void Sift(int data[], int k, int last) {
    int i, j, temp;
    i = k; j = 2*i+1;  // j是i的左孩子
    while (j <= last) {
        if (j < last && data[j] < data[j+1]) j++;  // j指向较大孩子
        if (data[i] > data[j]) break;  // 已经是堆
        else {
            temp = data[i]; data[i] = data[j]; data[j] = temp;
            i = j; j = 2*i+1;
        }
    }
}

void HeapSort(int data[], int n) {
    int i, temp;
    // 初始建堆
    for (i = (n-2)/2; i >= 0; i--) {
        Sift(data, i, n-1);
    }
    // 排序
    for (i = n-1; i >= 1; i--) {
        temp = data[0]; data[0] = data[i]; data[i] = temp;
        Sift(data, 0, i-1);
    }
}
\end{lstlisting}

\textbf{堆排序详细执行过程：}

以序列$[36, 30, 18, 40, 32, 45, 22, 50]$为例，详细演示堆排序的完整过程：

\textbf{步骤1：初始建堆（构造大根堆）}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 初始状态的完全二叉树
    \node at (-8, 3) {\textbf{初始状态:}};
    \node [circle,draw] (n0) at (-8, 2) {36};
    \node [circle,draw] (n1) at (-9.5, 0.5) {30};
    \node [circle,draw] (n2) at (-6.5, 0.5) {18};
    \node [circle,draw] (n3) at (-10.5, -1) {40};
    \node [circle,draw] (n4) at (-8.5, -1) {32};
    \node [circle,draw] (n5) at (-7.5, -1) {45};
    \node [circle,draw] (n6) at (-5.5, -1) {22};
    \node [circle,draw] (n7) at (-11.5, -2.5) {50};

    \draw (n0) -- (n1);
    \draw (n0) -- (n2);
    \draw (n1) -- (n3);
    \draw (n1) -- (n4);
    \draw (n2) -- (n5);
    \draw (n2) -- (n6);
    \draw (n3) -- (n7);

    % 数组表示
    \node at (-8, -3.5) {数组:};
    \foreach \i/\val in {0/36, 1/30, 2/18, 3/40, 4/32, 5/45, 6/22, 7/50} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm] at (-11+\i*0.8, -4.5) {\val};
        \node[below, font=\tiny] at (-11+\i*0.8, -5) {\i};
    }
\end{tikzpicture}
\end{center}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 调整后的大根堆
    \node at (8, 3) {\textbf{调整后大根堆:}};
    \node [circle,draw] (m0) at (8, 2) {50};
    \node [circle,draw] (m1) at (6.5, 0.5) {40};
    \node [circle,draw] (m2) at (9.5, 0.5) {45};
    \node [circle,draw] (m3) at (5.5, -1) {36};
    \node [circle,draw] (m4) at (7.5, -1) {32};
    \node [circle,draw] (m5) at (8.5, -1) {18};
    \node [circle,draw] (m6) at (10.5, -1) {22};
    \node [circle,draw] (m7) at (4.5, -2.5) {30};

    \draw (m0) -- (m1);
    \draw (m0) -- (m2);
    \draw (m1) -- (m3);
    \draw (m1) -- (m4);
    \draw (m2) -- (m5);
    \draw (m2) -- (m6);
    \draw (m3) -- (m7);

    % 数组表示
    \node at (8, -3.5) {数组:};
    \foreach \i/\val in {0/50, 1/40, 2/45, 3/36, 4/32, 5/18, 6/22, 7/30} {
        \node[draw, rectangle, minimum width=0.6cm, minimum height=0.6cm] at (5+\i*0.8, -4.5) {\val};
        \node[below, font=\tiny] at (5+\i*0.8, -5) {\i};
    }
\end{tikzpicture}
\end{center}

\textbf{建堆过程详解：}

从最后一个非叶子结点开始调整（下标为$\lfloor(n-1)/2\rfloor = 3$的结点40）：

\begin{enumerate}
\item \textbf{调整结点3（值为40）}：
    \begin{itemize}
    \item 40的左孩子是结点7（值为50）
    \item $50 > 40$，交换结点3和结点7：$[36, 30, 18, 50, 32, 45, 22, 40]$
    \end{itemize}

\item \textbf{调整结点2（值为18）}：
    \begin{itemize}
    \item 18的左孩子是结点5（值为45），右孩子是结点6（值为22）
    \item $45 > 22$且$45 > 18$，交换结点2和结点5：$[36, 30, 45, 50, 32, 18, 22, 40]$
    \end{itemize}

\item \textbf{调整结点1（值为30）}：
    \begin{itemize}
    \item 30的左孩子是结点3（值为50），右孩子是结点4（值为32）
    \item $50 > 32$且$50 > 30$，交换结点1和结点3：$[36, 50, 45, 30, 32, 18, 22, 40]$
    \end{itemize}

\item \textbf{调整结点0（值为36）}：
    \begin{itemize}
    \item 36的左孩子是结点1（值为50），右孩子是结点2（值为45）
    \item $50 > 45$且$50 > 36$，交换结点0和结点1：$[50, 36, 45, 30, 32, 18, 22, 40]$
    \item 继续调整结点1（现在值为36）：36的左孩子是结点3（值为30），右孩子是结点4（值为32）
    \item $36 > 32$且$36 > 30$，无需交换
    \end{itemize}
\end{enumerate}

\textbf{步骤2：排序过程}

将堆顶元素与最后一个元素交换，然后重新调整堆：

\textbf{第1次：}
\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-5, 1) {交换50↔30：};
    \foreach \i/\val/\col in {0/30/red, 1/36/blue, 2/45/blue, 3/30/blue, 4/32/blue, 5/18/blue, 6/22/blue, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, 1) {\val};
    }
    
    \node at (-5, -0.5) {调整后：};
    \foreach \i/\val/\col in {0/45/blue, 1/36/blue, 2/22/blue, 3/30/blue, 4/32/blue, 5/18/blue, 6/30/blue, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{第2次：}
\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-5, 1) {交换45↔30：};
    \foreach \i/\val/\col in {0/30/red, 1/36/blue, 2/22/blue, 3/30/blue, 4/32/blue, 5/18/blue, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, 1) {\val};
    }
    
    \node at (-5, -0.5) {调整后：};
    \foreach \i/\val/\col in {0/36/blue, 1/32/blue, 2/22/blue, 3/30/blue, 4/30/blue, 5/18/blue, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{第3次：}
\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-5, 1) {交换36↔18：};
    \foreach \i/\val/\col in {0/18/red, 1/32/blue, 2/22/blue, 3/30/blue, 4/30/blue, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, 1) {\val};
    }
    
    \node at (-5, -0.5) {调整后：};
    \foreach \i/\val/\col in {0/32/blue, 1/30/blue, 2/22/blue, 3/18/blue, 4/30/blue, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{第4次：}
\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-5, 1) {交换32↔30：};
    \foreach \i/\val/\col in {0/30/red, 1/30/blue, 2/22/blue, 3/18/blue, 4/32/green, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, 1) {\val};
    }
    
    \node at (-5, -0.5) {调整后：};
    \foreach \i/\val/\col in {0/30/blue, 1/18/blue, 2/22/blue, 3/30/blue, 4/32/green, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{第5次：}
\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-5, 1) {交换30↔30：};
    \foreach \i/\val/\col in {0/30/red, 1/18/blue, 2/22/blue, 3/30/green, 4/32/green, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, 1) {\val};
    }
    
    \node at (-5, -0.5) {调整后：};
    \foreach \i/\val/\col in {0/22/blue, 1/18/blue, 2/30/blue, 3/30/green, 4/32/green, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{第6次：}
\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-5, 1) {交换22↔30：};
    \foreach \i/\val/\col in {0/30/red, 1/18/blue, 2/22/green, 3/30/green, 4/32/green, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, 1) {\val};
    }
    
    \node at (-5, -0.5) {调整后：};
    \foreach \i/\val/\col in {0/18/blue, 1/30/blue, 2/22/green, 3/30/green, 4/32/green, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{第7次：}
\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-5, 0) {交换18↔30：};
    \foreach \i/\val/\col in {0/18/green, 1/22/green, 2/30/green, 3/30/green, 4/32/green, 5/36/green, 6/45/green, 7/50/green} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=\col!20] at (-3.2+\i*0.8, 0) {\val};
    }
\end{tikzpicture}
\end{center}

\begin{center}
\textbf{颜色说明：}\\
\textcolor{blue!80}{蓝色：未排序部分} \quad 
\textcolor{green!80}{绿色：已排序部分} \quad 
\textcolor{red!80}{红色：需要调整的元素}
\end{center}

\textbf{完整排序过程表格：}

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{交换次数} & \textbf{交换前堆顶} & \textbf{交换的两个元素} & \textbf{调整后的堆} \\
\hline
1 & 50 & 50 ↔ 30 & [45,40,22,36,32,18,30] \\
\hline
2 & 45 & 45 ↔ 30 & [40,36,22,30,32,18] \\
\hline
3 & 40 & 40 ↔ 18 & [36,32,22,30,18] \\
\hline
4 & 36 & 36 ↔ 18 & [32,30,22,18] \\
\hline
5 & 32 & 32 ↔ 18 & [30,18,22] \\
\hline
6 & 30 & 30 ↔ 22 & [22,18] \\
\hline
7 & 22 & 22 ↔ 18 & [18] \\
\hline
\end{tabular}
\end{center}

\begin{example}[堆排序手工模拟]
对序列$\{23, 17, 14, 6, 13, 10, 1, 5, 7, 12\}$进行堆排序。

\textbf{解：}

\textbf{步骤1：建堆}
从最后一个非叶子结点（下标为4的结点13）开始调整：

初始状态：$[23, 17, 14, 6, 13, 10, 1, 5, 7, 12]$

\begin{enumerate}
\item 调整结点4（13）：13的左孩子是12，$13 > 12$，无需调整
\item 调整结点3（6）：6的左孩子是5，右孩子是7，$7 > 6$，交换 → $[23, 17, 14, 7, 13, 10, 1, 5, 6, 12]$
\item 调整结点2（14）：14的左孩子是10，右孩子是1，$14 > 10$且$14 > 1$，无需调整
\item 调整结点1（17）：17的左孩子是7，右孩子是13，$17 > 13$且$17 > 7$，无需调整
\item 调整结点0（23）：23的左孩子是17，右孩子是14，$23 > 17$且$23 > 14$，无需调整
\end{enumerate}

建堆完成：$[23, 17, 14, 7, 13, 10, 1, 5, 6, 12]$

\textbf{步骤2：排序}
重复"交换堆顶与末尾元素，调整堆"的过程：

第1次：$[12, 17, 14, 7, 13, 10, 1, 5, 6, \mathbf{23}]$ → 调整 → $[17, 13, 14, 7, 12, 10, 1, 5, 6, \mathbf{23}]$

第2次：$[6, 13, 14, 7, 12, 10, 1, 5, \mathbf{17, 23}]$ → 调整 → $[14, 13, 10, 7, 12, 6, 1, 5, \mathbf{17, 23}]$

⋮（继续此过程）

最终结果：$[1, 5, 6, 7, 10, 12, 13, 14, 17, 23]$
\end{example}

\begin{theorem}[堆排序的性能]
\indent
\begin{itemize}
\item \textbf{时间复杂度}：$O(n\log n)$（最好、最坏、平均情况相同）
\item \textbf{空间复杂度}：$O(1)$
\item \textbf{稳定性}：不稳定
\item \textbf{优点}：
    \begin{itemize}
    \item 时间复杂度稳定，不受输入数据影响
    \item 原地排序，空间效率高
    \item 适合处理大量数据
    \end{itemize}
\item \textbf{缺点}：
    \begin{itemize}
    \item 不稳定排序
    \item 常数因子较大，实际运行时间较长
    \item 不适合小规模数据排序
    \end{itemize}
\end{itemize}
\end{theorem}

\section{归并排序}

\begin{definition}[二路归并排序]
二路归并排序(2-way Merge Sort)的基本思想是：将待排序序列划分为两个长度相等的子序列，分别对这两个子序列进行排序，得到两个有序子序列，再将这两个有序子序列合并成一个有序序列。
\end{definition}

\begin{center}
\begin{tikzpicture}[scale=1]
    % 分解过程
    \node at (-6, 4) {\textbf{分解过程:}};
    
    % 第一层：原始数组
    \node[draw, rectangle, minimum width=6cm, minimum height=0.8cm] at (0, 3.5) {38 \quad 27 \quad 43 \quad 3 \quad 9 \quad 82 \quad 10};
    
    % 分解箭头
    \draw[->, thick] (-1.5, 3.1) -- (-2.5, 2.4);
    \draw[->, thick] (1.5, 3.1) -- (2.5, 2.4);
    
    % 第二层：分成两部分
    \node[draw, rectangle, minimum width=3cm, minimum height=0.8cm] at (-3, 2) {38 \quad 27 \quad 43 \quad 3};
    \node[draw, rectangle, minimum width=2.5cm, minimum height=0.8cm] at (3, 2) {9 \quad 82 \quad 10};
    
    % 继续分解箭头
    \draw[->, thick] (-4, 1.6) -- (-4.5, 1);
    \draw[->, thick] (-2, 1.6) -- (-1.5, 1);
    \draw[->, thick] (2, 1.6) -- (1.5, 1);
    \draw[->, thick] (4, 1.6) -- (4.5, 1);
    
    % 第三层：继续分解
    \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] at (-4.5, 0.5) {38 \quad 27};
    \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] at (-1.5, 0.5) {43 \quad 3};
    \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] at (1.5, 0.5) {9 \quad 82};
    \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm] at (4.5, 0.5) {10};
    
    % 最后分解箭头
    \draw[->, thick] (-5, 0.1) -- (-5.5, -0.5);
    \draw[->, thick] (-4, 0.1) -- (-3.5, -0.5);
    \draw[->, thick] (-2, 0.1) -- (-2.5, -0.5);
    \draw[->, thick] (-1, 0.1) -- (-0.5, -0.5);
    \draw[->, thick] (1, 0.1) -- (0.5, -0.5);
    \draw[->, thick] (2, 0.1) -- (2.5, -0.5);
    
    % 第四层：单个元素
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (-5.5, -1) {38};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (-3.5, -1) {27};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (-2.5, -1) {43};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (-0.5, -1) {3};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (0.5, -1) {9};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (2.5, -1) {82};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (4.5, -1) {10};
    
    % 合并过程标题
    \node at (-6, -2) {\textbf{合并过程:}};
    
    % 合并箭头（向上）
    \draw[->, thick, red] (-5, -1.6) -- (-4.5, -2.4);
    \draw[->, thick, red] (-4, -1.6) -- (-4.5, -2.4);
    \draw[->, thick, red] (-2, -1.6) -- (-1.5, -2.4);
    \draw[->, thick, red] (-1, -1.6) -- (-1.5, -2.4);
    \draw[->, thick, red] (1, -1.6) -- (1.5, -2.4);
    \draw[->, thick, red] (3, -1.6) -- (1.5, -2.4);
    
    % 第一次合并结果
    \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] at (-4.5, -2.8) {27 \quad 38};
    \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] at (-1.5, -2.8) {3 \quad 43};
    \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] at (1.5, -2.8) {9 \quad 82};
    \node[draw, rectangle, minimum width=1cm, minimum height=0.8cm, fill=green!20] at (4.5, -2.8) {10};
    
    % 第二次合并箭头
    \draw[->, thick, red] (-4, -3.4) -- (-3, -4);
    \draw[->, thick, red] (-2, -3.4) -- (-3, -4);
    \draw[->, thick, red] (2, -3.4) -- (3, -4);
    \draw[->, thick, red] (4, -3.4) -- (3, -4);
    
    % 第二次合并结果
    \node[draw, rectangle, minimum width=3cm, minimum height=0.8cm, fill=blue!20] at (-3, -4.4) {3 \quad 27 \quad 38 \quad 43};
    \node[draw, rectangle, minimum width=2.5cm, minimum height=0.8cm, fill=blue!20] at (3, -4.4) {9 \quad 10 \quad 82};
    
    % 最终合并箭头
    \draw[->, thick, red] (-1.5, -5) -- (0, -5.6);
    \draw[->, thick, red] (1.5, -5) -- (0, -5.6);
    
    % 最终结果
    \node[draw, rectangle, minimum width=6cm, minimum height=0.8cm, fill=yellow!20] at (0, -6) {3 \quad 9 \quad 10 \quad 27 \quad 38 \quad 43 \quad 82};
    
    \node at (0, -7) {\textbf{归并排序过程示意图}};
\end{tikzpicture}
\end{center}

\textbf{归并排序详细执行过程：}

以序列$[38, 27, 43, 3, 9, 82, 10]$为例，详细演示归并排序的完整过程：
\textbf{分解过程：}

\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-10, 6) {\textbf{第1层：原始序列}};
    \foreach \i/\val in {0/38, 1/27, 2/43, 3/3, 4/9, 5/82, 6/10} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (\i*1.2-3.6, 5.5) {\val};
    }
    
    \node at (-10, 4) {\textbf{第2层：分成两部分}};
    \foreach \i/\val in {0/38, 1/27, 2/43, 3/3} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=blue!20] at (\i*1-5, 3.5) {\val};
    }
    \foreach \i/\val in {0/9, 1/82, 2/10} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=red!20] at (\i*1+2, 3.5) {\val};
    }
    
    \node at (-10, 2) {\textbf{第3层：继续分解}};
    \foreach \i/\val in {0/38, 1/27} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=blue!20] at (\i*1-6, 1.5) {\val};
    }
    \foreach \i/\val in {0/43, 1/3} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=blue!20] at (\i*1-3, 1.5) {\val};
    }
    \foreach \i/\val in {0/9, 1/82} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=red!20] at (\i*1+1, 1.5) {\val};
    }
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=red!20] at (4, 1.5) {10};
    
    \node at (-10, 0) {\textbf{第4层：单个元素}};
    \foreach \i/\val in {0/38, 1/27, 2/43, 3/3, 4/9, 5/82, 6/10} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=yellow!20] at (\i*1.5-4.5, -0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{合并过程：}

\textbf{第1次合并：}合并相邻的单个元素

\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-4, 1.5) {合并[38]和[27]};
    \foreach \i/\val in {0/27, 1/38} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=green!20] at (\i*0.7-4, 0.5) {\val};
    }
    
    \node at (-1, 1.5) {合并[43]和[3]};
    \foreach \i/\val in {0/3, 1/43} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=green!20] at (\i*0.7-1, 0.5) {\val};
    }
    
    \node at (2, 1.5) {合并[9]和[82]};
    \foreach \i/\val in {0/9, 1/82} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=green!20] at (\i*0.7+2, 0.5) {\val};
    }
    
    \node at (4.5, 1.5) {[10]保持};
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=green!20] at (4.5, 0.5) {10};
\end{tikzpicture}
\end{center}

\textbf{第2次合并：}合并长度为2的子数组

\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (-2, 1.5) {合并左半部分：[27,38]和[3,43]};
    \foreach \i/\val in {0/3, 1/27, 2/38, 3/43} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=blue!20] at (\i*0.8-3.2, 0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (0, 1.5) {合并右半部分：[9,82]和[10]};
    \foreach \i/\val in {0/9, 1/10, 2/82} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=blue!20] at (\i*0.8-0.8, 0.5) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{左半部分合并详解：}

合并$[27,38]$和$[3,43]$的过程如下：

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{步骤} & \textbf{左指针} & \textbf{右指针} & \textbf{比较} & \textbf{选择元素} \\
\hline
1 & 27 & 3 & $27 > 3$ & 选择3 \\
\hline
2 & 27 & 43 & $27 < 43$ & 选择27 \\
\hline
3 & 38 & 43 & $38 < 43$ & 选择38 \\
\hline
4 & - & 43 & 左数组结束 & 选择43 \\
\hline
\end{tabular}
\end{center}

结果：$[3, 27, 38, 43]$

\textbf{右半部分合并详解：}

合并$[9,82]$和$[10]$的过程如下：

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{步骤} & \textbf{左指针} & \textbf{右指针} & \textbf{比较} & \textbf{选择元素} \\
\hline
1 & 9 & 10 & $9 < 10$ & 选择9 \\
\hline
2 & 82 & 10 & $82 > 10$ & 选择10 \\
\hline
3 & 82 & - & 右数组结束 & 选择82 \\
\hline
\end{tabular}
\end{center}

结果：$[9, 10, 82]$

\textbf{第3次合并：}最终合并

\begin{center}
\begin{tikzpicture}[scale=1]
    \node at (0, 2) {合并[3,27,38,43]和[9,10,82]};
    \node at (0, -0.5) {\footnotesize 详细比较过程如下表：};
    \foreach \i/\val in {0/3, 1/9, 2/10, 3/27, 4/38, 5/43, 6/82} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm, fill=yellow!20] at (\i*0.8-2.4, 1) {\val};
    }
\end{tikzpicture}
\end{center}

\textbf{最终合并过程详解：}

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{步骤} & \textbf{左数组指针} & \textbf{右数组指针} & \textbf{比较} & \textbf{选择元素} \\
\hline
1 & 3 & 9 & $3 < 9$ & 选择3 \\
\hline
2 & 27 & 9 & $27 > 9$ & 选择9 \\
\hline
3 & 27 & 10 & $27 > 10$ & 选择10 \\
\hline
4 & 27 & 82 & $27 < 82$ & 选择27 \\
\hline
5 & 38 & 82 & $38 < 82$ & 选择38 \\
\hline
6 & 43 & 82 & $43 < 82$ & 选择43 \\
\hline
7 & - & 82 & 左数组结束 & 选择82 \\
\hline
\end{tabular}
\end{center}

\begin{example}[归并排序手工模拟]
对序列$\{64, 25, 12, 22, 11\}$进行归并排序。

\textbf{解：}

\textbf{分解过程：}
\begin{enumerate}
\item 原始序列：$[64, 25, 12, 22, 11]$
\item 分解为：$[64, 25, 12]$ 和 $[22, 11]$
\item 继续分解：
    \begin{itemize}
    \item $[64, 25, 12]$ → $[64, 25]$ 和 $[12]$
    \item $[22, 11]$ → $[22]$ 和 $[11]$
    \end{itemize}
\item 最终分解：
    \begin{itemize}
    \item $[64, 25]$ → $[64]$ 和 $[25]$
    \end{itemize}
\end{enumerate}

\textbf{合并过程：}
\begin{enumerate}
\item 合并$[64]$和$[25]$ → $[25, 64]$
\item 合并$[25, 64]$和$[12]$ → $[12, 25, 64]$
\item 合并$[22]$和$[11]$ → $[11, 22]$
\item 最终合并$[12, 25, 64]$和$[11, 22]$ → $[11, 12, 22, 25, 64]$
\end{enumerate}

\textbf{最终合并详细步骤：}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{左指针} & \textbf{右指针} & \textbf{比较} & \textbf{结果} \\
\hline
12 & 11 & $12 > 11$ & [11] \\
\hline
12 & 22 & $12 < 22$ & [11, 12] \\
\hline
25 & 22 & $25 > 22$ & [11, 12, 22] \\
\hline
25 & - & 右数组结束 & [11, 12, 22, 25] \\
\hline
64 & - & 右数组结束 & [11, 12, 22, 25, 64] \\
\hline
\end{tabular}
\end{center}
\end{example}

\begin{algorithm}[H]
\caption{归并排序算法}
\begin{algorithmic}[1]
\REQUIRE 数组$data[]$，左边界$first$，右边界$last$
\ENSURE 排序后的数组
\IF{$first \geq last$}
\RETURN \COMMENT{递归结束条件}
\ENDIF
\STATE $mid \leftarrow \lfloor(first + last)/2\rfloor$ \COMMENT{计算中点}
\STATE MergeSort$(data, first, mid)$ \COMMENT{递归排序左半部分}
\STATE MergeSort$(data, mid+1, last)$ \COMMENT{递归排序右半部分}
\STATE Merge$(data, first, mid, last)$ \COMMENT{合并两个有序子数组}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{合并算法}
\begin{algorithmic}[1]
\REQUIRE 数组$data[]$，左边界$first$，中点$mid$，右边界$last$
\ENSURE 合并后的有序数组
\STATE 创建临时数组$temp[last-first+1]$
\STATE $i \leftarrow first$，$j \leftarrow mid+1$，$k \leftarrow 0$ \COMMENT{初始化指针}
\WHILE{$i \leq mid$ \AND $j \leq last$} \COMMENT{比较并合并}
    \IF{$data[i] \leq data[j]$}
        \STATE $temp[k] \leftarrow data[i]$，$i \leftarrow i+1$
    \ELSE
        \STATE $temp[k] \leftarrow data[j]$，$j \leftarrow j+1$
    \ENDIF
    \STATE $k \leftarrow k+1$
\ENDWHILE
\WHILE{$i \leq mid$} \COMMENT{复制左数组剩余元素}
    \STATE $temp[k] \leftarrow data[i]$，$i \leftarrow i+1$，$k \leftarrow k+1$
\ENDWHILE
\WHILE{$j \leq last$} \COMMENT{复制右数组剩余元素}
    \STATE $temp[k] \leftarrow data[j]$，$j \leftarrow j+1$，$k \leftarrow k+1$
\ENDWHILE
\FOR{$i \leftarrow 0$ \TO $k-1$} \COMMENT{将结果复制回原数组}
    \STATE $data[first+i] \leftarrow temp[i]$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{lstlisting}[caption=归并排序实现]
void Merge(int data[], int first, int mid, int last) {
    int *temp = new int[last-first+1];
    int i = first, j = mid+1, k = 0;
    
    while (i <= mid && j <= last) {
        if (data[i] <= data[j])
            temp[k++] = data[i++];
        else
            temp[k++] = data[j++];
    }
    
    while (i <= mid) temp[k++] = data[i++];
    while (j <= last) temp[k++] = data[j++];
    
    for (i = 0; i < k; i++)
        data[first+i] = temp[i];
    
    delete[] temp;
}

void MergeSort(int data[], int first, int last) {
    if (first >= last) return;
    int mid = (first + last) / 2;
    MergeSort(data, first, mid);
    MergeSort(data, mid+1, last);
    Merge(data, first, mid, last);
}
\end{lstlisting}

\begin{theorem}[归并排序的性能]
\indent
\begin{itemize}
\item \textbf{时间复杂度}：$O(n\log n)$（最好、最坏、平均情况相同）
\item \textbf{空间复杂度}：$O(n)$（需要额外的临时数组）
\item \textbf{稳定性}：稳定
\item \textbf{优点}：
    \begin{itemize}
    \item 时间复杂度稳定，不受输入数据影响
    \item 稳定排序算法
    \item 适合大规模数据排序
    \item 可以很好地利用外存储器
    \end{itemize}
\item \textbf{缺点}：
    \begin{itemize}
    \item 需要额外的存储空间
    \item 对小规模数据排序效率不如简单排序算法
    \end{itemize}
\end{itemize}
\end{theorem}

\section{各种排序方法的比较}

\subsection{时间复杂度比较}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{排序方法} & \textbf{最好情况} & \textbf{平均情况} & \textbf{最坏情况} \\
\hline
直接插入排序 & $O(n)$ & $O(n^2)$ & $O(n^2)$ \\
\hline
希尔排序 & $O(n^{1.3})$ & $O(n\log n) \sim O(n^2)$ & $O(n^2)$ \\
\hline
起泡排序 & $O(n)$ & $O(n^2)$ & $O(n^2)$ \\
\hline
快速排序 & $O(n\log n)$ & $O(n\log n)$ & $O(n^2)$ \\
\hline
简单选择排序 & $O(n^2)$ & $O(n^2)$ & $O(n^2)$ \\
\hline
堆排序 & $O(n\log n)$ & $O(n\log n)$ & $O(n\log n)$ \\
\hline
归并排序 & $O(n\log n)$ & $O(n\log n)$ & $O(n\log n)$ \\
\hline
\end{tabular}
\end{center}

\subsection{空间复杂度和稳定性比较}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{排序方法} & \textbf{空间复杂度} & \textbf{稳定性} \\
\hline
直接插入排序 & $O(1)$ & 稳定 \\
\hline
希尔排序 & $O(1)$ & 不稳定 \\
\hline
起泡排序 & $O(1)$ & 稳定 \\
\hline
快速排序 & $O(\log n) \sim O(n)$ & 不稳定 \\
\hline
简单选择排序 & $O(1)$ & 不稳定 \\
\hline
堆排序 & $O(1)$ & 不稳定 \\
\hline
归并排序 & $O(n)$ & 稳定 \\
\hline
\end{tabular}
\end{center}

\subsection{排序方法的选择}

\begin{enumerate}
\item \textbf{数据规模较小}（$n < 50$）：直接插入排序或简单选择排序
\item \textbf{数据基本有序}：直接插入排序或起泡排序
\item \textbf{数据规模较大}：
    \begin{itemize}
    \item 要求稳定：归并排序
    \item 不要求稳定：快速排序或堆排序
    \end{itemize}
\item \textbf{数据随机分布}：快速排序平均性能最好
\item \textbf{最坏情况要求好}：堆排序或归并排序
\end{enumerate}

\section{典型例题分析}

\begin{example}[直接插入排序过程]
对序列$\{12, 30, 25, 9, 18\}$进行直接插入排序，写出每趟排序的结果。

\textbf{解：}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
初始序列 & 12 & 30 & 25 & 9 & 18 \\
\hline
第1趟 & 12 & 30 & 25 & 9 & 18 \\
\hline
第2趟 & 12 & 25 & 30 & 9 & 18 \\
\hline
第3趟 & 9 & 12 & 25 & 30 & 18 \\
\hline
第4趟 & 9 & 12 & 18 & 25 & 30 \\
\hline
\end{tabular}
\end{center}

详细过程：
\begin{itemize}
\item 第1趟：插入30，30>12，不需移动
\item 第2趟：插入25，25<30，将30后移，25插入到12和30之间
\item 第3趟：插入9，9小于所有已排序元素，全部后移
\item 第4趟：插入18，18介于12和25之间
\end{itemize}
\end{example}

\begin{example}[快速排序一次划分]
对序列$\{23, 13, 35, 6, 19, 50, 28\}$进行一次划分，选择第一个元素作为轴值。

\textbf{解：}
\begin{center}
\begin{tikzpicture}[scale=1]
    % 初始状态
    \node at (-2, 4) {初始:};
    \foreach \i/\val in {0/23, 1/13, 2/35, 3/6, 4/19, 5/50, 6/28} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] (n\i) at (\i*1, 4) {\val};
    }
    \node[above] at (n0) {i};
    \node[above] at (n6) {j};
    
    % 第一次交换
    \node at (-2, 2.5) {第1步:};
    \foreach \i/\val in {0/19, 1/13, 2/35, 3/6, 4/23, 5/50, 6/28} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] (m\i) at (\i*1, 2.5) {\val};
    }
    \node[above] at (m1) {i};
    \node[above] at (m4) {j};
    
    % 第二次交换
    \node at (-2, 1) {第2步:};
    \foreach \i/\val in {0/19, 1/13, 2/6, 3/35, 4/23, 5/50, 6/28} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] (p\i) at (\i*1, 1) {\val};
    }
    \node[above] at (p3) {i};
    \node[above] at (p2) {j};
    
    % 最终结果
    \node at (-2, -0.5) {结果:};
    \foreach \i/\val in {0/19, 1/13, 2/6, 3/23, 4/35, 5/50, 6/28} {
        \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (\i*1, -0.5) {\val};
    }
    
    \node at (3, -2) {轴值23的最终位置：3};
\end{tikzpicture}
\end{center}
\end{example}

\begin{example}[堆排序建堆过程]
将序列$\{36, 30, 18, 40, 32, 45, 22, 50\}$调整为大根堆。

\textbf{解：}
从最后一个非叶子结点开始调整（下标为3的结点40）：

\begin{center}
\begin{tikzpicture}[scale=1]
% 初始状态
\node at (-4.5, 3) {\textbf{初始状态:}};
\node [circle,draw] (n0) at (-4.5, 2) {36};
\node [circle,draw] (n1) at (-6, 0.5) {30};
\node [circle,draw] (n2) at (-3, 0.5) {18};
\node [circle,draw] (n3) at (-7, -1) {40};
\node [circle,draw] (n4) at (-5, -1) {32};
\node [circle,draw] (n5) at (-4, -1) {45};
\node [circle,draw] (n6) at (-2, -1) {22};
\node [circle,draw] (n7) at (-8, -2.5) {50};

\draw (n0) -- (n1);
\draw (n0) -- (n2);
\draw (n1) -- (n3);
\draw (n1) -- (n4);
\draw (n2) -- (n5);
\draw (n2) -- (n6);
\draw (n3) -- (n7);

% 数组表示
\node at (-4.5, -3.5) {数组:};
\foreach \i/\val in {0/36, 1/30, 2/18, 3/40, 4/32, 5/45, 6/22, 7/50} {
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (-7.5+\i*1, -4.5) {\val};
    \node[below, font=\tiny] at (-7.5+\i*1, -5.2) {\i};
}

% 最终状态
\node at (4.5, 3) {\textbf{调整后大根堆:}};
\node [circle,draw] (m0) at (4.5, 2) {50};
\node [circle,draw] (m1) at (3, 0.5) {40};
\node [circle,draw] (m2) at (6, 0.5) {45};
\node [circle,draw] (m3) at (2, -1) {36};
\node [circle,draw] (m4) at (4, -1) {32};
\node [circle,draw] (m5) at (5, -1) {18};
\node [circle,draw] (m6) at (7, -1) {22};
\node [circle,draw] (m7) at (1, -2.5) {30};

\draw (m0) -- (m1);
\draw (m0) -- (m2);
\draw (m1) -- (m3);
\draw (m1) -- (m4);
\draw (m2) -- (m5);
\draw (m2) -- (m6);
\draw (m3) -- (m7);

% 数组表示
\node at (4.5, -3.5) {数组:};
\foreach \i/\val in {0/50, 1/40, 2/45, 3/36, 4/32, 5/18, 6/22, 7/30} {
    \node[draw, rectangle, minimum width=0.8cm, minimum height=0.8cm] at (1.5+\i*0.8, -4.5) {\val};
    \node[below, font=\tiny] at (1.5+\i*0.8, -5.2) {\i};
}
\end{tikzpicture}
\end{center}

调整步骤：
\begin{enumerate}
\item 调整结点40：40>32，不需调整
\item 调整结点18：45>18，交换18和45
\item 调整结点30：40>30，交换30和40
\item 调整结点36：需要多次调整，最终50成为根
\end{enumerate}
\end{example}

\begin{example}[排序算法稳定性判断]
判断以下排序算法的稳定性，并举例说明。

\textbf{解：}
\begin{enumerate}
\item \textbf{直接插入排序}：稳定
    \begin{itemize}
    \item 相等元素不会交换位置
    \item 例：$\{3_a, 1, 3_b\} \rightarrow \{1, 3_a, 3_b\}$
    \end{itemize}

\item \textbf{快速排序}：不稳定
    \begin{itemize}
    \item 划分过程可能改变相等元素的相对位置
    \item 例：$\{3_a, 3_b, 1\}$，选$3_a$为轴值，结果可能为$\{1, 3_b, 3_a\}$
    \end{itemize}

\item \textbf{堆排序}：不稳定
    \begin{itemize}
    \item 建堆和调整过程会破坏相等元素的相对位置
    \item 例：$\{3_a, 3_b, 1\} \rightarrow \{3_b, 1, 3_a\}$（建小根堆）
    \end{itemize}
\end{enumerate}
\end{example}

\begin{example}[时间复杂度分析]
分析在最好、平均、最坏情况下，对n个记录进行快速排序的时间复杂度。

\textbf{解：}
\begin{enumerate}
\item \textbf{最好情况}：每次划分都将序列均分
    \begin{itemize}
    \item 递归深度：$\log_2 n$
    \item 每层时间：$O(n)$
    \item 总时间：$O(n\log n)$
    \end{itemize}

\item \textbf{最坏情况}：每次划分只分出一个元素
    \begin{itemize}
    \item 递归深度：$n-1$
    \item 第$i$次划分：$O(n-i)$
    \item 总时间：$\sum_{i=0}^{n-1}(n-i) = O(n^2)$
    \end{itemize}

\item \textbf{平均情况}：假设每个位置等概率成为轴值位置
    \begin{itemize}
    \item 平均递归深度：$O(\log n)$
    \item 时间复杂度：$O(n\log n)$
    \end{itemize}
\end{enumerate}
\end{example}

\section{复习要点总结}

\subsection{重点掌握内容}

\begin{enumerate}
\item 排序的基本概念：稳定性、内外排序
\item 各种排序算法的基本思想和实现
\item 时间复杂度分析（最好、平均、最坏情况）
\item 空间复杂度和稳定性判断
\item 不同场景下排序算法的选择
\item 排序算法的优化技巧
\end{enumerate}

\subsection{常见考试题型}

\begin{enumerate}
\item 排序算法的手工模拟
\item 时间复杂度和空间复杂度计算
\item 稳定性判断及举例
\item 算法实现（填空或编程）
\item 排序算法的比较和选择
\item 综合应用题
\end{enumerate}

\subsection{记忆技巧}

\begin{enumerate}
\item \textbf{时间复杂度记忆}：
    \begin{itemize}
    \item $O(n^2)$：直接插入、起泡、简单选择（简单算法）
    \item $O(n\log n)$：快速、堆、归并（高效算法）
    \item $O(n) \sim O(n^2)$：希尔（介于两者之间）
    \end{itemize}

\item \textbf{稳定性记忆}：
    \begin{itemize}
    \item 稳定：直接插入、起泡、归并（相邻比较或归并）
    \item 不稳定：希尔、快速、选择、堆（跳跃移动）
    \end{itemize}
\end{enumerate}

\subsection{学习建议}

\begin{enumerate}
\item 理解每种排序算法的核心思想
\item 掌握算法的实现细节和优化技巧
\item 通过手工模拟加深理解
\item 分析不同情况下的性能表现
\item 多做练习题，特别是算法设计题
\item 重点掌握快速排序和堆排序的实现
\end{enumerate}

\end{document} 