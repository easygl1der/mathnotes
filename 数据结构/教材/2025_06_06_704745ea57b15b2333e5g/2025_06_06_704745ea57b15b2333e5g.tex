% This LaTeX document needs to be compiled with XeLaTeX.
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[version=4]{mhchem}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\graphicspath{ {./images/} }
\usepackage{multirow}
\usepackage{underscore}
\usepackage{soul}
\usepackage{color}
\usepackage[fallback]{xeCJK}
\usepackage{polyglossia}
\usepackage{fontspec}
\IfFontExistsTF{Noto Serif CJK JP}
{\setCJKmainfont{Noto Serif CJK JP}}
{\IfFontExistsTF{STSong}
  {\setCJKmainfont{STSong}}
  {\IfFontExistsTF{Droid Sans Fallback}
    {\setCJKmainfont{Droid Sans Fallback}}
    {\setCJKmainfont{SimSun}}
}}
\IfFontExistsTF{Noto Serif CJK KR}
{\setCJKfallbackfamilyfont{\CJKrmdefault}{Noto Serif CJK KR}}
{\IfFontExistsTF{Apple SD Gothic Neo}
  {\setCJKfallbackfamilyfont{\CJKrmdefault}{Apple SD Gothic Neo}}
  {\IfFontExistsTF{UnDotum}
    {\setCJKfallbackfamilyfont{\CJKrmdefault}{UnDotum}}
    {\setCJKfallbackfamilyfont{\CJKrmdefault}{Malgun Gothic}}
}}

\setmainlanguage{english}
\IfFontExistsTF{CMU Serif}
{\setmainfont{CMU Serif}}
{\IfFontExistsTF{DejaVu Sans}
  {\setmainfont{DejaVu Sans}}
  {\setmainfont{Georgia}}
}

\title{include <iostream>}

\author{}
\date{}


%New command to display footnote whose markers will always be hidden
\let\svthefootnote\thefootnote
\newcommand\blfootnotetext[1]{%
  \let\thefootnote\relax\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \let\thefootnote\svthefootnote%
}

%Overriding the \footnotetext command to hide the marker if its value is `0`
\let\svfootnotetext\footnotetext
\renewcommand\footnotetext[2][?]{%
  \if\relax#1\relax%
    \ifnum\value{footnote}=0\blfootnotetext{#2}\else\svfootnotetext{#2}\fi%
  \else%
    \if?#1\ifnum\value{footnote}=0\blfootnotetext{#2}\else\svfootnotetext{#2}\fi%
    \else\svfootnotetext[#1]{#2}\fi%
  \fi
}

\begin{document}
\maketitle
\section*{＂十二五＂普通高等教育本科国家级规划教材}
普通高等教育＂十一五＂国家级规划教材 $\square$\\
教 育 部 普 通 高 等 教 育 精 品 教 材 $\qquad$中国大学出版社图书奖优秀教材一等奖 $\qquad$

\section*{普通高校本科计算机专业特色教材精选，算法与程序设计}
$\square$

\section*{数据结构从概念到C＋＋实现（第3版）}
王红梅 王慧 王新颖 编著

\section*{省级教学名师、数据结构教材王牌作者倾情奉献}
1．合理规划教学内容。紧扣《高等学校计算机专业核心课程教学实施方案》和《计算机学科硕士研究生入学考试大纲》，涵盖教学方案及考研大纲要求的全部知识点。\\
2．遵循认知规律，理清教学主线。根据学生的认知规律和课程的知识结构，按照从已知到未知的思维进程逐步推进教学内容，梳理和规划了各知识单元及其拓扑结构。\\
3．提炼基础知识，适当扩展提高。抓牢核心概念，贯彻数据结构课程的基本教学要求，同时对某些知识点进行了适当的扩充和提高。\\
4．兼顾概念层和实现层。将数据结构的实现过程分为抽象层、设计层和实现层，既强调数据结构的基本概念和原理方法，又注重数据结构的程序实现和实际运用。\\
5．展现求解过程，培养计算思维。按照＂问题 $\rightarrow$ 想法 $\rightarrow$ 算法 $\rightarrow$ 程序＂的模式进行问题求解，采用 ＂阐述基本思想 $\rightarrow$ 伪代码描述算法 $\rightarrow$ C ++ 语言实现算法＂的模式进行算法设计。\\
6．明确重点，化解难点。给出每一章的重点难点、各知识点的教学要求，以及有效的处理方法。针对数据结构内容抽象的特点设计大量图解降低了理解问题的复杂性。

作者相关书籍

\begin{center}
\begin{tabular}{|l|l|}
\hline
书 名 & 书 号 \\
\hline
计算机学科概论（第2版） & 9787302253600 \\
\hline
数据结构（C＋＋版）第2版 & 9787302244165 \\
\hline
数据结构（C＋＋版）学习辅导与实验指导（第2版） & 9787302255291 \\
\hline
数据结构考研辅导（第2版） & 9787302276746 \\
\hline
数据结构（C＋＋版）教师用书 & 9787302151289 \\
\hline
算法设计与分析（第2版） & 9787302307525 \\
\hline
程序设计基础—从问题到程序（第2版） & 9787302411802 \\
\hline
数据结构——人概念到C实现 & 9787302451495 \\
\hline
数据结构——人概念到Java实现 & 9787302513407 \\
\hline
\end{tabular}
\end{center}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-002}
\end{center}

\section*{＂十二五＂普通高等教育本科国家级规划教材}
普通高等教育＂十一五＂国家级规划教材教育部普通高等教育精品教材中国大学出版社图书奖优秀教材一等奖普通高校本科计算机专业特色教材精选，算法与程序设计

\section*{数据结构从概念到C＋＋实现（第3版）}
王红梅 王慧 王新颖 编著

清华大学出版社\\
北京

\section*{内 容 简 介}
数据结构是计算机及相关专业的核心课程，也是计算机及相关专业硕士研究生人学考试的必考科目，而且是理工专业的热门公选课程。本书介绍数据结构、算法以及抽象数据类型的概念；介绍线性表、栈和队列、字符串和多维数组、树和二叉树、图等常用数据结构；讨论查找和排序技术。本书合理规划教学内容，梳理知识单元及其拓扑结构，兼顾概念层和实现层，既强调数据结构的基本概念和原理方法，又注重数据结构的程序实现和实际运用，在提炼基础知识的同时，进行适当的扩展和提高。

本书内容丰富，层次清晰，深人浅出，结合实例，可作为高等学校计算机及相关专业数据结构课程的教材，也可供从事计算机软件开发和应用的工程技术人员参考和阅读。

本书封面贴有清华大学出版社防伪标签，无标签者不得销售。\\
版权所有，侵权必究。侵权举报电话：010－62782989 13701121933

\section*{图书在版编目（CIP）数据}
数据结构 ：从概念到 C＋＋实现／王红梅，王慧，王新颖编著．－3 版．－北京：清华大学出版社，2019 （普通高校本科计算机专业特色教材精选•算法与程序设计）\\
ISBN 978－7－302－50576－1

I．（1）数．．．II．（1）王．．．（2）王．．．（3）王．．．III．（1）数据结构（2） C 语言一程序设计 IV．（1）TP311．12 （2）TP312．8

中国版本图书馆 CIP 数据核字（2018）第141998号

责任编辑：袁勤勇\\
封面设计：常雪影\\
责任校对：李建庄\\
责任印制：宋 林

出版发行：清华大学出版社\\
网 址：http：／／www，tup．com．cn，http：／／www．wqbook．com\\
地 址：北京清华大学学研大厦 A 座 邮 编：100084\\
社 总 机：010－62770175 邮 购：010－62786544\\
投稿与读者服务：010－62776969，c－service＠tup．tsinghua，edu，cn\\
质量反馈：010－62772015，zhiliang＠tup．tsinghua．edu．cn\\
课件下载：http：／／www．tup．com．cn，010－62795954\\
印 装 者：清华大学印刷厂\\
经 销：全国新华书店\\
开 本： $185 \mathrm{~mm} \times 260 \mathrm{~mm}$\\
版 次：2005年7月第1版 2019年5月第3版\\
印 张： 20.25\\
字 数：468 千字

定 价：45．00元\\
印 次：2019年5月第1次印刷

产品编号：078470－01

\section*{前 言}
数据结构是计算机及相关专业的核心课程，也是计算机及相关专业硕士研究生入学考试的必考科目，而且是理工专业的热门公选课程。作为程序设计的重要补充和延伸，数据结构所讨论的知识内容、蕴含的技术方法、体现的思维方式，无论进一步学习计算机专业的其他课程，还是从事计算机领域的各项工作，都有着不可替代的作用。

数据结构课程的知识丰富，内容抽象，隐藏在各知识单元的概念和方法较多，贯穿于各知识单元的链表和递归更是加重了学习难度。笔者长期从事数据结构的研究和教学，深切理解学生在学习数据结构过程中遇到的问题和困惑，深入探究掌握数据结构的有效途径和方法，深刻思考数据结构对培养程序设计和计算思维的地位和作用，深度把握课程的教学目标和重点难点。本书第1版于2005年7月出版，第2版于2011年6月出版，国内有超过 100 所院校将本书作为主讲教材，第 3 版在体例和主要内容保持不变的基础上，在教学内容和教学设计等方面进行了如下处理。\\
（1）合理规划教学内容。紧扣《高等学校计算机专业核心课程教学实施方案》和《计算机学科硕士研究生入学考试大纲》，涵盖教学方案及考研大纲要求的全部知识点。\\
（2）遵循认知规律，厘清教学主线。根据学生的认知规律和课程的知识结构，按照从已知到未知的思维进程逐步推进教学内容，梳理和规划各知识单元及其拓扑结构，设计清晰的教学主线。知识单元及其拓扑结构如图1所示。\\
（3）提炼基础知识，适当扩展提高。考虑到不同学校教学要求的差异以及不同学生学习需求的差别，一方面本着＂够用、实用＂的原则，抓牢核心概念，提炼基础性知识，贯彻数据结构课程的基本教学要求；另一方面对某些知识点进行适当的扩充和提高（图1中打星号部分），这部分内容可用于选讲，也可用于学生自学或课外阅读（教学建议：目录中打一个星号的可用于选讲，打两个星号的可用于课外阅读，其他是必讲的基础知识）。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-006}

图1 数据结构课程的知识单元及拓扑结构\\
（4）兼顾概念层和实现层。从抽象数据类型的角度将数据结构的实现过程分为抽象层、设计层和实现层，其中抽象层定义数据结构和基本操作集合，设计层是数据结构的存储表示和算法设计，实现层用 C＋＋语言实现数据结构，既强调了数据结构的基本概念和原理方法，又注重了数据结构的程序实现和实际运用。\\
（5）展现求解过程，培养计算思维。通过讲思路、讲过程、讲方法，按照＂问题 $\rightarrow$ 想法 $\rightarrow$ 算法 $\rightarrow$ 程序＂的模式进行问题求解，采用＂阐述基本思想 $\rightarrow$ 伪代码描述算法 $\rightarrow$ C＋＋语言实现算法＂的模式进行算法设计与实现，这个过程正是计算思维的运用过程。每章通过两个应用实例展示了问题求解过程以及算法设计过程。\\
（6）明确重点，化解难点。 每一章开篇即给出该章的重点难点，以及各知识点的教学要求，在具体阐述时提供针对性的处理方法。针对数据结构内容抽象的特点，全书设计了大量插图，将抽象内容进行了具体化处理，降低了理解问题的复杂性。

总之，本书在概念的描述、实例的选择、知识的前后衔接、内容的组织结构，以及教学内容的理解、教学目标的实现、教学意图的融入、教学方法的运用等方面进行了系统思考和统筹设计，力图通过本书为读者构建多层次的知识体系。在问题求解层面，以数据表示和数据处理为主线，给出＂问题 $\rightarrow$ 想法 $\rightarrow$ 算法 $\rightarrow$ 程序＂的思维模式；在算法设计层面，通过伪代码描述算法，强调计算思维的培养；在算法分析层面，理解什么是 ＂好＂算法，给出算法分析的基本方法；在存储结构层面，通过存储示意图理解数据表示，再给出存储结构定义；在程序实现层面，给出所有数据结构的 C＋＋程序实现以及使

用范例；在数据结构和算法的运用层面，通过应用实例理解如何为求解问题设计适当的数据结构，如何基于数据结构设计算法，从而将数据结构、算法和程序设计有机地融合在一起。

参加本书编写的还有王涛、党源源、肖巍、刘冰等，2015级本科生陈圣、陈甲旺、房子龙同学参与了本书的代码调试工作，所有代码均在 Dev－C＋＋5．8．1、Code：：Blocks 16．01、C－free 5.0 编程环境下调试通过。本书采用 C＋＋ 11 标准，具体变化是：（1）用 nullptr 取代 NULL；（2）定义模板时，用 typename 取代 class；（3）定义对象变量时，用花括号（1）取代圆括号（）。本书程序源代码均以二维码形式提供，使用前请阅读 readme（二维码）。

由于作者的知识和写作水平有限，书稿虽再三斟酌几经修改，仍难免有缺点，欢迎专家和读者批评指正。作者的电子邮箱是：wanghm＠ccut．edu．cn。

\section*{目录}
第1章 绪论 ..... 1\\
1.1 问题求解与程序设计 ..... 2\\
1．1．1 程序设计的一般过程 ..... 2\\
1．1．2 数据结构在程序设计中的作用 ..... 5\\
1．1．3 算法在程序设计中的作用 ..... 6\\
1．1．4 本书讨论的主要内容 ..... 7\\
1.2 数据结构的基本概念 ..... 9\\
1．2．1 数据结构 ..... 9\\
1．2．2 抽象数据类型 ..... 11\\
1.3 算法的基本概念 ..... 13\\
1．3．1 算法及算法的特性 ..... 13\\
1．3．2 算法的描述方法 ..... 14\\
1.4 算法分析 ..... 16\\
1．4．1 算法的时间复杂度 ..... 16\\
1．4．2 算法的空间复杂度 ..... 18\\
1．4．3 算法分析举例 ..... 18\\
1.5 扩展与提高 ..... 21\\
＊＊1．5．1 从数据到大数据 ..... 21\\
＊＊1．5．2 算法分析的其他渐进符号 ..... 22\\
思想火花——概率算法 ..... 23\\
习题 1 ..... 24\\
第2章 线性表 ..... 27\\
2.1 引言 ..... 28\\
2.2 线性表的逻辑结构 ..... 29\\
2．2．1 线性表的定义 ..... 29\\
2．2．2 线性表的抽象数据类型定义 ..... 30\\
2.3 线性表的顺序存储结构及实现 ..... 31\\
2．3．1 顺序表的存储结构 ..... 31\\
2．3．2 顺序表的实现 ..... 32\\
2．3．3 顺序表的使用 ..... 37\\
2.4 线性表的链接存储结构及实现 ..... 38\\
2．4．1 单链表的存储结构 ..... 38\\
2．4．2 单链表的实现 ..... 40\\
2，4．3 单链表的使用 ..... 48\\
2．4．4 双链表 ..... 49\\
2．4．5 循环链表 ..... 50\\
2.5 顺序表和链表的比较 ..... 51\\
2.6 扩展与提高 ..... 52\\
＊2．6．1 线性表的静态链表存储 ..... 52\\
＊2．6．2 顺序表的动态分配方式 ..... 54\\
2.7 应用实例 ..... 56\\
＊2．7．1 约瑟夫环问题 ..... 56\\
＊2．7．2 一元多项式求和 ..... 59\\
思想火花——好算法是反复努力和重新修正的结果 ..... 63\\
习题 2 ..... 64\\
实验题 2 ..... 67\\
第3章 栈和队列 ..... 69\\
3.1 引言 ..... 70\\
3.2 栈 ..... 71\\
3．2．1 栈的逻辑结构 ..... 71\\
3．2．2 栈的顺序存储结构及实现 ..... 72\\
3．2．3 栈的链接存储结构及实现 ..... 75\\
3．2．4 顺序栈和链栈的比较 ..... 77\\
3.3 队列 ..... 78\\
3．3．1 队列的逻辑结构 ..... 78\\
3．3．2 队列的顺序存储结构及实现 ..... 79\\
3．3．3 队列的链接存储结构及实现 ..... 83\\
3．3．4 循环队列和链队列的比较 ..... 86\\
3.4 扩展与提高 ..... 86\\
＊3．4．1 两栈共享空间 ..... 86\\
＊3．4．2 双端队列 ..... 88\\
3.5 应用举例 ..... 89\\
3．5．1 括号匹配问题 ..... 89\\
3．5．2 表达式求值 ..... 91\\
思想火花——好程序要能识别和处理各种输人 ..... 94\\
习题 3 ..... 95\\
实验题 3 ..... 97\\
第4章 字符串和多维数组 ..... 99\\
4.1 引言 ..... 100\\
4.2 字符串 ..... 101\\
4．2．1 字符串的逻辑结构 ..... 101\\
4．2．2 字符串的存储结构 ..... 103\\
4．2．3 模式匹配 ..... 103\\
4.3 多维数组 ..... 107\\
4．3．1 数组的逻辑结构 ..... 107\\
4．3．2 数组的存储结构与寻址 ..... 108\\
4.4 矩阵的压缩存储 ..... 109\\
4．4．1 特殊矩阵的压缩存储 ..... 109\\
4．4．2 稀疏矩阵的压缩存储 ..... 112\\
4.5 扩展与提高 ..... 114\\
＊＊4．5．1 稀疏矩阵的转置运算 ..... 114\\
＊＊4．5．2 广义表 ..... 116\\
4． 6 应用实例 ..... 119\\
4．6．1 发纸牌 ..... 119\\
4．6．2 八皇后问题 ..... 121\\
思想火花——用常识性的思维去思考问题 ..... 124\\
习题 4 ..... 124\\
实验题 4 ..... 126\\
第5章 树和二叉树 ..... 127\\
5.1 引言 ..... 128\\
5.2 树的逻辑结构 ..... 129\\
5．2．1 树的定义和基本术语 ..... 129\\
5．2．2 树的抽象数据类型定义 ..... 131\\
5．2．3 树的遍历操作 ..... 131\\
5.3 树的存储结构 ..... 132\\
5．3．1 双亲表示法 ..... 132\\
5．3．2 孩子表示法 ..... 132\\
5．3．3 孩子兄弟表示法 ..... 133\\
5.4 二叉树的逻辑结构 ..... 134\\
5．4．1 二叉树的定义 ..... 134\\
5．4．2 二叉树的基本性质 ..... 136\\
5．4．3 二叉树的抽象数据类型定义 ..... 138\\
5．4．4 二叉树的遍历操作 ..... 139\\
5.5 二叉树的存储结构 ..... 140\\
5．5．1 顺序存储结构 ..... 140\\
5．5．2 二叉链表 ..... 141\\
5．5．3 三叉链表 ..... 146\\
5.6 森林 ..... 147\\
5．6．1 森林的逻辑结构 ..... 147\\
5．6．2 树、森林与二叉树的转换 ..... 147\\
5.7 最优二叉树 ..... 149\\
5．7．1 哈夫曼算法 ..... 149\\
5．7．2 哈夫曼编码 ..... 152\\
5.8 扩展与提高 ..... 153\\
＊5．8．1 二叉树遍历的非递归算法 ..... 153\\
＊5．8．2 线索链表 ..... 157\\
5.9 应用实例 ..... 161\\
5．9．1 堆与优先队列 ..... 161\\
5．9．2 并查集 ..... 164\\
思想火花——调试程序与魔术表演 ..... 166\\
习题 5 ..... 167\\
实验题 5 ..... 169\\
第6章 图 ..... 171\\
6.1 引言 ..... 172\\
6.2 图的逻辑结构 ..... 173\\
6．2．1 图的定义和基本术语 ..... 173\\
6．2．2 图的抽象数据类型定义 ..... 176\\
6．2．3 图的遍历操作 ..... 176\\
6.3 图的存储结构及实现 ..... 179\\
6．3．1 邻接矩阵 ..... 179\\
6．3．2 邻接表 ..... 182\\
6．3．3 邻接矩阵和邻接表的比较 ..... 187\\
6.4 最小生成树 ..... 188\\
6．4．1 Prim算法 ..... 189\\
6．4．2 Kruskal 算法 ..... 191\\
6.5 最短路径 ..... 195\\
6．5．1 Dijkstra 算法 ..... 196\\
6．5．2 Floyd 算法 ..... 199\\
6.6 有向无环图及其应用 ..... 200\\
6．6．1 AOV 网与拓扑排序 ..... 201\\
6．6．2 AOE 网与can ..... 203\\
6.7 扩展与提高 ..... 206\\
＊6．7．1 图的其他存储方法 ..... 206\\
＊6．7．2 图的连通性 ..... 208\\
6.8 应用实例 ..... 209\\
6．8．1 七巧板涂色问题 ..... 209\\
6．8．2 医院选址问题 ..... 211\\
思想火花——直觉可能是错误的 ..... 214\\
习题 6 ..... 214\\
实验题 6 ..... 218\\
第7章 查找技术 ..... 219\\
7.1 概述 ..... 220\\
7．1．1 查找的基本概念 ..... 220\\
7．1．2 查找算法的性能 ..... 221\\
7.2 线性表的查找技术 ..... 221\\
7．2．1 线性表查找结构的类定义 ..... 221\\
7．2．2 顺序查找 ..... 222\\
7．2．3 折半查找 ..... 223\\
7.3 树表的查找技术 ..... 226\\
7．3．1 二叉排序树 ..... 226\\
7．3．2 平衡二叉树 ..... 231\\
7．3．3 B 树 ..... 235\\
7.4 散列表的查找技术 ..... 239\\
7．4．1 散列查找的基本思想 ..... 239\\
7．4．2 散列函数的设计 ..... 241\\
7．4．3 处理冲突的方法 ..... 242\\
7．4．4 散列查找的性能分析 ..... 246\\
7．4．5 开散列表与闭散列表的比较 ..... 247\\
7.5 各种查找方法的比较 ..... 247\\
7.6 扩展与提高 ..... 248\\
＊＊7．6．1 顺序查找的改进——分块查找— ..... 248\\
＊＊7．6．2 折半查找的改进——插值查找— ..... 249\\
＊＊7．6．3 B 树的改进—— $\mathrm{B}^{+}$树 ..... 250\\
思想火花——把注意力集中于主要因素，不要纠缠于噪声 ..... 251\\
习题 7 ..... 251\\
实验题 7 ..... 254\\
第8章 排序技术 ..... 255\\
8． 1 概述 ..... 256\\
8．1．1 排序的基本概念 ..... 256\\
8．1．2 排序算法的性能 ..... 257\\
8．1．3 排序类的定义 ..... 257\\
8.2 插人排序 ..... 258\\
8．2．1 直接插人排序 ..... 258\\
8．2．2 希尔排序 ..... 260\\
8.3 交换排序 ..... 262\\
8．3．1 起泡排序 ..... 262\\
8．3．2 快速排序 ..... 264\\
8.4 选择排序 ..... 267\\
8．4．1 简单选择排序 ..... 267\\
8．4．2 堆排序 ..... 269\\
8． 5 归并排序 ..... 274\\
8．5．1 二路归并排序的递归实现 ..... 274\\
8．5．2 二路归并排序的非递归实现 ..... 275\\
8.6 各种排序方法的比较 ..... 277\\
8．6．1 各种排序技术的使用范例 ..... 277\\
8．6．2 各种排序方法的综合比较 ..... 278\\
8.7 扩展与提高 ..... 280\\
＊＊8．7．1 排序问题的时间下界 ..... 280\\
＊8．7．2 基数排序 ..... 281\\
思想火花——学会＂盒子以外的思考＂ ..... 283\\
习题 8 ..... 284\\
实验题 8 ..... 286\\
附录 A 预备知识 ..... 289\\
附录 B C＋＋语言基本语法 ..... 293\\
附录 C 词汇索引 ..... 307\\
参考文献 ..... 311

\section*{1. \\
 绪 论}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
本章概述 & \multicolumn{5}{|c|}{\begin{tabular}{l}
用计算机求解任何问题都离不开程序设计，程序设计的关键是数据表示和数据处理。数据要能被计算机处理，首先必须能够存储在计算机的内存中，这项任务称为数据表示，其核心是数据结构；一个实际问题的求解必须满足各项处理要求，这项任务称为数据处理，其核心是算法，数据结构课程讨论数据表示和数据处理的基本思想和方法。 \\
本章通过二个实例的求解过程给出程序设计的一般过程，说明数据结构和算法在程序设计中的作用，介绍数据结构和算法的基本概念，说明用大 $O$ 记号进行算法分析的基本方法。 \\
\end{tabular}} \\
\hline
教学重点 & \multicolumn{5}{|c|}{数据结构的基本概念；数据的逻辑结构、存储结构以及二者之间的关系；算法及算法的特性；大 $O$ 记号} \\
\hline
教学难点 & \multicolumn{5}{|l|}{抽象数据类型；算法的时间复杂度分析} \\
\hline
\multirow{11}{*}{教学内容和教学目标} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教 学 要 求} \\
\hline
 &  & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline
 & 程序设计的一般过程 & $\checkmark$ &  &  &  \\
\hline
 & 数据结构在程序设计中的作用 &  & $\checkmark$ &  &  \\
\hline
 & 算法在程序设计中的作用 &  & $\checkmark$ &  &  \\
\hline
 & 数据结构的基本概念 &  &  &  & $\checkmark$ \\
\hline
 & 抽象数据类型 &  & $\checkmark$ &  &  \\
\hline
 & 算法及算法的特性 &  &  &  & $\checkmark$ \\
\hline
 & 算法的描述方法 &  &  & $\checkmark$ &  \\
\hline
 & 算法的时间复杂度 &  &  & $\checkmark$ &  \\
\hline
 & 算法的空间复杂度 &  & $\checkmark$ &  &  \\
\hline
\end{tabular}
\end{center}

\section*{1.1 问题求解与程序设计}
计算机科学致力于研究用计算机求解人类生产生活中的各种实际问题，只有最终在计算机上能够运行良好的程序才能解决特定的实际问题，因此，程序设计的过程就是利用计算机求解问题的过程。

\section*{1．1．1 程序设计的一般过程}
用计算机求解任何问题都离不开程序设计，但是计算机不能分析问题并产生问题的解决方案，必须由人（即程序设计者）分析问题，确定问题\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-015}

电子课件的解决方案，采用计算机能够理解的指令描述这个问题的求解步骤（即编写程序），然后让计算机执行程序最终获得问题的解。用计算机求解问题（即程序设计）的一般过程 ${ }^{(1)}$ 如图 1－1 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-015(1)}

图 1－1 程序设计的一般过程\\
由问题到想法需要分析待处理的数据以及数据之间的关系，抽象出具体的数据模型并形成问题求解的基本思路。对于数值问题抽象出的数据模型通常是数学方程，对于非数值问题抽象出的数据模型通常是表、树、图等数据结构。

算法用来描述问题的解决方案，是具体的、机械的操作步骤。利用计算机解决问题的最重要一步是将人的想法描述成算法，也就是从计算机的角度设想计算机是如何一步一步完成这个任务的。由想法到算法需要完成数据表示和数据处理，即描述问题的数据模型，将数据模型从机外表示转换为机内表示；描述问题求解的基本思路，将问题的解决方案形成算法。

由算法到程序需要将算法的操作步骤转换为某种程序设计语言对应的语句，转换所依据的规则就是某种程序设计语言的语法。换言之，就是在某种编程环境下用程序设计语言描述要处理的数据以及数据处理的过程。

著名的计算机学者尼古拉斯－沃思 ${ }^{(2)}$ 给出了一个公式：算法 + 数据结构 $=$ 程序。从

\footnotetext{（1）在作者编著的算法与程序设计系列教材《程序设计基础——从问题到程序》《数据结构——从概念到 C 实现》《数据结构——从概念到 $\mathrm{C}++$ 实现》《数据结构——从概念到 Java 实现》算法设计与分析》中，都是通过这个问题求解过程培养学生的计算思维能力和程序设计能力。\\
（2）尼古拉斯•沃思（Niklaus Wirth） 1934 年生于瑞士。1968 年设计并实现了 Pascal 语言，1971 年提出了结构化程序设计，1976 年设计并实现了 Modula 2 语言。除了程序设计语言之外，沃思在其他方面也有许多创造，如扩充了著名的巴科斯范式，发明了语法图等。1984年获图灵奖。
}这个公式可以看到，数据结构和算法是构成程序的两个重要的组成部分，一个＂好＂程序首先是将问题抽象出一个适当的数据模型并转换为机内表示，然后基于该数据结构设计一个＂好＂算法，或者说，学习数据结构的意义在于编写高质量、高效率的程序。下面以著名的哥尼斯堡七桥问题为例，说明程序设计的一般过程。

【问题】哥尼斯堡七桥问题（以下简称＂七桥问题＂）。17世纪的东普鲁士有一座哥尼斯堡城（现在叫加里宁格勒，在波罗的海南岸）。城中有一座岛，普雷格尔河的两条支流环绕其旁，并将整个城市分成北区、东区、南区和岛区 4 个区域，全城共有七座桥将 4 个城区连接起来，如图1－2（a）所示。于是，产生了一个有趣的问题：一个人是否能在一次步行中经过全部的七座桥后回到出发点，且每座桥只经过一次。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-016}

图 1－2 七桥问题的数据抽象过程\\
【想法】将城区抽象为顶点，用 A、B、C、D 表示 4 个城区。将桥抽象为边，用 7 条边表示七座桥。抽象出七桥问题的数据模型如图 1－2（b）所示，从而将七桥问题抽象为一个数学问题：求经过图中每条边一次且仅一次的回路，后来人们称为欧拉回路。欧拉回路的判定规则是：\\
（1）如果没有一个城区通奇数桥，则无论从哪里出发都能找到欧拉回路；\\
（2）如果通奇数桥的城区多于两个，则不存在欧拉回路；\\
（3）如果只有两个城区通奇数桥，则不存在欧拉回路，但可以从这两个城区之一出发找到欧拉路径（不要求回到出发点）。

由上述判定规则得到求解七桥问题的基本思路：依次计算与每个顶点相关联的边数，根据边数为奇数的顶点个数判定是否存在欧拉回路。

【算法】将顶点 A、B、C、D 编号为 $0 、 1 、 2 、 3$ ，用二维数组 mat［4］［4］存储七桥问题的数据模型，如果顶点 $i(0 \leqslant i \leqslant 3)$ 和顶点 $j(0 \leqslant j \leqslant 3)$ 之间有 $k$ 条边，则元素 mat $[i][j]$ 的值为 $k$ ，如图 1－2（c）所示。求解七桥问题的关键是求与每个顶点相关联的边数，即在二维数组 mat［4］［4］中求每一行元素之和，算法描述如下：

算法：oddVertexNum\\
输人：二维数组mat［］［］，顶点个数 n\\
输出：通奇数桥的顶点个数 count\\
1．count 初始化为 0 ；\\
2．下标 $i$ 从 $0 \sim n-1$ 重复执行下述操作：\\
2.1 计算第 1 行元素之和 degree；

\section*{2.2 如果 degree 为奇数，则 count + ；； \\
 3．返回 count；}
【程序】将函数 oddVertexNum 定义为类 EulerCircuit 的成员函数，类 EulerCircuit 的成员变量表示七桥问题对应的数据模型。主函数首先定义对象变量 G，然后调用函数 oddVertexNum 计算图模型中通奇数桥的顶点个数，再根据欧拉规则判定是否存在欧拉回路。程序\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-017}如下：

\begin{verbatim}
# include <iostream>
using namespace std;
const int MaxSize = 4;
class EulerCirouit
public:
    EulerCirewit(int **a, int n); //构造函数
    ~Fulercircuit(); //析构函数
    int oddVertexNum(); // 求图中度为奇数的顶点个数
private:
    int mat [MaxSize] [MaxSize]; // 一维数组存储图
    int vertexNum; //顶点个数
};
EulerCircuit : : EulerCircuit(int **a, int n)
{
    for(int i = 0; i < n; i++)
        for (int j = 0; j<n; j++)
            mat[i][j]=*((int *)a+n*i+j); //取元素a[i][j]
    vertexNum = n;
}
EulerCircuit : : ~BulerCircuit()
{
}
int EulerCircuit :: oddVertexNum()
{
    int count = 0, i, j, degree;
    for (i = 0; i < vertexNum; i++) //依次累加每一行无素
    l
        degree = 0; //记录通过顶点i的边数
        for (j=0;j<vertexNum; j++)
            degree = degree + mat[i][j];
        if (degree % 2 != 0) count++;
    }
    return count ;
\end{verbatim}

\begin{verbatim}
int main()
1
    int a [4] [4] = {{0, 1, 2, 2},{1,0,1,1},{2,1,0,0},{2,1,0,0});
    EulerCircuit G(a, 4);
    int num = G.oddVertexNum(); //得到通奇数桠的顶点个数
    if (num >= 2) //两个以上的顶点通奇数桥
        cout <<num <<"个地方通奇数桥,不存在欧拉回路" < <endl;
    else
        cout <<"存在欧拉回路" <<endl;
    return 0;
)
\end{verbatim}

\section*{1．1．2 数据结构在程序设计中的作用}
在冯•诺依曼 ${ }^{(1)}$ 体系结构下，程序的原始输入、中间结果和最终输出都以数据的形式存储在计算机的内存中，因此，数据的组织（求解问题的第一步就是将实际问题抽象为合适的数据模型）和存储（将数据模型从机外表示转换为机内表示）将直接影响和决定程序的效率。请看下面两个\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-018}例子。

【例 1－1】 握手问题。Smith 先生和太太邀请 4 对夫妻来参加晚宴。每个人来的时候，房间里的一些人都要和其他人握手。当然，每个人都不会和自己的配偶握手，也不会和同一个人握手两次。之后，Smith 先生问每个人和别人握了几次手，他们的答案都不一样。问题是，Smith 太太和别人握了几次手？

【想法——数据模型】这个问题具有挑战性的原因是没有一个明显的思考点，如果将此问题抽象出一个合适的数据模型，则问题会变得㲅然开朗。

首先将每个人抽象为一个结点，如图 1－3（a）所示。其次考虑每个结点的权值，Smith先生问了房间的 9 个人，每个人的答案都不相同，因此，每个答案都在 0 和 8 之间，相应地修改模型如图1－3（b）所示。最后根据握手信息建立结点之间的边，8号除了他（她）自己和配偶，与房间里的其他人总共握了 8 次手，基于这个观察，可以画出 8 号的握手信息并且知道 8 号的配偶是 0 号，如图1－3（c）所示； 7 号除了 0 号和 1 号，与房间里的其他人总共握了 7 次手，因此 7 号的配偶是 1 号……问题是不是变得㲅然开朗了？

【例 1－2】电话号码查询问题。假设某手机中存储了若干电话号码，如何查找某个人的电话号码？

【想法 1——数据模型】将电话号码集合线性排列（即组织成线性结构），如表1－1所示，则查找某个人的电话号码只能进行顺序查找。

\footnotetext{（1）冯•诺依曼（Von Neumann）1903年出生于匈牙利布达佩斯。19 岁就发表了有影响的数学论文，曾游学柏林大学，成为德国大数学家希尔伯特的得意门生。1933年受聘于美国普林斯顿大学高等研究院，成为爱因斯坦最年轻的同事。冯，诺依曼在数学、应用数学、物理学、博亦论和数值分析等领域都有不凡建树，为计算机的逻辑设计奠定了坚实的基础。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-019(2)}

图 1－3 握手问题的数据模型\\
表 1－1 某手机中的电话号码

\begin{center}
\begin{tabular}{c|c|c|c|c|c|c}
\hline
姓名 & 王靓靓 & 赵 刚 & 韩春颖 & 李琦勇 & $\boldsymbol{\cdots}$ & 张 强 \\
\hline
电话 & 13833278900 & 13944178123 & 15594434552 & 13833212779 & $\boldsymbol{\cdots}$ & 13331688900 \\
\hline
\end{tabular}
\end{center}

【想法 2——数据模型】将电话号码集合进行分组（即组织成树结构），如图 1－4 所示，则查找某个人的电话号码可以只在某个分组中进行。显然，后者的查找效率更高，当数据量较大时差别就更大。可见，一个＂好＂程序首先是将问题抽象出一个适当的数据模型，基于不同数据模型的算法，其运行效率可能会有很大差别。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-019(1)}

图 1－4 分组——将电话号码集合组织为树结构

\section*{1．1．3 算法在程序设计中的作用}
算法是问题的解决方案，这个解决方案本身并不是问题的答案，而是能获得答案的指令序列。对于许多实际的问题，写出一个正确的算法还不够，如果这个算法在规模较大的数据集上运行，那么运行效率就成为一个重要的问题。在选择和设计算法时要有效率的观念，这一点比提高计\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-019}算机本身的速度更为重要 ${ }^{(1)}$ 。例如下面的排序问题。

【例 1－3】排序问题。对整型数组 r［n］进行非降序排列。\\
【算法】有很多排序算法可以解决这个问题，不同排序算法的运行时间有很大差别，起泡排序（请参见 8．3．1节）和快速排序（请参见8．3．2节）在不同数据规模的运行时间 ${ }^{(2)}$

\footnotetext{（1）算法领域有一个启发式规则：不要拘泥于头脑中出现的第一个算法。一个好的算法是反复努力和重新修正的结果，即使足够幸运地得到了一个貌似完美的算法思想，也应该尝试着改进它。\\
（2）实验环境为主频 2.20 GHz 、内存 4 GB 、操作系统 Windows 7、编程环境 Dev C＋＋5．11。
}如表 1－2 所示，随着数据规模的增长，起泡排序和快速排序运行时间的差别越来越大。\\
表 1－2 起泡排序和快速排序的运行时间（单位：s）

\begin{center}
\begin{tabular}{c|c|c|c|c|c}
\hline
数据规模 & 1000 & 10000 & 100000 & 1000000 & 10000000 \\
起泡排序 & 0.003 & 0.395 & 40.276 & 4158.44 & $>100$ 小时 \\
快速排序 & 0 & 0.001 & 0.018 & 0.234 & 5.187 \\
\hline
\end{tabular}
\end{center}

计算机技术的每一个重要进步都与算法研究的突破密切相关。现代计算机在计算能力和存储容量上的革命仅仅提供了计算更复杂问题的有效工具。计算机的应用范围不断扩大，应用问题本身也越来越复杂，我们不仅需要算法，而且需要＂好＂算法。例如，多媒体技术的发展与数据压缩算法的研究密切相关，电子商务、网上银行的发展离不开数据加密算法，阿尔法狗 （AlphaGo）的获胜更是应用了深度学习算法。可以肯定的是，发明（或发\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-020}现）算法是一个非常有创造性和值得付出的过程。

\section*{1．1．4 本书讨论的主要内容}
从数据模型的角度，可以将计算机能够求解的问题分为数值问题和非数值问题。数值问题抽象出的数据模型通常是数学方程，非数值问题抽象出的数据模型通常是表、树、图等数据结构。下面请看几个例子。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-020(2)}

【例 1－4】百元买百鸡问题。已知公鸡 5 元一只，母鸡 3 元一只，小鸡 1 元三只，花 100 元钱买 100 只鸡，问公鸡、母鸡、小鸡各多少只？

【想法——数据模型】设 $x 、 y$ 和 $z$ 分别表示公鸡、母鸡和小鸡的个数，则有如下方程组成立；

$$
\left\{\begin{array} { l } 
{ x + y + z = 1 0 0 } \\
{ 5 \times x + 3 \times y + z / 3 = 1 0 0 }
\end{array} \text { 且 } \left\{\begin{array}{l}
0 \leqslant x \leqslant 20 \\
0 \leqslant y \leqslant 33 \\
0 \leqslant z \leqslant 100
\end{array}\right.\right.
$$

【例 1－5】学籍管理问题。图 1－5（a）所示是一张简单的学生学籍登记表，用计算机来完成学籍管理，实现增、删、改、查等功能。

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
学号 & 姓名 & 性别 & 出生日期 & 政治面貌 \\
\hline
0001 & 陆宇 & 男 & $1997 / 09 / 02$ & 团员 \\
\hline
0002 & 李明 & 男 & $1996 / 12 / 25$ & 党员 \\
\hline
0003 & 汤晓影 & 女 & $1997 / 03 / 26$ & 团员 \\
\hline
$\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
\hline
\end{tabular}
\end{center}

（a）学生学籍登记表\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-020(1)}\\
（b）线性结构

图 1－5 学籍登记表及其数据模型

【想法——数据模型】在学籍管理问题中，计算机的操作对象是每个学生的学籍信息——称为表项，各表项之间的关系可以用线性结构来描述，如图1－5（b）所示。线性结

构也称为表结构或线性表结构。\\
【例 1－6】 人机对弈问题。井字棋又称三子连珠，棋盘为 $3 \times 3$ 的方格，假设游戏者和计算机对弈，当一方的三个棋子占同一行，或同一列，或同一对角线时便为胜方。

【想法——数据模型】在对弈问题中，计算机的操作对象是对弈过程中可能出现的棋盘状态——称为格局，而格局之间的关系是由对弈规则决定的。因为从一个格局可以派生出多个格局，所以，这种关系通常不是线性的。例如，从三子连珠游戏的某格局出发可以派生出 5 个新的格局，从新的格局出发，还可以再派生出新的格局，如图1－6（a）所示。格局之间的关系可以用树结构来描述，如图 1－6（b）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-021(2)}\\
（a）对弈树的局部\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-021}\\
（b）树结构

图 1－6 对率树及其数据模型\\
【例 1－7】七巧板涂色问题。假设有如图 1－7（a）所示七巧板，使用至多 4 种不同颜色对七巧板涂色，要求每个区域涂一种颜色，相邻区域的颜色互不相同。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-021(1)}

图 1－7 七巧板及其数据模型\\
【想法——数据模型】为了识别不同区域的相邻关系，可以将七巧板的每个区域看成一个顶点，如果两个区域相邻，则这两个顶点之间有边相连，则将七巧板抽象为图结构，如图1－7（b）所示。

1968年，克努思教授 ${ }^{(1)}$ 开创了数据结构的最初体系，他所著的《计算机程序设计艺术》第一卷《基本算法》较系统地阐述了数据的逻辑结构和存储结构及其基本操作。20 世纪 70 年代初，数据结构作为一门独立的课程开始进人大学课堂，并且一直是计算机及相关专业重要的专业基础课。本书讨论非数值问题的数据组织和处理，主要内容如下。

\footnotetext{（1）克努思（Donald E．Knuth，1938 年生）1963 年担任加利福尼亚理工学院的教师，1968 年担任斯坦福大学教授。 1992年为集中精力写作而荣誉退休，保留教授头衔。他编著的《计算机程序设计艺术》丛书对计算机科学的发展产生了深远的影响。从某种意义上说，克努思就意味着计算机程序设计艺术，也就意味着数据结构和算法这一类问题的答案。
}
（1）数据的逻辑结构：包括表、树、图等数据结构，其核心是如何组织待处理的数据以及数据之间的逻辑关系。\\
（2）数据的存储结构：如何将表、树、图等数据结构存储到计算机的存储器中，其核心是如何有效地存储数据以及数据之间的逻辑关系。\\
（3）算法：如何基于数据的某种存储结构实现插人、删除、查找等基本操作，其核心是如何有效地处理数据。\\
（4）常用的数据处理技术：包括查找技术和排序技术等。

\section*{1.2 数据结构的基本概念}
\section*{1．2．1 数据结构}
数据（data）是能输人到计算机中并能被计算机程序识别和处理的符号。可以将数据分为两大类：一类是整数、实数等数值数据；另一类是文字、声音、图形和图像 ${ }^{(1)}$ 等非数值数据。数据是计算机程序的处理对象。例如，编译程序处理的数据是源程序；学籍管理程序处理的数据是学籍登\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-022}记表。

数据元素（data element）是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。构成数据元素的最小单位称为数据项（data item），并且数据元素通常具有相同个数和类型的数据项。例如，对于学生学籍登记表，每个学生的档案就是一个数据元素，而档案中的学号、姓名、出生日期等是数据项，如图 1－8 所示。

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
学号 & 姓名 & 性别 & 出生日期 & 政治面貌 & \multirow{2}{*}{数据元素} \\
\hline
0001 & 陆宇 & 男 & $1997 / 09 / 02$ & 团员 &  \\
\hline
0002 & 李明 & 男 & $1996 / 12 / 25$ & 党员 &  \\
\hline
0003 & 汤晓影 & 女 & $1997 / 03 / 26$ & 团员 &  \\
\hline
\end{tabular}
\end{center}

图 1－8 数据元素和数据项\\
数据元素具有广泛的含义，一般来说，能独立、完整地描述问题世界的一切实体都是数据元素。例如，对弈中的棋盘格局、教学计划中的某门课程、一年中的四个季节，甚至一次学术报告、一场足球比赛都可以作为数据元素。在不同的应用场合，数据元素又称为结点、顶点、记录等。

数据结构（data structure）是指相互之间存在一定关系的数据元素的集合。需要强调的是，数据元素是讨论数据结构时涉及的最小数据单位，其中的数据项一般不予考虑。按照视点的不同，数据结构分为逻辑结构和存储结构。

数据的逻辑结构（logical structure）是指数据元素以及数据元素之间的逻辑关系，是

\footnotetext{（1）在计算机中，图形和图像是两个不同的概念。图形一般是指通过绘图软件绘制的，由直线、圆、弧等基本曲线组成的画面，即图形是由计算机产生的；图像是由扫描仪、数码相机等输人设备捕捉的画面，即图像是真实的场景或图片输人计算机的。
}从实际问题抽象出的数据模型，在形式上可定义为一个二元组：

$$
\text { Data_Structure }=(D, R)
$$

其中， D 是数据元素的有限集合， R 是 D 上关系的集合 ${ }^{(1)}$ 。实质上，这个形式定义是对数据模型的一种数学描述，请看下面的例子。

【例 1－8】【图 1－7 所示七巧板涂色问题的数据模型可表示为：DS＿puzzle $=(D, R)$ ，其中， $\mathrm{D}=\{\mathrm{A}, \mathrm{B}, \mathrm{C}, \mathrm{D}, \mathrm{E}, \mathrm{F}, \mathrm{G}\}, \mathrm{R}=\{\langle\mathrm{A}, \mathrm{B}\rangle,\langle\mathrm{A}, \mathrm{E}\rangle,\langle\mathrm{A}, \mathrm{F}\rangle,\langle\mathrm{B}, \mathrm{C}\rangle$ ， $<\mathrm{B}, \mathrm{D}>,<\mathrm{C}, \mathrm{D}>,<\mathrm{D}, \mathrm{E}>,<\mathrm{D}, \mathrm{G}>,<\mathrm{E}, \mathrm{F}>,<\mathrm{E}, \mathrm{G}>\}$ 。

通常用逻辑关系图（logical relation diagram）来描述数据的逻辑结构，其描述方法是：将每一个数据元素看作一个结点，用圆圈表示；元素之间的逻辑关系用结点之间的连线表示，如果强调关系的方向性，则用带箭头的连线表示关系。根据数据元素之间逻辑关系的不同，数据结构分为 4 类，如图 1－9 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-023}

图 1－9 数据结构的逻辑关系图\\
（1）集合结构：数据元素之间就是＂属于同一个集合＂，除此之外，没有任何关系。\\
（2）线性结构：数据元素之间存在着一对一的线性关系。\\
（3）树结构：数据元素之间存在着一对多的层次关系。\\
（4）图结构：数据元素之间存在着多对多的任意关系。\\
树结构和图结构也称为非线性结构 ${ }^{(2)}$ 。\\
数据的存储结构（storage structure）又称为物理结构 ${ }^{(3)}$ ，是数据及其逻辑结构在计算机中的表示（也称映像）。需要强调的是，存储结构除了存储数据元素之外，必须隐式或显式地存储数据元素之间的逻辑关系。通常有两种存储结构 ${ }^{(4)}$ ：顺序存储结构和链接存储结构。顺序存储结构的基本思想是用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。链接存储结构的基本思想是：用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。

【例 1－9】对于 $\mathrm{DS} \_$color $=(\mathrm{D}, \mathrm{R})$ ，其中 $\mathrm{D}=\{$ red，green，blue $\}, \mathrm{R}=\{<$ red，green $>$ ，

\footnotetext{（1）数据元素之间可以具有多元关系，不同关系可能具有不同的数据结构，例如，（D，R1）是一种数据结构，（D， R2）可能是另一种数据结构。本书仅讨论数据元素之间的一元关系。\\
（2）有些教材将树结构称为半线性结构，将图结构称为非线性结构。\\
（3）除特殊说明，数据的存储结构都针对内存，而文件结构常指外存（如磁盘、磁带）中数据的组织。\\
（4）有些教材认为数据的存储结构还包括散列存储和索引存储。实质上，散列存储和索引存储都是面向查找的存储结构，并没有存储元素之间的逻辑关系，因此，严格来说，不是基本的存储结构。
}
＜green，blue＞\}, DS\_color 的顺序存储如图1-10所示, DS\_color的链接存储如图1-11所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-024(2)}

图 1－10 顺序存储示意图\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-024(3)}

图 1－11 链接存储示意图

如图 1－12 所示，数据的逻辑结构是从具体问题抽象出来的数据模型 ${ }^{(1)}$ ，是面向问题的，反映了数据元素之间的关联方式或邻接关系；数据的存储结构是面向计算机的，其基本目标是将数据及其逻辑关系存储到计算机的内存中。数据的逻辑结构和存储结构是密切相关的两个方面。一般来说，一种数据的逻辑结构可以用多种存储结构来存储，而采用不同的存储结构，其数据处理的效率往往是不同的。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-024}

图 1－12 数据的逻辑结构和存储结构之间的关系

\section*{1．2．2 抽象数据类型}
\section*{1．数据类型}
数据类型（data type）是一组值的集合以及定义于这个值集上的一组操作的总称。在用高级语言编写的程序中，每个变量都有一个确定的数\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-024(1)}据类型，用以规定在程序执行期间，该变量的取值范围以及允许进行的操作。例如，C＋＋语言中 int 型变量（假设占 4 个字节）的取值范围是 4 个字节能够表示的最小负整数和最大正整数之间的任何一个整数，允许执行的操作有算术运算（ + 、 、 ＊、 $/ 、 \%$ ）、关系运算（ $<、<=、>、>=、=~=~!~=~$ ）和逻辑运算（ $\& \& 、|\mid$ 、 ）等。

\section*{2．抽象}
所谓抽象（abstract），就是抽出问题本质的特征而忽略非本质的细节，是对具体事物

\footnotetext{（1）在不致混淆的情况下，常常将数据的逻辑结构称为数据结构。
}的一个概括。例如，水果是对苹果、香蕉、橘子等植物果实的一种抽象，地图是对它所描述地域的一种抽象，中国人是对所有具有中国国籍的中国公民的一种抽象。

无论在数学领域还是程序设计领域，抽象的作用都源于这样一个事实：一旦一个抽象的问题得到解决，则很多同类的具体问题便可迎刃而解。抽象还可以实现封装和信息隐藏，抽象的程度越高，对信息及其处理细节的隐藏就越深。例如，C＋＋语言将能够完成某种功能并可重复执行的一段程序抽象为函数，在需要执行这种功能时调用这个函数，从而将＂做什么＂和＂怎么做＂分离开来，实现了算法细节和数据内部结构的隐藏。

\section*{3．抽象数据类型}
抽象数据类型（abstract data type，ADT）是一个数据模型以及定义在该模型上的一组操作的总称。ADT可理解为对数据类型的进一步抽象，数据类型和 ADT 的区别仅在于：数据类型指的是高级程序设计语言支持的基本数据类型，而ADT指的是用户自定义的数据类型。事实上，抽象数据类型理论催生了面向对象程序设计语言的诞生和发展，此类语言的最大特点就是能够实现封装。

如图1－13所示，从抽象数据类型的角度，可以把数据结构的实现过程分为抽象层、设计层和实现层。其中抽象层是ADT的定义，定义数据及其逻辑结构和所允许的基本操作集合。一方面，ADT 的使用者依据这些定义来使用 ADT，即通过操作集合对该 ADT进行操作；另一方面，ADT 的实现者依据这些定义来完成该ADT各种操作的具体实现。设计层是 ADT 的设计，是数据模型的存储表示和算法设计。实现层是 ADT 的具体实现，是用某种程序设计语言来实现数据结构。目前，有两种实现方式：过程化程序设计语言（如 C 语言）和面向对象程序设计语言（如 C＋＋、Java）。C 语言没有可以实现抽象数据类型的相应机制，只能用 typedef 定义数据类型，再分别定义函数来实现基本操作。C＋＋和 Java 语言提供了类（class）定义机制，可以按照抽象数据类型来定义类，即用成员变量描述存储结构，用成员函数实现基本操作。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-025}

图 1－13 数据结构的实现过程\\
一个 ADT 的定义不涉及具体的实现细节，在形式上可繁可简，本书对 ADT 的定义包括抽象数据类型名、数据元素之间逻辑关系的定义、每种基本操作的接口（操作的名称、输人、功能、输出），形式如下：

\begin{verbatim}
ADT 抽象数据类型名
DataModel
\end{verbatim}

\begin{verbatim}
operation
    操作 1
        输人:执行此操作所需要的输人
        功能:该操作将完成的功能
        输出:执行该操作后产生的输出
    操作2
    :
    操作n
    ;
endADT
\end{verbatim}

\section*{1.3 算法的基本概念}
\section*{1．3．1 算法及算法的特性}
\section*{1．什么是算法}
通俗地讲，算法是解决问题的方法。现实生活中关于算法的实例不胜枚举，如一道菜谱、一个安装转椅的操作指南等，再如四则运算法则、算盘的计算口诀等。严格地说，算法 ${ }^{(1)}$（algorithm）是对特定问题求解步骤的一种描述，是指令的有限序列，如图 1－14 所示。此外，算法还必须满足以下基本特性：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-026}

图 1－14 算法的概念\\
（1）有穷性 ${ }^{(2)}$ ：一个算法必须总是（对任何合法的输人）在执行有穷步之后结束，且每一步都在有穷时间内完成。\\
（2）确定性：算法中的每一条指令必须有确切的含义，不存在二义性。并且，在任何条件下，对于相同的输人只能得到相同的输出。\\
（3）可行性：描述算法的每一条指令可以转换为某种程序设计语言对应的语句，并在计算机上可以执行。

通常来说，算法有零个或多个输人（即算法可以没有输人），这些输入通常取自于某个特定的对象集合，但是算法必须要有输出，而且输出与输入之间有着某种特定的关系。

算法和程序不同。程序（program）是对一个算法使用某种程序设计语言的具体实现，原则上，算法可以用任何一种程序设计语言实现。算法的有穷性意味着不是所有的计

\footnotetext{（1）算法的中文名称出自《周髀算经》，英文名称来自于波斯数学家阿勒•霍瓦里松（Al•Khowarizmi）在公元 825 年写的经典著作《代数对话录》。算法之所以被拼写成 algorithm，也是由于和算术（arithmetic）有着密切的联系。\\
（2）算法中有穷的概念不是纯数学的，而是指在实际应用中是合理的，可接受的。
}算机程序都是算法。例如，操作系统是一个在无限循环中执行的程序而不是一个算法，但是可以把操作系统的各个任务看成是一个单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法来实现，得到输出结果后便终止。

\section*{2．什么是＂好＂算法}
一个＂好＂算法首先要满足算法的基本特性，此外还要具备下列特性：\\
（1）正确性 ${ }^{(1)}$ ：算法能满足具体问题的需求，即对于任何合法的输人，算法都会得出正确的结果。\\
（2）健壮性 ${ }^{(2)}$ ：算法对非法输人的抵抗能力，即对于错误的输人，算法应能识别并做出处理，而不是产生错误动作或陷人瘫痪。\\
（3）可理解性：算法容易理解和实现。算法首先是为了人的阅读和交流，其次是为了程序实现，因此，算法要易于被人理解、易于转换为程序。䀲涩难懂的算法可能隐藏一些不易发现的逻辑错误。\\
（4）抽象分级：算法是由人来阅读、理解、使用和修改，研究发现，对大多数人来说，认识限度是 $7 \pm 2^{(3)}$ 。如果算法涉及的步骤太多，人就会糊涂，因此，必须用抽象分级来组织算法表达的思想。理解起来，算法中的每个操作步骤可以是一条简单指令，如果算法的步骤太多（例如，超过 9 步），可以将算法中的相关操作步骤构成一个模块，通过模块调用完成相应功能。\\
（5）高效性：算法的效率包括时间效率和空间效率，时间效率显示了算法运行得有多快；而空间效率则显示了算法需要多少额外的存储空间。不言而喻，一个＂好＂算法应该具有较短的执行时间并占用较少的辅助空间。

\section*{1．3．2 算法的描述方法}
算法设计者在构思和设计了一个算法之后，必须清楚准确地将所设计的求解步骤记录下来，即描述算法。常用的描述算法的方法有自然语言、流程图、程序设计语言和伪代码等。下面以欧几里得算法 ${ }^{(4)}$ 为例进行介绍。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-027}

\section*{1．自然语言}
用自然语言描述算法，最大的优点是容易理解，缺点是容易出现二义性，并且算法通

\footnotetext{（1）有些学者主张将算法的正确性纳人到算法的定义中，因为这是对算法最基本，也是最重要的要求。有些学者反对这个主张，由于测试无法穷尽所有可能的输人，因此大多数算法无法保证对所有合法输人都是正确的。\\
（2）设计算法时可以不考虑健壮性，这些细致的要求应该是软件工程的范畴，但却是好算法的重要标志，例如测试各种可能的极端输人。\\
（3）著名心理学家米勒提出的米勒原则：人类的短期记忆能力一般限于一次记忆 $5 \sim 9$ 个对象，例如几乎所有计算机软件系统的顶层莱单都不超过 9 个。\\
（4）欧几里得算法产生于古希腊（公元前 300 年左右），被公认是第一个算法。设两个自然数 $m$ 和 $n$ 的最大公约数记为 $\operatorname{gcd}(m, n)$ ，欧几里得算法的基本思想是将 $m$ 和 $n$ 辗转相除直到余数为 0 ，例如 $\operatorname{gcd}(35,25)=\operatorname{gcd}(25,10)=$ $\operatorname{gcd}(10,5)=\operatorname{gcd}(5,0)=5$ 。
}常都很冗长。欧几里得算法用自然语言描述如下：\\
步骤 1：将 $m$ 除以 $n$ 得到余数 $r$ 。\\
步骤 2：若 $r$ 等于 0 ，则 $n$ 为最大公约数，算法结束；否则执行步骤 3 。\\
步骤 3 ：将 $n$ 的值放在 $m$ 中，将 $r$ 的值放在 $n$ 中，重新执行步骤 1 。

\section*{2．流程图}
用流程图描述算法，优点是直观易懂，缺点是严密性不如程序设计语言，灵活性不如自然语言。欧几里得算法用流程图描述如图 1－15 所示。在计算机应用早期，很多人使用流程图描述算法，但实践证明，除了描述程序设计语言的语法规则和一些非常简单的算法，这种描述方法使用起来非常不方便。

\section*{3．程序设计语言}
用程序设计语言描述的算法能由计算机直接执行，缺点是抽象性差，使算法设计者拘泥于描述算法的具体细节，忽略了＂好＂算法和正确逻辑的重要性，此外，还要求算法设计者掌握程序设计语言及其编程技巧。欧几里得算法用 $\mathrm{C} / \mathrm{C}++$ 语\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-028}

图 1－15 用流程图描述算法言实现的程序如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-028(1)}

4．伪代码\\
伪代码（pseudo－code）是介于自然语言和程序设计语言之间的方法，它采用某一程序设计语言的基本语法，操作指令可以结合自然语言来设计。至于算法中自然语言的成分有多少，取决于算法的抽象级别。抽象级别高的伪代码自然语言多一些，抽象级别低的伪

代码程序设计语言的语句多一些。欧几里得算法用伪代码描述如下：

\begin{verbatim}
算法:ComFactor
输人:两个自然数 m 和 n
输出:m和n的最大公约数
    1. r=m%n;
    2. 循环直到 r等于 0
        2.1 m=n;
        2.2 n=r;
        2.3r=m%n;
    3. 输出 n;
\end{verbatim}

伪代码不是一种实际的编程语言，但在表达能力上类似于编程语言，同时极小化了描述算法的不必要的技术细节，是比较合适的描述算法的方法，被称为＂算法语言＂或＂第一语言＂。原则上，伪代码不依赖于具体的程序设计语言，换言之，可以用任何一种程序设计语言来实现伪代码。本书采用 C ++ 语言实现伪代码。

\section*{1.4 算 法 分 析}
如何度量一个算法的效率呢？一种方法是事后统计，将算法实现，然后输入适当的数据运行，测算其时间和空间开销。事后统计的方法至少有以下缺点：（1）编写程序实现算法将花费较多的时间和精力；（2）所得实验结果依赖于计算机的软硬件等环境因素，有时容易掩盖算法本身的优劣。通常采用事前分析估算的方法 ${ }^{(1)}$ —渐进复杂度（asymptotic complexity），它是对算法所消耗资源的一种估算方法。

\section*{1．4．1 算法的时间复杂度}
同一个算法用不同的程序设计语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行，效率均不相同。敵开与计算机软硬件有关的因素，影响算法时间代价的最主要因素是问题规模。问题规模 （problem scope）是指输人量的多少，一般来说，它可以从问题描述中得到。例如，找出 100 以内的所有素数，问题规模是 100 ；对一个具有 $n$ 个整数的数组进行排序，问题规模是 $n$ 。一个显而易见的事实是：几乎所有的\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-029}算法，对于规模更大的输人需要运行更长的时间。例如，找出 10000 以内的所有素数比找出 100 以内的所有素数需要更多的时间；待排序的数据量 $n$ 越大就需要越多的时间。所以运行算法所需要的时间 $T$ 是问题规模 $n$ 的函数，记作 $T(n)$ 。

要精确地表示算法的运行时间函数常常是很困难的，即使能够给出，也可能是个相当复杂的函数，函数的求解本身也是相当复杂的。为了客观地反映一个算法的执行时间，可以用算法中基本语句的执行次数来度量算法的工作量。基本语句（basic statement）是执行

\footnotetext{（1）估算方法是工程学课程的基本内容之一，它不能代替对一个问题的严格细节分析，但是，如果估算表明一个方法不可行，那么进一步的分析就没有必要了。
}次数与整个算法的执行次数成正比的语句，基本语句对算法运行时间的贡献最大，是算法中最重要的操作。这种衡量效率的方法得出的不是时间量，而是一种增长趋势的度量 ${ }^{(1)}$ 。换言之，只考察当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶，称作算法的渐进时间复杂度，简称时间复杂度（time complexity），通常用大 $O$ 记号表示 ${ }^{(2)}$ 。

定义 1－1 若存在两个正的常数 $c$ 和 $n_{0}$ ，对于任意 $n \geqslant n_{0}$ ，都有 $T(n) \leqslant c \times f(n)$ ，则称 $T(n)=O(f(n))$（读作＂ T n 是 Of n 的＂）。

该定义说明了函数 $T(n)$ 和 $f(n)$ 具有相同的增长趋势，并且 $T(n)$ 的增长至多趋同于函数 $f(n)$ 的增长。大 $O$ 记号用来描述增长率的上限，也就是说，当输人规模为 $n$ 时，算法耗费时间的最大值，其含义如图 1－16 所示。

算法的时间复杂度分析是一种估算技术，若两个算法中一个总是比另一个＂稍快一点＂时，它并不能判断那个＂稍快一点＂的算法的相对优越\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-030}

图 1－16 大 $O$ 记号的含义性。但是在实际应用中，它被证明是很有效的，尤其是确定算法是否值得实现的时候。常见的时间复杂度如下：

$$
O\left(\log _{2} n\right)<O(n)<O\left(n \log _{2} n\right)<O\left(n^{2}\right)<O\left(n^{3}\right)<\cdots<\mathrm{O}\left(2^{n}\right)<O(n!)
$$

算法的时间复杂度是衡量一个算法优劣的重要标准。一般来说，具有多项式时间复杂度的算法是可接受的、可使用的算法，具有指数时间复杂度的算法，只有当问题规模足够小的时候才是可使用的算法 ${ }^{(3)}$ 。表1－3给出了多项式增长和指数增长的比较，可以看到多项式函数与指数函数的增长率有本质的差别。

表 1－3 多项式增长和指数增长的比较

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multirow{2}{*}{问题规模 $n$} & \multicolumn{5}{|c|}{多项式增长} & \multicolumn{2}{|c|}{指数增长} \\
\hline
 & $\log _{2} n$ & $n$ & $n \log _{2} n$ & $n^{2}$ & $n^{3}$ & $2^{n}$ & $n$ ！ \\
\hline
1 & 0.00 & 1 & 0.00 & 1 & 1 & 2 & 1 \\
\hline
2 & 1.00 & 2 & 2.0 & 4 & 8 & 4 & 2 \\
\hline
3 & 1.60 & 3 & 4.8 & 9 & 27 & 8 & 3 \\
\hline
4 & 2.00 & 4 & 8.0 & 16 & 64 & 16 & 24 \\
\hline
5 & 2． 32 & 5 & 11.6 & 25 & 125 & 32 & 120 \\
\hline
6 & 2.58 & 6 & 15.5 & 36 & 216 & 64 & 720 \\
\hline
7 & 2.81 & 7 & 19.7 & 49 & 343 & 128 & 5040 \\
\hline
8 & 3，00 & 8 & 24.0 & 64 & 512 & 256 & 40320 \\
\hline
9 & 3． 16 & 9 & 28.5 & 81 & 729 & 512 & 362800 \\
\hline
\end{tabular}
\end{center}

\footnotetext{（1）算法时间复杂度的思维抽象过程如下：算法的运行时间 $=$ 每条语句的执行时间之和 $\rightarrow$ 每条语句的执行次数之和 $\rightarrow$ 基本语句的执行次数 $\rightarrow$ 基本语句执行次数的数量级 $\rightarrow$ 大 $O$ 记号表示。\\
（2）算法的时间复杂度分析最初因 Knuth 在其经典著作 The Art of Computer Programming 中使用而流行，大 O 记号（读作＂大欧＂）也是 Knuth 在这本书中提倡的。\\
（3）存在多项式时间算法的问题称为易解问题，需要指数时间算法的问题称为难解问题。关于指数时间算法类问题的界定和研究属于计算复杂性理论的范畴，本书主要讨论多项式时间算法。
}续表

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
\multirow{2}{*}{问题规模 $n$} & \multicolumn{5}{|c|}{多项式增长} & \multicolumn{2}{|c|}{指数增长} \\
\hline
 & $\log _{2} n$ & $n$ & $n \log _{2} n$ & $n^{2}$ & $n^{3}$ & $2^{n}$ & $n$ ！ \\
\hline
10 & 3.32 & 10 & 33.2 & 100 & 1000 & 1024 & 3628800 \\
\hline
20 & 4.32 & 20 & 86.4 & 400 & 8000 & 1048376 & 2．4E18 \\
\hline
30 & 4.91 & 30 & 147.3 & 900 & 27000 & 1．0E9 & 2．7E32 \\
\hline
40 & 5． 32 & 40 & 212.8 & 1600 & 64000 & 1．0E12 & 8．2E47 \\
\hline
50 & 5． 64 & 50 & 282.2 & 2500 & 125000 & 1．0E15 & 3．0E64 \\
\hline
100 & 6.64 & 100 & 664.4 & 10000 & 1．0E6 & 1．3E30 & 9．3E157 \\
\hline
\end{tabular}
\end{center}

\section*{1．4．2 算法的空间复杂度}
算法在运行过程中所需的存储空间包括：（1）输入／输出数据占用的空间；（2）算法本身占用的空间；（3）执行算法需要的辅助空间。其中，输人／输出数据占用的空间取决于问题，与算法无关；算法本身占用的空间虽然与算法相关，但一般其大小是固定的。所以，算法的空间复杂度 （space complexity）是指算法在执行过程中需要的辅助空间数量，也就是除算法本身和输人输出数据所占用的空间外，算法临时开辟的存储空间。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-031}

如果算法所需的辅助空间相对于问题规模来说是一个常数，称此算法为原地（或就地）工作，否则，这个辅助空间数量也应该是问题规模的函数，通常记作：

$$
S(n)=O(f(n))
$$

其中，$n$ 为问题规模，分析方法与算法的时间复杂度类似。

\section*{1．4．3 算法分析举例}
定理 1－1 若 $A(n)=a_{m} n^{m}+a_{m-1} n^{m-1}+\cdots+a_{1} n+a_{0}$ 是一个 $m$ 次多项式，则 $A(n)=O\left(n^{m}\right)$ 。

定理 1－1 说明，在计算任何算法的时间复杂度时，可以忽略所有低次幂和最高次幂的系数，这样能够简化算法分析，并且使注意力集中在最重\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-031(1)}要的一点——增长率上。

\section*{1．非递归算法的时间性能分析}
对非递归算法时间复杂度的分析，关键是建立一个代表算法运行时间的求和表达式，然后用渐进符号表示这个求和表达式。

【例 1－10】 求＂++x ；＂的时间复杂度。\\
解：++x 是基本语句，执行次数为 1 ，时间复杂度为 $O(1)$ ，称为常量阶 ${ }^{(1)}$ 。\\
【例 1－11】求下面程序段的时间复杂度。

\footnotetext{（1）只要 $T(n)$ 不是问题规模 $n$ 的函数，而是一个常数，其时间复杂度均为 $O(1)$ 。
}\begin{verbatim}
for (i = 1; i <= n;++i)
    ++x;
\end{verbatim}

解：++x 是基本语句，执行次数为 $n$ ，时间复杂度为 $O(n)$ ，称为线性阶。\\
【例 1－12】求下面程序段的时间复杂度。

\begin{verbatim}
for (i=1;i<=n;++1)
    for (j=1;j<=n;++j)
        ++x;
\end{verbatim}

解：++x 是基本语句，执行次数为 $n^{2}$ ，时间复杂度为 $O\left(n^{2}\right)$ ，称为平方阶。\\
【例 1－13】求下面程序段的时间复杂度。

\begin{verbatim}
for (i = 1; i <= n;++i)
    for (j=1;j<=n;++j)
    f
        c[i][j] = 0;
        for (k = 1;k<=n;++k)
            c[i][j] += a[i][k] * b[k][j];
\end{verbatim}

解： $\mathrm{c}[\mathrm{i}][\mathrm{j}]+=\mathrm{a}[\mathrm{i}][\mathrm{k}] * \mathrm{~b}[\mathrm{k}][\mathrm{j}]$ 是基本语句，由于是一个三重循环，每个循环从 1到 $n$ ，所以总的执行次数为 $n^{3}$ ，时间复杂度为 $O\left(n^{3}\right)$ ，称为立方阶。

【例 1－14】求下面程序段的时间复杂度。

\begin{verbatim}
for (i=1;i<=n;++i)
    for (j=1;j<=1-1;++j)
        ++x;
\end{verbatim}

解：++x 是基本语句，执行次数为：$\sum_{i=1}^{n} \sum_{j=1}^{i-1} 1=\sum_{i=1}^{n}(i-1)=\frac{n(n-1)}{2}$ ，所以时间复杂度为 $O\left(n^{2}\right)$ 。分析的策略是从内部（或最深层部分）向外展开。

【例 1－15】求下面程序段的时间复杂度。

\begin{verbatim}
for (i = 1; i <= n; i = 2 * i)
    ++x;
\end{verbatim}

解：++x 是基本语句，设其执行次数为 $T(n)$ ，则有 $2^{T(n)} \leqslant n$ ，即 $T(n) \leqslant \log _{2} n$ ，所以时间复杂度为 $O\left(\log _{2} n\right)$ ，称为对数阶。

\section*{2．递归算法的时间性能分析}
对递归算法时间复杂度的分析，关键是根据递归过程建立递推关系式，然后求解这个递推关系式。通常用扩展递归技术将递推关系式中等式右边的项根据递推式进行替换，

这称为扩展，扩展后的项被再次扩展，依此下去，就会得到一个求和表达式。\\
【例 1－16】 使用扩展递归技术分析递推式 $T(n)=\left\{\begin{array}{ll}7 & n=1 \\ 2 T(n / 2)+5 n^{2} & n>1\end{array}\right.$ 的时间复杂度。

解：简单起见，假定 $n=2^{k}$ 。将递推式进行扩展：

$$
\begin{aligned}
T(n) & =2 T(n / 2)+5 n^{2} \\
& =2\left(2 T(n / 4)+5(n / 2)^{2}\right)+5 n^{2} \\
& =2\left(2\left(2 T(n / 8)+5(n / 4)^{2}\right)+5(n / 2)^{2}\right)+5 n^{2} \\
& =2^{k} T(1)+2^{k-1} 5\left(\frac{n}{2^{k-1}}\right)^{2}+\cdots+2 \times 5\left(\frac{n}{2}\right)^{2}+5 n^{2}
\end{aligned}
$$

最后这个表达式可以使用如下的求和表示：

$$
\begin{aligned}
T(n) & =7 n+5 \sum_{i=0}^{k-1}\left(\frac{n}{2^{i}}\right)^{2}=7 n+5 n^{2}\left(2-\frac{1}{2^{k-1}}\right) \\
& =7 n+5 n^{2}\left(2-\frac{2}{n}\right)=10 n^{2}-3 n \leqslant 10 n^{2} \\
& =O\left(n^{2}\right)
\end{aligned}
$$

递归算法一般存在如下通用分治递推式：

\[
T(n)=\left\{\begin{array}{cc}
c & n=1  \tag{1-1}\\
a T(n / b)+c n^{k} & n>1
\end{array}\right.
\]

其中 $a, b, c, k$ 都是常数。这个递推式描述了大小为 $n$ 的原问题被分成若干个大小为 $n / b$的子问题，其中 $a$ 个子问题需要求解，而 $c n^{k}$ 是合并各个子问题的解需要的工作量。

定理 1－2 设 $T(n)$ 是非递减函数，且满足通用分治递推式，则有如下结果成立：

$$
T(n)= \begin{cases}O\left(n^{\log _{b} a}\right) & a>b^{k} \\ O\left(n^{k} \log _{b} n\right) & a=b^{k} \\ O\left(n^{k}\right) & a<b^{k}\end{cases}
$$

【例 1－17】设某算法运行时间的递推式描述为：$T(n)=\left\{\begin{array}{ll}1 & n=2 \\ 2 T(n / 2)+n & n>2\end{array}\right.$ ，分析该算法的时间复杂度。

解：根据定理 1－2，有 $a=2, b=2, c=1, k=1$ 成立，即满足 $a=b^{k}$ ，因此 $T(n)=$ $O\left(n \log _{2} n\right)$ 。

\section*{3．最好、最坏和平均情况}
对于某些算法，即使问题规模相同，如果输人数据不同，其时间开销也不同。此时，就需要分析最好、最坏以及平均情况的时间性能。

【例 1－18】在一维整型数组 $\mathrm{A}[\mathrm{n}]$ 中顺序查找与给定值 k 相等的元素，算法如下：

\begin{verbatim}
int Find(int A[], int n, int k)
i
    for (int i = 0; i<n; 1++)
\end{verbatim}

\begin{verbatim}
    if (A[i] == k) break;
    return i; //返回元素 k 的下标,返回 n时表示查找失败
}
\end{verbatim}

顺序查找从第一个元素开始，依次比较每一个元素，直至找到 $k$ 为止。如果数组的第一个元素恰好就是 $k$ ，只需比较 1 次，这是最好情况；如果数组的最后一个元素是 $k$ ，就要比较 $n$ 次，这是最坏情况；如果在数组中查找不同的元素 $k$ ，假设数据是等概率分布，则平均要比较 $n / 2$ 次，这是平均情况 ${ }^{(1)}$ 。

一般来说，最好情况不能代表算法性能，因为它发生的概率较小。但是，当最好情况出现概率较大的时候，应该分析最好情况；分析最差情况有一个好处，即可以知道算法的运行时间最坏能坏到什么程度，这一点在实时系统中尤其重要；通常需要分析平均情况的时间代价，特别是算法要处理不同的输人时，但它要求已知输人数据是如何分布的。通常假设等概率分布，例如，顺序查找算法在平均情况下的时间性能，如果数据不是等概率分布，那么算法的平均情况就不一定是查找一半的元素了。

\section*{1.5 扩展与提高}
\section*{1．5．1 从数据到大数据}
传统意义上的数据指的是有根据的数字。人类在实践中发现，仅仅用语言、文字和图形来描述这个世界，常常是不精确的。例如，有人问＂姚明有多高＂，如果回答说＂很高＂或 ＂非常高＂，听的人只能得到一个抽象的概念，因为每个人对＂很＂或＂非常＂有不同的理解，但如果说＂ 2.26 米＂就一清二楚了。除了描述世界，数据还是人类改造世界的重要工具。人类的一切生产、交换活动，可以说都是以数据为基础展开的，例如，度量衡、货币、股票的背后都是数据。

数据最早来源于测量，所谓有根据的数字，是指数据是对客观世界的测量结果。除了测量，数据经过计算还可以产生新的数据。测量和计算都是人为的，也就是说，世上本没有数据，一切数据都是人为的产物，我们说的原始数据，仅仅是指第一手的、没有经过人为修改的数据。进人信息时代之后，数据的内涵开始扩大：数据是指一切存储在计算机中的信息，包括文本、图片、音频、视频等。文本、音频、视频等数据的来源不是对世界的测量，而是对世界的一种记录，所以，信息时代的数据又多了一个来源：记录。

随着计算机科学技术的发展，数据除了内涵的扩大，还出现了另外一个重要现象，从科学研究到医疗保险，从银行业到互联网，各个不同的领域都在讲述着一个类似的故事，那就是爆发式增长的数据。2003年，人类第一次破译人体基因密码的时候，辛苦工作了十年才完成了三十亿对碱基对的排序。大约十年之后，一个普通的基因仪 15 分钟就可以完成同样的工作。美国股市每天的成交量高达 70 亿股，而其中三分之二的交易都是由建

\footnotetext{（1）通常用 $T_{B}(n)$ 表示最好情况（best），用 $T_{W}(n)$ 表示最坏情况（worst），用 $T_{E}(n)$ 表示平均情况，平均情况通常指的是期望情况（expected）。
}立在数学模型和算法之上的计算机程序自动完成的，这些程序运用海量数据来预测利益和降低风险。谷歌公司每天要处理超过 24 PB 的数据，这意味着其每天的数据处理量是美国国家图书馆所有纸质出版物所含数据量的上千倍。

人类数据的真正爆炸发生在社交媒体时代。从2004年开始，以脸谱网（Facebook）、推特（Twitter）为代表的社交媒体相继问世，拉开了互联网的崭新时代。FaceBook 每天更新的照片量超过 1000 万张，每天人们在网站上点击按钮或写评论大约有 30 亿次。 Twitter 上的信息量几乎每年翻一番，每天都会发布超过 4 亿条微博。由于社交媒体的出现，全世界的网民都开始成为数据的生产者，每个网民都犹如一个信息系统、一个传感器，不断地制造数据，这引发了人类历史上最庞大的数据爆炸。除了数据总量骤然增加，社交媒体还使人类的数据世界更为复杂：在大家发的微博中，你带的图片、他带的视频，大小、结构完全不一样，这被称为非结构化数据。

1965年，英特尔的创始人之一戈登•摩尔在考察了计算机硬件的发展规律之后，提出了著名的摩尔定律：同一面积芯片上可容纳的晶体管数量，一到两年将增加一倍。回顾这半个多世纪的历史，硬件的发展基本符合摩尔定律。正是因为存储器的价格在半个世纪之内经历了空前绝后的下降，人类才可能以非常低廉的成本保存海量的数据，这为大数据时代的到来铺平了硬件道路。除了便宜、功能强大，摩尔定律也导致各种计算设备的体积变得越来越小。今天，小小的智能手机，其功能毫不逊色于一台普通的计算机，各种传感器越做越小，可穿戴设备又向我们走来。

大数据之大，不仅在于其大容量，更在于其大价值。价值在于使用，如同埋在地底下的石油，远古即已有之，人类进人石油时代，是因为掌握了开采、冶炼石油的技术。现在进人大数据时代，其最根本的原因，是人类使用数据的能力取得了重大突破和进展，这种突破集中表现在数据挖掘上。数据挖掘是指通过特定的算法对大量的数据进行自动分析，从而揭示数据当中隐藏的规律和趋势，在大量的数据中发现新知识，为决策者提供参考。大数据的核心就是预测，是把数学算法运用到大数据上来预测事情发生的可能性。例如，亚马逊根据用户在网站上的类似查询来进行产品推荐，FaceBook 和 Twitter 通过用户的社交网络图来得知用户的喜好。

大数据的成因，是人类信息技术的进步，而且是不同时期多个进步交互作用的结果，如图 1－17 所示。回顾半个多世纪人类信息社会的历史，正是因为1965年提出的摩尔定律，晶体管越做越小、成本越来越低，才形成了大数据的物理基础；1989年兴起的数据挖掘，相当于把原油炼成石油的技术，是让大数据产生大价值的关键；2004年出现的社交媒体，则把全世界每个人都变成了潜在的数据生成器，为世界贡献了大数据。

大数据正在成为巨大的经济资产，成为新世纪的矿产与石油，将带来全新的创业方向、商业模式和投资机会。大数据产生后，全世界的科学家都在预测和观望，这股由信息技术掀起的新浪潮对人类社会将产生何种影响，将带领我们的世界走向何方？

\section*{1．5．2 算法分析的其他渐进符号}
定义 1－2 若存在两个正的常数 $c$ 和 $n_{0}$ ，对于任意 $n \geqslant n_{0}$ ，都有 $T(n) \geqslant c \times g(n)$ ，则称 $T(n)=\Omega(g(n))$（或称算法在 $\Omega(g(n))$ 中）。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-036(2)}

图 1－17 大数据的三大成因\\
定义 1－2 说明了函数 $T(n)$ 和 $f(n)$ 具有相同的增长趋势，并且 $T(n)$ 的增长至少趋同于函数 $f(n)$ 的增长。大 $\Omega$ 符号用来描述增长率的下限，也就是说，当输人规模为 $n$ 时，算法消耗时间的最小值。大 $\Omega$ 符号的含义如图 1－18 所示。与大 $O$ 符号对称，这个下限的阶越高，结果就越有价值。

大 $\Omega$ 符号通常用来分析某个问题或某类算法的时间下界。例如，矩阵乘法问题的时间下界为 $\Omega\left(n^{2}\right)$ ，是指任何两个 $n \times n$ 矩阵相乘的算法，其时间复杂度不会小于 $n^{2}$ ，基于比较的排序算法的时间下界为 $\Omega\left(n \log _{2} n\right)$ ，是指任何基于比较的排序算法，其时间复杂度不会小于 $n \log _{2} n$ 。

定义 1－3 若存在三个正的常数 $c_{1} 、 c_{2}$ 和 $n_{0}$ ，对于任意 $n \geqslant n_{0}$ ，都有 $c_{1} \times f(n) \geqslant T(n) \geqslant$ $c_{2} \times f(n)$ ，则称 $T(n)=\Theta(f(n))$ 。\\
$\Theta$ 符号意味着 $T(n)$ 与 $f(n)$ 同阶，通常用来表示算法的精确阶，其含义如图 1－19所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-036}

图 1－18 大 $\Omega$ 符号的含义\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-036(1)}

图 1－19＠符号的含义

\section*{思想火花——概率算法}
假设你意外地得到了一张藏宝图，但是，可能的藏宝地点有两个，要到达其中一个地点，或者从一个地点到达另一个地点都需要 5 天的时间。你需要 4 天的时间解读藏宝图，得出确切的藏宝位置，但是一旦出发后就不允许再解读藏宝图。更麻烦的是，有另外一个人知道这个藏宝地点，每天都会拿走一部分宝藏。不过，有一个小精灵可以告诉你如何解

读藏宝图，它的条件是，需要支付给它相当于知道藏宝地点的那个人 3 天拿走的宝藏。如何做才能得到更多的宝藏呢？

假设你得到藏宝图时剩余宝藏的总价值是 $x$ ，知道藏宝地点的那个人每天拿走宝藏的价值是 $y$ ，并且 $x>9 y$ ，可行的方案有：\\
（1）用 4 天的时间解读藏宝图，用 5 天的时间到达藏宝地点，可获宝藏价值 $x-9 y$ ；\\
（2）接受小精灵的条件，用 5 天的时间到达藏宝地点，可获宝藏价值 $x-5 y$ ，但需付给小精灵宝藏价值 $3 y$ ，最终可获宝藏价值 $x-8 y$ ；\\
（3）投掷硬币决定首先前往哪个地点，如果发现地点是错的，就前往另一个地点。这样，你就有一半的机会获得宝藏价值 $x-5 y$ ，另一半的机会获得宝藏价值 $x-10 y$ ，所以，最终可获宝藏价值 $x-7.5 y$ 。

当面临一个选择时，如果计算正确选择的时间大于随机确定一个选择的时间，那么，就应该随机选择一个。同样，当算法在执行过程中面临一个选择时，有时候随机地选择算法的执行动作可能比花费时间计算哪个是最优选择要好。随机从某种角度来说就是运气，在算法中增加这种随机性的因素，通常可以引导算法快速地求解问题。

例如，判断表达式 $f\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ 是否恒等于 0 。概率算法首先生成一个随机 $n$元向量 $\left(r_{1}, r_{2}, \cdots, r_{n}\right)$ ，并计算 $f\left(r_{1}, r_{2}, \cdots, r_{n}\right)$ 的值，如果 $f\left(r_{1}, r_{2}, \cdots, r_{n}\right) \neq 0$ ，则 $f\left(x_{1}, x_{2}, \cdots, x_{n}\right) \neq 0$ ；如果 $f\left(r_{1}, r_{2}, \cdots, r_{n}\right)=0$ ，则或者 $f\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ 恒等于 0 ，或者是向量 $\left(r_{1}, r_{2}, \cdots, r_{n}\right)$ 比较特殊，如果这样重复几次，继续得到 $f\left(r_{1}, r_{2}, \cdots, r_{n}\right)=0$的结果，那么就可以得出 $f\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ 恒等于 0 的结论，并且测试的随机向量越多，这个结果出错的可能性就越小。

概率算法（probabilistic algorithm）把＂对于所有合理的输人都必须给出正确的输出＂这一求解问题的条件放宽，允许算法在执行过程中随机选择下一步该如何进行，同时允许结果以较小的概率出现错误，并以此为代价，获得算法运行时间的大幅度减少。如果一个问题没有有效的确定性算法可以在一个合理的时间内给出解答，但是，该问题能接受小概率的错误，那么，概率算法也许可以快速找到这个问题的解。

\section*{习 题 1}
\section*{1．选择题}
（1）顺序存储结构中数据元素之间的逻辑关系是由（ ）表示的，链接存储结构中的数据元素之间的逻辑关系是由（ ）表示的。\\
A．线性结构\\
B．非线性结构\\
C．存储位置\\
D．指针\\
（2）假设有如下遗产继承规则：丈夫和妻子可以相互继承遗产；子女可以继承父亲或母亲的遗产；子女间不能相互继承。则表示该遗产继承关系的数据结构应该是（）。\\
A．树\\
B．图\\
C．线性表\\
D．集合\\
（3）计算机所处理的数据一般具有某种内在联系，这是指（ ）。\\
A．数据和数据之间存在某种关系\\
B．元素和元素之间存在某种关系

C．元素内部具有某种结构\\
D．数据项和数据项之间存在某种关系\\
（4）对于数据结构的描述，下列说法中不正确的是 。\\
A．相同的逻辑结构对应的存储结构也必相同\\
B．数据结构由逻辑结构、存储结构和基本操作三方面组成\\
C．对数据结构基本操作的实现与存储结构有关\\
D．数据的存储结构是数据的逻辑结构的机内实现\\
（5）算法指的是 。\\
A．对特定问题求解步骤的一种描述，是指令的有限序列\\
B．计算机程序\\
C．解决问题的计算方法\\
D．数据处理\\
（6）下面（ ）不是算法所必须具备的特性。\\
A．有穷性\\
B．确切性\\
C．高效性\\
D．可行性\\
（7）算法分析的目的是 ，算法分析的两个主要方面是 。\\
A．找出数据结构的合理性\\
B．研究算法中输人和输出的关系\\
C．分析算法的效率以求改进\\
D．分析算法的易读性和文档性\\
E．空间性能和时间性能\\
F．正确性和简明性\\
G．可读性和文档性\\
H．数据复杂性和程序复杂性\\
（8）假设时间复杂度为 $O\left(n^{2}\right)$ 的算法在有 200 个元素的数组上运行需要 3.1 ms ，则在有 400 个元素的数组上运行需要 ms 。\\
A． 3.1\\
B． 6.2\\
C． 12,4\\
D． 9.61\\
（9）下列程序段加下画线的语句执行 次。

\begin{verbatim}
for ( }m=0,i=1;i<=n;i++
    for (j=1;j<=2*i;j++)
        m = m + 1;
\end{verbatim}

A．$n^{2}$\\
B． $3 n$\\
C．$n(n+1)$\\
D．$n^{3}$

2．分析以下各程序段，并用大 $O$ 记号表示其执行时间\\
（1） $\mathrm{i}=1$ ； $\mathrm{k}=0$ ；\\
while（i＜＝n）\\
\textbackslash ｛\\
$k=k+10 * i ;$\\
i++;

（2）$i=1 ; k=0$ ；\\
do\\
i\\
$\mathrm{k}=\mathrm{k}+10 * \mathrm{i}$;\\
i++;\\
\} while (i <= n);

\begin{verbatim}
(3) i = 1; j = 0;
    while (i+j <= n)
        if (i > j) j++;
        else i++;
\end{verbatim}

（4）$y=0$ ；\\
while $((y+1) *(y+1)<=n)$\\
$y=y+1 ;$\\
（5）for（ $\mathrm{i}=1 ; \mathrm{i}<=\mathrm{n} ; \mathrm{i}++$ ）\\
for（ $\mathrm{j}=1 ; \mathrm{j}<=\mathrm{i} ; \mathrm{j}++$ ）\\
for $(\mathrm{k}=1 ; \mathrm{k}<=\mathrm{j} ; \mathrm{k}++)$\\
x＋＋；

\begin{verbatim}
（6）for（ $\mathrm{i}=1 ; \mathrm{i}<=\mathrm{n}$ ； $\mathrm{i}++$ ）
for $(j=2 * i ; j<=n ; j++)$
\end{verbatim}

\begin{verbatim}

\end{verbatim}

\section*{3．解答下列问题}
（1）假设有数据结构 $(D, R)$ ，其中 $D=\{1,2,3,4,5,6\}, R=\{(1,2),(1,4)$ ， $(2,3),(2,4),(3,4),(3,5),(3,6),(4,5),(5,6)\}$ 。试画出其逻辑结构图并指出属于何种结构。\\
（2）为整数定义一个抽象数据类型，包含整数的常用运算，每个运算对应一个基本操作，每个基本操作的接口需定义输入、功能和输出。\\
（3）求多项式 $A(x)$ 的算法可根据下列两个公式之一来设计：\\
（1）$A(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\cdots+a_{1} x+a_{0}$\\
（2）$A(x)=\left(\cdots\left(a_{n} x+a_{n-1}\right) x+\cdots+a_{1}\right) x+a_{0}$\\
根据算法的时间复杂度分析比较这两种算法的优劣。

\section*{4．算法设计（要求：分别用伪代码和 $\mathbf{C}++$ 语言描述算法，并分析时间复杂度）}
（1）找出整型数组 $\mathrm{A}[\mathrm{n}]$ 中的最大值和次最大值。\\
（2）判断给定字符串是否是回文。所谓回文是正读和反读均相同的字符串，例如 ＂abcba＂或＂abba＂是回文，而＂abcda＂不是回文。\\
（3）已知数组 $\mathrm{A}[\mathrm{n}]$ 中的元素为整型，设计算法将其调整为左右两部分，左边所有元素为奇数，右边所有元素为偶数，并要求算法的时间复杂度为 $O(n)$ 。\\
（4）荷兰国旗问题。要求重新排列一个由字符 $R, W, B(R$ 代表红色，$W$ 代表白色， $B$ 代表蓝色，这都是荷兰国旗的颜色）构成的数组，使得所有的 $R$ 都排在最前面，$W$ 排在其次，$B$ 排在最后。为荷兰国旗问题设计一个算法，其时间性能是 $O(n)$ 。\\
（5）有 4 个人打算过桥，这个桥每次最多只能有两个人同时通过。他们都在桥的某一端，并且是在晚上，过桥需要一只手电筒，而他们只有一只手电筒。这就意味着两个人过桥后必须有一个人将手电筒带回来。每个人走路的速度是不同的：甲过桥要用 1 分钟，乙过桥要用 2 分钟，丙过桥要用 5 分钟，丁过桥要用 10 分钟，两个人一起走路的速度等于其中较慢那个人的速度。问题是他们全部过桥最少要用多长时间？

\section*{线 性 表}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
本章概述 & \multicolumn{5}{|c|}{\begin{tabular}{l}
线性表是线性结构的典型代表。线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。线性表不仅有着广泛的应用，而且也是其他数据结构的基础，同时，单链表也是贯穿数据结构课程的基本技术。本章虽然讨论的是线性表，但涉及的许多问题都具有一定的普遍性，因此，本章是本课程的重点与核心，也是其他后续章节的重要基础。 \\
本章由实际问题引出线性表，介绍线性表的逻辑结构并定义线性表抽象数据类型，给出线性表的两种基本存储结构——顺序存储和链接存储，讨论线性表基本操作的实现并分析时间性能 \\
\end{tabular}} \\
\hline
教学重点 & \multicolumn{5}{|c|}{顺序存储结构和链接存储结构的基本思想；顺序表和单链表的基本算法；顺序表和单链表基本操作的时间性能；顺序表和链表之间的比较} \\
\hline
教学难点 & \multicolumn{5}{|c|}{线性表的抽象数据类型定义；基于单链表的算法设计，尤其是要求算法满足一定的时间性能和空间性能；双链表的算法设计} \\
\hline
\multirow{11}{*}{教学内容和教学目标} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教 学 要 求} \\
\hline
 &  & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline
 & 线性表的定义 &  &  &  & $\checkmark$ \\
\hline
 & 线性表的抽象数据类型定义 &  & $\checkmark$ &  &  \\
\hline
 & 顺序表的存储思想 &  &  &  & $\checkmark$ \\
\hline
 & 单链表的存储思想 &  &  &  & $\checkmark$ \\
\hline
 & 顺序表的基本算法及时间性能 &  &  &  & $\checkmark$ \\
\hline
 & 单链表的基本算法及时间性能 &  &  &  & $\checkmark$ \\
\hline
 & 双链表的基本算法及时间性能 &  &  & $\checkmark$ &  \\
\hline
 & 循环链表的基本算法及时间性能 &  &  & $\checkmark$ &  \\
\hline
 & 顺序表和链表的比较 &  &  & $\checkmark$ &  \\
\hline
\end{tabular}
\end{center}

\section*{2.1 引言}
线性表是一种最基本、最简单的数据结构，用来描述数据元素之间单一的前驱和后继关系。现实生活中，许多问题抽象出的数据模型是线性表，例如下面两个例子。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-041(2)}

【例 2－1】学籍管理问题和工资管理问题。用计算机进行学籍管理和工资管理，实现增、删、改、查、统计等功能。

【想法——数据模型】在学籍管理问题中，计算机的操作对象是每个学生的学籍信息——即数据元素，各元素之间的逻辑关系可以用线性结构来描述，如图 2－1 所示。在工资管理问题中，计算机的操作对象是每个职工的工资信息——即数据元素，各元素之间的逻辑关系也可以用线性结构来描述，如图 2－2 所示。

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
学号 & 姓名 & 性别 & 出生日期 & 政治面貌 \\
\hline
0001 & 陆宇 & 男 & $1997 / 09 / 02$ & 团员 \\
\hline
0002 & 李明 & 男 & $1996 / 12 / 25$ & 党员 \\
\hline
0003 & 汤晓影 & 女 & $1997 / 03 / 26$ & 团员 \\
\hline
$\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
\hline
\end{tabular}
\end{center}

（a）学籍登记表\\
图 2－1 学籍登记表及其数据模型\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-041(1)}\\
（b）线性结构

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
职工号 & 姓名 & 性别 & 基本工资 & 岗位津贴 & 业绩津贴 \\
\hline
000826 & 王一梅 & 女 & 3200 & 1900 & 600 \\
\hline
000235 & 李明 & 男 & 3800 & 2200 & 900 \\
\hline
000973 & 郑浩 & 男 & 2800 & 1500 & 500 \\
\hline
$\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
\hline
\end{tabular}
\end{center}

（a）职工工资表\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-041}\\
（b）线性结构

图 2－2 职工工资表及其数据模型\\
学籍登记表与职工工资表具有不同的数据项，内容也完全不同，但数据元素之间的逻辑关系都是线性的。推而广之，所有二维表的逻辑结构都是线性的。如何存储这种二维表并实现增、删、改、查等基本操作呢？

【例 2－2】约瑟夫环问题。约瑟夫环问题由古罗马史学家约瑟夫（Josephus）提出，他参加并记录了公元 66－70 年犹太人反抗罗马的起义。约瑟夫作为一个将军，设法守住了戔达伯特城达 47 天之久。在城市沦陷之后，他和 40 名死硬的将士在附近的一个洞穴中避难。在那里，这些起义者表决说＂要投降毋宁死＂。于是，约瑟夫建议每个人轮流杀死他旁边的人，而这个顺序是由抽签决定的。约瑟夫有预谋地抓到了最后一签，并且，作为洞穴中的两个幸存者之一，他说服了他原先的牺牲品一起投降了罗马。

【想法——数据模型】 约瑟夫环问题的操作对象是抽签的人——即数据元素，将数据元素从 1 至 $n$ 进行编号并构成一个环，从而将约悪夫环问题抽象为如图 2－3 所示数据模型。从第 1 个人开始报数，报到 $m$ 时停止报数，报 $m$ 的人出环。再从他的下一个人起重新报数，报到 $m$ 时停止报数，报 $m$ 的人出环。如此下去，直到所有人全部出环为止。当任意给定 $n$ 和 $m$ 后，求 $n$ 个人出环的次序。约瑟夫环问题的数据模型是一种典型的环状线性结构，如何存储这种环形结构并求解约瑟夫环的出环次序呢？\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-042}

图 2－3 约瑟夫环问题的数据模型（ $n=5, m=3$ 时的出圈次序： $3,1,5,2,4$ ）

\section*{2.2 线性表的逻辑结构}
\section*{2．2．1 线性表的定义}
线性表（linear list）简称表，是 $n(n \geqslant 0)$ 个数据元素的有限序列，线性表中数据元素的个数称为线性表的长度。长度等于零的线性表称为空表，一个非空表通常记为：

$$
L=\left(a_{1}, a_{2}, \cdots, a_{n}\right)
$$

其中，$a_{i}(1 \leqslant i \leqslant n)$ 称为数据元素，下角标 $i$ 表示该元素在线性表中的位置或序号 ${ }^{(1)}$ ，称元素 $a_{i}$ 位于表的第 $i$ 个位置，或称 $a_{i}$ 是表中的第 $i$ 个元素。 $a_{1}$ 称为表头元素， $a_{n}$ 称为表尾元素，任意一对相邻的数据元素 $a_{i-1}$ 和 $a_{i}(1<i \leqslant n)$ 之间存在序偶关系 $<a_{i-1}$ ， $a_{i}>$ ，且 $a_{i-1}$ 称为 $a_{i}$ 的前驱，$a_{i}$ 称为 $a_{i-1}$ 的后继。在这个序列中，元素 $a_{1}$ 无前驱，元素 $a_{n}$ 无后继，其他每个元素有且仅有一个前驱和一个后继。线性表的逻辑结构图如图2－4所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-042(1)}

图 2－4 线性表的逻辑结构图\\
线性表的数据元素具有抽象（即不确定）的数据类型，在实际问题中，数据元素的抽象类型将被具体的数据类型所取代。例如，约瑟夫环问题中 $n$ 个人的编号 $(1,2, \cdots, n)$ 是一个线性表，表中数据元素的类型是整型；学籍管理问题中 $n$ 个人的学籍信息（ $a_{1}$ ， $\left.a_{2}, \cdots, a_{n}\right)$ 是一个线性表，表中数据元素的类型是相应的结构体类型。

\footnotetext{（1）在非空表中，每个数据元素都有且仅有一个确定的位置。在本书中，数据元素的逻辑序号从 1 开始。
}\section*{2．2．2 线性表的抽象数据类型定义}
线性表是一个相当灵活的数据结构，对线性表的数据元素不仅可以进行存取访问，还可以进行插人和删除等基本操作。其抽象数据类型定义为：

\begin{verbatim}
ADT List
DataModel
数据元素具有相同类型,相邻元素具有前驱和后继关系
Operation
    InitIist
        输人:无
        功能:线性表的初始化
        输出:空的线性表
    CreatList
        输人:n个数据无素
        功能:建立一个线性表
        输出:具有 n 个元素的线性表
    DestroyList
        输人:无
        功能:销毁线性表
        输出:桻放线性表的存储空间
    PrintList
        输人:无
        功能:遍历操作,按序号依次输出线性表中的元素
        输出:线性表的各个数据元素
    Length
        输人:无
        功能:求线性表的长度
        输出:线性表中数据元素的个数
    Locate
        输人:数据元素 x
        功能:按值查找,在线性表中查找值等于 x 的元素
        输出:如果查找成功,返回元素 x 在线性表中的序号,否则返回 0
    Get
        输人:元素的序号 i
        功能:按位查找,在线性表中查找序号为i的数据元素
        输出:如果查找成功,这回序号为 i 的元素值,否则返回查找失败信息
    Insert
        输人:括人位篮 i;待插元素 x
        功能:插入操作,在线性表的第 i 个位置处插入一个新元素 x
        输出:如果插人成功,迈回新的线性表,否则返回插人失败信息
    Delete
        输人:侀除位置 1
        功能:删除操作,删除线性表中的第 i 个元素
        输出:如果删除成功,返回被删元素,否则返可删除失败信息
\end{verbatim}

\begin{verbatim}
    Empty
        输人:无
        功能:判空操作,判断线性表是否为空表
        输出:如果是空表,返回 1,否则返回 0
endADT
\end{verbatim}

需要强调的是，（1）对于不同的应用，线性表的基本操作不同；（2）对于实际问题中更复杂的操作，可以用这些基本操作的组合（即调用基本操作）来实现；（3）对于不同的应用，上述操作的接口可能不同，例如删除操作，若要求删除表中值为 $x$ 的元素，则 Delete 操作的输人参数不是位置而应该是元素值。

\section*{2.3 线性表的顺序存储结构及实现}
\section*{2．3．1 顺序表的存储结构}
线性表的顺序存储结构称为顺序表（sequential list），其基本思想是用一段地址连续的存储单元依次存储线性表的数据元素，如图 2－5 所示。设顺序表的每个元素占用 $c$ 个存储单元 ${ }^{(1)}$ ，则第 $i$ 个元素的存储地址为：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-044}


\begin{equation*}
\operatorname{Loc}\left(a_{i}\right)=\operatorname{Loc}\left(a_{1}\right)+(i-1) \times c \tag{2-1}
\end{equation*}


图 2－5 顺序表中元素 $a_{i}$ 的存储地址\\
容易看出，顺序表中数据元素的存储地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任意一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存取（random access）结构。

通常用一维数组来实现顺序表，也就是把线性表中相邻的元素存储在数组中相邻的位置，从而导致了数据元素的序号和存放它的数组下标之间具有一一对应关系，如图 2－6所示。需要强调的是，C＋＋语言中数组下标是从 0 开始的，而线性表中元素序号是从 1 开始的，也就是说，线性表中第 $i$ 个元素存储在数组中下标为 $i-1$ 的位置 ${ }^{(2)}$ 。

数组需要分配固定长度的数组空间，因此，必须确定存放线性表的数组空间的长度。因为在线性表中可以进行插入操作，则数组的长度就要大于当前线性表的长度。用 MaxSize 表示数组的长度，用 length 表示线性表的长度，如图 2－6 所示。

\footnotetext{（1）线性表中的数据元素具有相同的数据类型，假设数据类型为 DataType，则 $c=$ sizeof（DataType）。\\
（2）关于线性表中数据元素的序号和存放它的数组下标之间的关系还有以下处理方法：（1）将线性表的序号定义为从 0 开始，这样元素的序号和存储它的数组下标是相等的，但这需要改动有关线性表的其他定义；（2）将数组的 0 号单元浪费，这需要多开辟一个数组单元，但其他地方无须改动，也能保证元素的序号和存储它的数组下标是相等的。
}下标：

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
\hline
0 & 1 & ．．． & i－2 & $i-1$ & ．．． & $n-1$ & \multicolumn{2}{|c|}{MaxSize－1} \\
\hline
$a_{1}$ & $a_{2}$ & $\cdots$ & $a_{i-1}$ & $a_{i}$ & ．．． & $a_{n}$ & 空闲 & 表的长度 \\
\hline
\multicolumn{7}{|c|}{线性表的长度length} & \multirow{2}{*}{} & \multirow{2}{*}{} \\
\hline
\multicolumn{8}{|l|}{\begin{tabular}{l}
数组的长度MaxSize \\
数组的长度MaxSize \\
\end{tabular}} &  \\
\hline
\end{tabular}
\end{center}

图 2－6 数组的长度和线性表的长度具有不同含义

\section*{2．3．2 顺序表的实现}
将线性表的抽象数据类型定义在顺序表存储结构下用 C＋＋的类实现，顺序表类定义如下，其中成员变量实现顺序表存储结构，成员函数实现线性表的基本操作。由于线性表的数据元素类型不确定，所以采用 C ＋＋的模板机制。

\begin{verbatim}
public：
\end{verbatim}

SeqList () ;\\[0pt]
SeqList (DataType a [], int n) ;\\
\~{}SeqList();\\
int Length();\\
DataType Get(int i);\\
int Locate (DataType x) ;\\
void Insert (int i, DataType x);\\
DataType Delete(int i);\\
int Empty();\\
void PrintList();\\
private:\\[0pt]
DataType data [MaxSize];\\
int length;\\
\};

\begin{verbatim}

\end{verbatim}

const int MaxSize = 100;\\
template <typename DataType>\\
class SeqList\\
\{

\begin{verbatim}

\end{verbatim}

\begin{verbatim}
        //建立空的顺序表
\end{verbatim}

/1建立长度为 n 的顺序表\\
//1析构函数\\
//求线性表的长度\\
||按位査找,查找第 i 个元素的值\\
//按值查找,查找值为 x 的元素序号\\
//插人操作,在第 i 个位置插人值为 x 的元素\\
//删除操作,删除第 i 个元素\\
///判断线性表是否为空\\
//遍历操作,按序号依次输出各元素\\
//底放数据元素的数组\\
//线性表的长度

\begin{verbatim}

在顺序表中，由于元素的序号与数组中存储该元素的下标之间具有一一对应关系，所以，容易实现顺序表的基本操作，下面讨论基本操作的算法及实现。

\section*{1．无参构造函数——初始化顺序表}

无参构造函数建立一个空的顺序表，只需将顺序表的长度 length 初始化为 0 。

\section*{2．有参构造函数——建立顺序表}

建立一个长度为 $n$ 的顺序表需要将给定的数据元素传入顺序表中，并将传人的元素个数作为顺序表的长度。设给定的数据元素存放在数组 $\mathrm{a}[\mathrm{n}]$ 中，建立顺序表的操作示意

图如图 2－7 所示。如果顺序表的存储空间小于给定的元素个数，则无法建立顺序表，有参构造函数定义如下：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-046.jpg?height=648&width=1391&top_left_y=367&top_left_x=161)

图 2－7 建立顺序表的操作示意图

\section*{3．析构函数——销毁顺序表}

顺序表是静态存储分配，在顺序表变量退出作用域时自动释放该变量所占内存单元，因此，顺序表无须销毁，析构函数为空。

\section*{4．判空操作}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-046.jpg?height=312&width=244&top_left_y=1132&top_left_x=1311)

顺序表的判空操作只需判断长度 length 是否为 0 。

\section*{5．求顺序表的长度}

在顺序表的类定义中用成员变量 length 保存线性表的长度，因此，求线性表的长度只需返回成员 length 的值。

\section*{6．遍历操作}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-046.jpg?height=317&width=246&top_left_y=1532&top_left_x=1310)

在顺序表中，遍历操作即是按下标依次输出各元素，遍历操作的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
void Seqlist<DataType>:: PrintWist()\\
\{\\
for (int i = 0; i < length; i++)\\[0pt]
cout <<data[i] <<"\textbackslash t"; //依次输出线性表的元素值\\
cout <<endl;\\
\}

\begin{verbatim}

\section*{7．按位查找}

顺序表中第 $i$ 个元素存储在数组中下标为 $i-1$ 的位置，所以，容易实现按位查找。显然，按位查找算法的时间复杂度为 $O(1)$ 。按位查找的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
DataType SeqList<DataType>::Get(int i)\\
\{\\
if (i<1|| i> length) throw "查找位置非法";\\[0pt]
else return data [i -1];\\
\}

\begin{verbatim}

\section*{8．按值查找}

在顺序表中实现按值查找操作，需要对顺序表中的元素依次进行比较 ${ }^{(1)}$ ，如果查找成功，返回元素的序号（注意不是下标），否则返回查找失败的标志 0 。按值查找的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
int SeqList<DataType>:: Locate(DataType x)\\
\{\\
for (int i = 0; i < length; i++)\\[0pt]
if (data [i] = = x) return i+1; // 返回其序号 i+1\\
return 0; //退出循环,说明查找失败

\begin{verbatim}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-047.jpg?height=312&width=243&top_left_y=1124&top_left_x=1388)

按值查找从第一个元素开始，依次比较每一个元素，直至找到 $x$ 为止。如果顺序表的第一个元素恰好就是 $x$ ，算法只要比较一次就行了，这是最好情况；如果顺序表的最后一个元素是 $x$ ，算法就要比较 $n$ 个元素，这是最坏情况；平均情况下，假设数据是等概率分布，则平均比较次数为表长的一半。所以，按值查找算法的平均时间性能是 $O(n)$ 。

\section*{9．插入操作}

插人操作是在表的第 $i(1 \leqslant i \leqslant n+1)$ 个位置插人一个新元素 $x$ ，使长度为 $n$ 的线性表 $\left(a_{1}, \cdots, a_{i-1}, a_{i}, \cdots, a_{n}\right)$ 变成长度为 $n+1$ 的线性表 $\left(a_{1}, \cdots, a_{i-1}, x, a_{i}, \cdots, a_{n}\right)$ ，且插人后，元素 $a_{i-1}$ 和 $a_{i}$ 之间的逻辑关系发生了变化并且存储位置要反映这个变化。图2－8给出了顺序表在进行插人操作的前后，数据元素在存储空间中位置的变化。

注意元素移动的方向，必须从最后一个元素开始，直至将第 $i$ 个元素后移为止，然后将新元素插人位置 $i$ 处。算法用伪代码描述如下：

\footnotetext{
（1）此处比较操作是＂ $\mathrm{L}->\mathrm{data}[\mathrm{i}]=~ \mathrm{x}$＂，在实际应用中，比较操作需要根据数据元素的类型重新设计。
}

数组下标：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-048.jpg?height=212&width=1207&top_left_y=228&top_left_x=274)
（a）插入前，线性表的长度为 6
\begin{tabular}{|c|l|l|l|l|l|l|l|l|}
\hline$a_{1}$ & $a_{2}$ & $a_{3}$ & $a_{4}$ & $a_{5}$ & $a_{6}$ & $a_{7}$ & 空闲 & 7 \\
10 & 12 & 15 & 25 & 8 & 16 & 20 & & \\
\hline
\end{tabular}
（b）插入后，线性表的长度为 7

图 2－8 将元素 15 插入位置 3，顺序表前后状态的对比

算法：Insert
输人：插人位置 $i$ ，待插人的元素值 $x$
输出：如果插人成功，返回新的顺序表，否则返回插人失败信息
1．如果表满了，则输出上溢错误信息，插人失败；
2．如果元素的插人位置不合理，则输出位置错误信息，插入失败；
3．将最后一个元素直至第 i 个元素分别向后移动一个位置；
4．将元素 x 填人位置 i 处；
5．表长加 1 ；
如果表满，则引发上溢错误；如果元素的插人位置不合理，则引发位置错误。插人操作的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
void SeqList<DataType>:: Insert (int i, DataType x)\\
\{\\
if (length == MaxSize) throw "上滥";\\
if (i<1 || i> length+1) throw "插人位置错误";\\
for (int j = length; j >= i; j--)\\[0pt]
data[j] = data[j-1]; //第 j 个元素存在数组下标为 j-1 处\\[0pt]
data[i-1] = x;\\
length++;\\
)

\begin{verbatim}

该算法的问题规模是表的长度 $n$ ，基本语句是 for 循环中的元素后移语句。当 $i=n+$ 1 时（即在表尾插人），元素后移语句将不执行，这是最好情况，时间复杂度为 $O(1)$ ；当 $i=$ 1 时（即在表头插人），元素后移语句将执行 $n$ 次，需移动表中所有元素，这是最坏情况，时间复杂度为 $O(n)$ ；由于插人可能在表中任意位置上进行，因此需分析算法的平均时间复杂度。令 $E_{\mathrm{in}}(n)$ 表示元素移动次数的平均值，$p_{i}$ 表示在表中第 $i$ 个位置上插人元素的概率，假设 $p_{1}=p_{2}=\cdots=p_{n+1}=1 /(n+1)$ ，由于在第 $i$ 个 $(1 \leqslant i \leqslant n+1)$ 位置上插入一个元素后移语句的执行次数为 $n-i+1$ ，故：

$$
E_{\mathrm{in}}(n)=\sum_{i=1}^{n+1} p_{i}(n-i+1)=\frac{1}{n+1} \sum_{i=1}^{n+1}(n-i+1)=\frac{n}{2}=O(n)
$$


也就是说，在等概率情况下，平均要移动表中一半的元素，算法的平均时间复杂度为 $O(n)$ 。

\section*{10．删除操作}

删除操作是将表的第 $i(1 \leqslant i \leqslant n)$ 个元素删除，使长度为 $n$ 的线性表 $\left(a_{1}, \cdots, a_{i-1}\right.$ ， $\left.a_{i}, a_{i+1}, \cdots, a_{n}\right)$ 变成长度为 $n-1$ 的线性表 $\left(a_{1}, \cdots, a_{i-1}, a_{i+1}, \cdots, a_{n}\right)$ ，且删除后元素 $a_{i-1}$ 和 $a_{i+1}$ 之间的逻辑关系发生了变化并且存储位置要反映这个变化。图2－9给出了顺序表在删除操作的前后，数据元素在存储空间中位置的变化。

数组下标：
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
\hline 0 & 1 & 2 & 3 & 4 & 5 & 6 & \multicolumn{2}{|r|}{MaxSize－1} \\
\hline $a_{1}$ 10 & $a_{2}$ 12 & $a_{3}$ 25 & $a_{4}$ 8 & $a_{5}$ 16 & $a_{6}$ 20 & $a_{7}$ 45 & 空闲 & 7 \\
\hline \multicolumn{3}{|r|}{删除 $a_{3}$} & \multicolumn{6}{|c|}{} \\
\hline
\end{tabular}
（a）删除前，线性表的长度为 7
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline$a_{1}$ & $a_{2}$ & $a_{3}$ & $a_{4}$ & $a_{5}$ & $a_{6}$ & 空闲 & 6 \\
\hline 10 & 12 & 8 & 16 & 20 & 45 & & \\
\hline
\end{tabular}
（b）删除后，线性表的长度为 6

图 2－9 将位置 3 处的元素删除，顺序表前后状态的对比
注意元素移动的方向，必须从第 $i+1$ 个元素（下标为 $i$ ）开始，直至将最后一个元素前移为止，并且在移动元素之前要取出被删元素。如果表空，则发生下溢 ${ }^{(1)}$ 异常；如果元素的删除位置不合理，则引发删除位置异常。删除操作的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
DataType SeqList<DataType> :: Delete(int i)\\
\{\\
DataType x;\\
if (length == 0) throw "下溢";\\
if (i<1|| > length) throw "删除位置错误";\\[0pt]
x = data [i -1]; //取出位箕 i的元素\\
for (int j = i; j < length; j++)\\[0pt]
data [j-1] = data [j]; //此处j已经是元素所在的数组下标\\
length--;\\
return x;

\begin{verbatim}

设顺序表的表长是 $n$ ，显然，删除第 $i$ 个 $(1 \leqslant i \leqslant n)$ 元素需要移动 $n-i$ 个元素，令 $E_{\mathrm{de}}(n)$表示元素移动次数的平均值，$p_{i}$ 表示删除第 $i$ 个元素的概率，等概率情况下，$p_{i}=1 / n$ ，则

$$
E_{\mathrm{de}}(n)=\sum_{i=1}^{n} p_{i}(n-i)=\frac{1}{n} \sum_{i=1}^{n}(n-i)=\frac{n-1}{2}=O(n)
$$


\footnotetext{
（1）下溢和上溢不同。上溢通常是程序中的错误，程序应当捕获并处理；而下溢通常作为条件用来控制程序的走向。
}

\section*{2．3．3 顺序表的使用}

在定义了顺序表类 SeqList 并实现了基本操作后，程序中就可以使用 SeqList 类型来定义变量，可以调用实现基本操作的函数来完成相应的功能 ${ }^{(1)}$ 。范例程序如下：
\end{verbatim}

\#include <iostream>\\
using namespace std;\\
//将顺序表的类定义和各个成员函数定义写到这里\\
int main()\\
I

\begin{verbatim}
int r[5] = {1, 2, 3, 4, 5}, i, x;
SeqList<int> L{r, 5}; //建立具有 5 个元素的顺序表
cout <<"当前线性表的数据为:";
L. PrintList(); //输出当前线性表12345
try
L. Insert (2, 8); // 在第 2 个位置插人值为8的元素
cout <<"执行插人操作后数据为:";
L.PrintList(); //输出插入后的线性表182345
} catch(char * str) {cout <<str<<endl;}
cout <<"当前线性表的长度为:"<<L.Length()<<endl; //输出线性表的长度6
cout<<"请输人查找的元素值:";
cin>>x;
i= I.Locate(x);
if (0== i) cout <<"查找失败" < <endl;
else cout <<"元素" <<x<<"的位置为:" <<i <<endl;
try
cout <<"请输人查找第几个元素值;";
cin >>i;
cout <<"第"<<i<<"个元素值是"<<L.Get(i)<<endl;
} catch(char * str) (cout <<str <<endl;)
try
l
cout <<"请输人要蒯除第几个元素;";
cin >>i;
x = I. Delete(i); //删除第i 个元素
cout <<"删除的元素是"<<x<<",删除后数据为:";
L. PrintList(); //输出删除后的线性表
} catch(char * str) {cout <<str <<endl;}
return 0;
\end{verbatim}

\footnotetext{（1）此处采用的是 $\mathrm{C}++$ 语言的单文件结构，也可以采用多文件结构，把顺序表的类定义放到头文件 SeqList．h中，把顺序表类的成员函数定义放到文件 SeqList．cpp 中，在主函数所在的程序中加上 \textbackslash ＃include＂SeqList．h＂。
}\section*{2.4 线性表的链接存储结构及实现}
顺序表利用数组元素在物理位置（即数组下标）上的邻接关系来表示线性表中数据元素之间的逻辑关系，这使得顺序表具有以下缺点：\\
（1）插人和删除操作需移动大量元素。在顺序表上做插人和删除操作，等概率情况下，平均要移动表中一半的元素。\\
（2）表的容量难以确定。由于数组的长度必须事先确定，因此，当线性表的长度变化较大时，难以确定合适的存储规模。\\
（3）造成存储空间的＂碎片＂。数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成存储空间的＂碎片＂现象。

造成顺序表上述缺点的根本原因是静态存储分配，为了克服顺序表的缺点，可以采用动态存储分配来存储线性表，也就是采用链接存储结构。

\section*{2．4．1 单链表的存储结构}
单链表 ${ }^{(1)}$（singly linked list）是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。为了能正确表示元素之间的逻辑关系，每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，如图 2－10\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-051(2)}所示，这个地址信息称为指针。这两部分组成了数据元素的存储映象，称为结点（node），结点结构如图 2－11 所示。其中，data 为数据域，存放数据元素；next 为指针域，存放该结点的后继结点的地址。下面给出单链表的结点结构 ${ }^{(2)}$ 定义：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-051}

图 2－10 线性表 $\left(a_{1}, a_{2}, a_{3}\right)$ 的单链表存储\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-051(1)}

图 2－11 单链表的结点结构

\footnotetext{（1）艾伦•纽厄尔（Allen Newell，1927年生）1949年毕业于斯坦福大学。提出了＂中间结分析法＂作为求解人工智能问题的一种技术，利用这种技术，开发了最早的启发式程序＂逻辑理论家＂和＂通用问题求解器＂。在开发逻辑理论家的过程中，首次提出并应用了单链表作为基本的数据结构。\\
（2）在单链表存储结构中，Node 处于最底层，可以通过头指针 first 保证其封装性。也可以将单链表的结点定义为结点类，结点的数据和指针作为私有成员隐藏在结点类的内部，通过成员函数访问结点的数据域和指针域。
}\begin{verbatim}
template <typename DataType>
struct Node
{
    DataType data; //数据域
    Node<DataType> * next; //指针域
);
\end{verbatim}

单链表通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起，由于每个结点只有一个指针域，故称为单链表。用图 2－10 的方法表示一个单链表非常不方便，而且在使用单链表时，关心的只是数据元素以及数据元素之间的逻辑关系，而不是每个数据元素在存储器中的实际位置。通常将图 2－10 所示的单链表画成图 2－12 的形式。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-052}

图 2－12 线性表 $\left(a_{1}, a_{2}, a_{3}\right)$ 的单链表存储\\
如图 2－12 所示，单链表中每个结点的存储地址存放在其前驱结点的 next 域中，而第一个元素无前驱，所以设头指针（head pointer）指向第一个元素所在结点（称为开始结点），整个单链表的存取必须从头指针开始进行，因而头指针具有标识一个单链表的作用。为了简化叙述，有时将头指针为 first 的单链表简称为单链表 first。由于最后一个元素无后继，故最后一个元素所在结点（称为终端结点）的指针域为空，图示中用 $\wedge$ 表示，这个空指针称为尾标志（tail mark）。

从单链表的存储示意图可以看到，除了开始结点外，其他每个结点的存储地址都存放在其前驱结点的 next 域中，而开始结点是由头指针指示的。这个特例需要在单链表实现时特殊处理，增加了程序的复杂性和出现 bug ${ }^{(1)}$ 的机会。因此，通常在单链表的开始结点之前附设一个类型相同的结点，称为头结点（head node），如图 2－13 所示。加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了。

单链表的存储思想是用指针表示结点之间的逻辑关系，首先要正确区分指针变量、指针、指针所指结点和结点的值这四个密切相关的不同概念。

设 $p$ 是一个指针变量，则 $p$ 的值是一个指针。有时为了叙述方便，将＂指针变量＂简称为＂指针＂。如将＂头指针变量＂简称为＂头指针＂。

设指针 $p$ 指向某个 Node 类型的结点，则该结点用 $* p$ 来表示，$* p$ 为结点变量。有时为了叙述方便，将＂指针 p 所指结点＂简称为＂结点 p＂。

在单链表中，结点 p 由两个域组成：存放数据元素的数据域和存放后继结点地址的指针域，分别用（＊p）。data 和（＊p）。next 来标识，为了使用方便，C＋＋语言为指向结构体的指针提供了运算符＂$->$＂，即用 $p->$ data 和 $p->$ next 分别表示结点 $p$ 的数据域和指针域，如图 2－14 所示，设指针 p 指向结点 $a_{i}$ ，则 $\mathrm{p}->$ next 指向结点 $a_{i+1}$ 。

\footnotetext{（1）bug 是指程序中的小错误。第二次世界大战期间，美国海军使用计算机来计算导弹的运行轨迹。某一时刻，系统出现了故障，突然不工作了。经过艰难的查找，人们发现是因为一只小虫（bug）粘在了计算机的电路上。从那以后，凡是计算机程序中难以发现的错误就称为 bug，排除程序中的错误称为 debug。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-053(1)}

图 2－13 带头结点的单链表\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-053}

图 2－14 指针和结点之间的关系

\section*{2．4．2 单链表的实现}
将线性表的抽象数据类型定义在单链表存储结构下用 C ++ 中的类实现。单链表类定义如下，其中成员变量 first 表示单链表的头指针，成员函数实现线性表的基本操作。由于线性表的数据元素类型不确定，所以采用 C＋＋的模板机制。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-053(2)}

单链表由头指针唯一指定，整个单链表的操作必须从头指针开始进行。下面讨论单链表基本操作的实现。

\section*{1．无参构造函数——单链表的初始化}
初始化单链表就是生成只有头结点的空单链表，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
LinkList<DataType> :: LinkList()
i
    first=new Node<DataType>; //生成头结点
    first ->next=nulIptr; //头结点的指针域置空
}
\end{verbatim}

\section*{2．判空操作}
单链表的判空操作只需判断单链表是否只有头结点，即判断 first－＞next 是否为空。

\section*{3．遍历操作}
遍历单链表是指按序号依次访问单链表中的所有结点 ${ }^{(1)}$ 。可以设置一个工作指针 p依次指向各结点，当指针 $p$ 指向某结点时输出该结点的数据域。遍历单链表的操作示意图如图 2－15 所示，算法用伪代码描述如下。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-054}

图 2－15 遍历单链表的操作示意图

算法：PrintList\\
输人：单链表的头指针 first\\
输出：单链表所有结点的元素值\\
1．工作指针 $p$ 初始化为指向开始结点；\\
2．重复执行下述操作，直到 $p$ 为空；\\
2.1 输出结点 p 的数据域；

2．2 工作指针 p 后移；

需要强调的是，工作指针 $p$ 后移不能写作 $p++$ ，因为单链表的存储单元可能不连续，因此 $p++$ 不能保证工作指针 $p$ 指向下一个结点，如图 2－16 所示。遍历单链表需要将

\footnotetext{（1）单链表算法的基本处理技术是遍历（也称扫描）。从头指针出发，通过工作指针的反复后移而将整个单链表 ＂审视＂一遍的方法称为遍历。遍历是蛮力法的一种常用技术，在很多算法中都要用到。
}单链表扫描一遍，因此时间复杂度为 $O(n)$ 。遍历操作的成员函数定义如下。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-055}

图 2－16 pt＋与 p－＞next 的执行结果\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-055(1)}

\section*{4．求单链表的长度}
由于单链表类定义中没有存储线性表的长度，因此，不能直接获得线性表的长度。可以采用遍历的方法来求其长度，设置工作指针 $p$ 依次指向各结点，当指针 $p$ 指向某结点时求出其序号，然后将 p 修改为指向其后继结点并且将序号加 1 ，则最后一个结点的序号即为表中结点个数。求单链表长度的成员函数定义如下：

\begin{verbatim}
template <typename DataType>
\end{verbatim}

int LinkList<DataType>: : Length ()\\
1\\
Node<DataType> * p = first->next; //T作指针初始化\\
int count $=0$; //累加器初始化\\
while ( $\mathrm{p}!=$ nullptr)\\
I\\
$p=p->n e x t ;$\\
count++ ;\\
)\\
return count; //注意count的初始化和返回值之间的关系\\
)

\section*{5．按位查找}
在单链表中，即使知道被访问结点的序号 $i$ ，也不能像顺序表那样直接按序号访问，

只能从头指针出发顺 next 域逐个结点往下搜索。当工作指针 p 指向某结点时判断是否为第 $i$ 个结点，若是，则查找成功；否则，将工作指针 p 后移。对每个结点依次执行上述操作，直到 $p$ 为 nullptr 时查找失败。按位查找的成员函数定义如下：

\begin{verbatim}
template <typename DataType>
DataType LinkList<DataType>:: Get (int i)
t
    Node<DataType> * $\mathrm{p}=$ first - >next ; //工作指针 p 初始化
    int count $=1$; $\quad$ //䉘加器 count 初始化
    while (p!= nullptr \&\& count < i)
    I
        $\mathrm{p}=\mathrm{p} \rightarrow \mathrm{next}$; //工作指针 p 后移
        count++ ;
    1
    if ( $p==$ nullptr) throw "查找位置错误";
    else return p->data;
\end{verbatim}

算法的基本语句是工作指针 p 后移，该语句执行的次数与被查结点在表中的位置有关。在查找成功的情况下，若查找位置为 $i(1 \leqslant i \leqslant n)$ ，则需要执行 $i-1$ 次，等概率情况下，平均时间性能为 $O(n)$ 。因此，单链表是顺序存取（sequential access）结构。

\section*{6．按值查找}
在单链表中实现按值查找操作，需要对单链表中的元素依次进行比较。如果查找成功，返回元素的序号，否则返回 0 表示查找失败。按值查找的成员函数定义如下：

\begin{verbatim}
template <typename DataType>
int LinkList<DataType>:: Locate (DataType x)
{
    Node<DataType>*p=first->next; //工作指针 p 初始化
    int count = 1; //褁加器count 初始化
    While (p != nullptr)
    {
        if (p->data = = x) return count; //查找成功返回序号
        p = p->next;
        count++;
    }
    return 0; //退出循环表明查找失败
}
\end{verbatim}

按值查找的基本语句是将结点 p 的数据域与待查值进行比较，具体的比较次数与待查值结点在单链表中的位置有关。在等概率情况下，平均时间性能为 $O(n)$ 。

\section*{7．插入操作}
单链表的插人操作是将值为 $x$ 的新结点插人到单链表的第 $i$ 个位置，即插人到 $a_{i-1}$ 与 $a_{i}$ 之间。因此，必须先扫描单链表，找到 $a_{i-1}$ 的存储地址 p ，然后生成一个数据域为 $x$ 的新结点 s ，将结点 s 的 next 域指向结点 $a_{i}$ ，将结点 p 的 next 域指向新结点 s （注意指针的链接顺序），从而实现三个\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-057}结点 $a_{i-1} 、 x$ 和 $a_{i}$ 之间逻辑关系的变化，插入过程如图 2－17 所示。注意分析在表头、表中间、表尾插人三种情况。由于单链表带头结点，这三种情况的操作语句一致，不用特殊处理。算法用伪代码描述如下：

算法：Insert\\
输人：单链表的头指针 first，插人位置 $i$ ，待插值 x\\
输出：如果插人成功，返回新的单链表，否则返回插入失败信息\\
1．工作指针 $p$ 初始化为指向头结点；\\
2．查找第 $i-1$ 个结点并使工作指针 $p$ 指向该结点；\\
3．若查找不成功，说明插人位置不合理，返回插人失败信息；否则，生成一个元素值为 $x$ 的新结点 $s$ ，将结点 $s$ 插人到结点 $p$ 之后；\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-057(1)}

图 2－17 在单链表中插人结点时指针的变化情况\\
（1） $\mathrm{s}->\mathrm{next}=\mathrm{p}->\mathrm{next}$ ；（2） $\mathrm{p}->\mathrm{next}=\mathrm{s}$ ；）\\
插人算法的时间主要耗费在查找正确的插人位置上，故时间复杂度为 $O(n)$ 。插人操作的成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void LinkList<DataType> :: Insext(int i, DataType x)
f
    Node<DataType> *p = first, * s = nullptr;
    int count = 0;
    While (p t= nullptr && count < i-1) //查找第 i-1个结点 (源代码)
    {
        p = p->next; //工作指针 p 后移
        count++;
    }
    if (p == nu1lptr) throw "插入位置错误"; //没有找到第 1-1个结点
    else f
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-058(1)}
\end{center}

在不带头结点的单链表中插人一个结点，在表头的操作和在表中间以及表尾的操作语句是不同的，则在表头的插人情况需要单独处理（如图 2－18 所示），算法不仅冗长，而且容易出现错误。所以，在单链表中，除非特别说明不能带头结点，否则，为了运算方便，都要加上头结点。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-058}

图 2－18 在不带头结点的单链表中插人结点时指针的变化情况 （1） $\mathrm{s} \longrightarrow>$ next $=$ first；（2）first $=\mathrm{s}$ ；（3） $\mathrm{s} \longrightarrow>\mathrm{next}=\mathrm{p} \longrightarrow>\mathrm{next}$ ；（4） $\mathrm{p} \longrightarrow>\mathrm{next}=\mathrm{s}$ ；）

\section*{8．构造函数——建立单链表}
设给定的数据元素存放在数组 $\mathrm{a}[\mathrm{n}]$ 中，建立单链表就是生成存储这 $n$ 个数据元素的单链表。有两种建立方法：头插法和尾插法。

头插法的基本思想是每次将新申请的结点插在头结点的后面，执行过程如图 2－19 所示，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
LinkList<DataType> :: LinkList(DataType a[], int n)
f
    first = new Node<DataType>;
    first ->next = nullptr; // 初始化一个空链表
    for (int i = 0; i<n; it+)
    {
        Node<DataType> * s = nullptr;
        s = new Node<DataType>; s->data = a[i];
        s->next = first->next; first->next = s; //将结点 s 插人头结点后
    }
)
\end{verbatim}

尾插法的基本思想是每次将新申请的结点插在终端结点的后面，为此，需要设尾指针指向当前的终端结点，执行过程如图 2－20 所示，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
LinkList<DataType>::LinkList(DataTypea[], int n)
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-059(1)}
\end{center}

图 2－19 头插法建立单链表的操作示意图\\
（1） $\mathrm{s}->$ next $=$ first $->$ next；（2）first $->$ next $=\mathrm{s}$ ；）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-059}\\
（d）最后情况插人元素a［n］，需将终端结点的指针域置空\\
图 2－20 尾插法建立单链表的操作示意图\\
（1） $\mathrm{r}->$ next $=\mathrm{s}$ ；（2） $\mathrm{r}=\mathrm{s}$ ；（3） $\mathrm{r}->$ next $=$ nullptr；）

\section*{9．删除操作}
删除操作是将单链表的第 $i$ 个结点删去。因为在单链表中结点 $a_{i}$ 的存储地址在其前驱结点 $a_{i-1}$ 的指针域中，所以必须首先找到 $a_{i-1}$ 的存储地址 p ，然后令 p 的 next 域指向 $a_{i}$

的后继结点，即把结点 $a_{i}$ 从链上摘下，最后释放结点 $a_{i}$ 的存储空间。需要注意表尾的特殊情况，此时虽然被删结点不存在，但其前驱结点却存在。因此仅当被删结点的前驱结点 p 存在且 $p$ 不是终端结点时，才能确定被删结点存在，如图 2－21 所示。算法用伪代码描述如下：

算法：Delete\\
输人：单链表的头指针 first，删除位置 i\\
输出：如果删除成功，返回被删除的元素值，否则返回删除失败信息\\
1．工作指针 $p$ 初始化；累加器 count 初始化；\\
2．查找第 $i-1$ 个结点并使工作指针 $p$ 指向该结点；\\
3．若 p 不存在或 p 的后继结点不存在，则出现删除位置错误，删除失败；\\
否则，3．1存储被删结点和被删元素值；\\
3.2 摘链，将结点 p 的后继结点从链表上摘下；\\
3.3 释放被删结点；\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-060}

图2－21 在单链表中删除结点时指针的变化情况\\
删除算法的时间主要耗费在查找正确的删除位置上，因此时间复杂度为 $O(n)$ 。删除操作的成员函数定义如下：

\begin{verbatim}
template <typename DataType>
DataType LinkList<DataType> : : Delete(int i)
f
    DataType x;
    Node<DataType> * p = first, *q = nullptr;
    int count = 0;
    while (p != nullptr && count < i-1) //查找第 i-1个结点
    |
        p = p->next;
        count++;
    }
    if (p == nullptr || p->next == nullptr) //结点 p 不存在或 p 的后继结点不存在
        throw "删除位䈯错误";
    else {
        q = p->next; x = q ->data; //暂存被删结点
        p->next = q->next; //摘链
        delete q;
        return x;
    }
)
\end{verbatim}

\section*{10．析构函数——销毁单链表}
单链表是动态存储分配，单链表的结点是在程序运行中动态申请的，因此，在单链表变量退出作用域之前，要释放单链表的存储空间。析构函数定义如下：

\begin{verbatim}
template <typename DataType>
LinkList<DataType>:: ~LinkList()
0
    Node<DataType> *p = first;
    while (first != nullptr) //辢放每 个结点的存储空间
    l
        first = first->next; // first 指向被释放结点的下一个结点
        deletep;
        p=first;
//工作指针p后移
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-061}
\end{center}

\section*{2．4．3 单链表的使用}
在定义了单链表类 LinkList 并实现了基本操作后，程序中就可以用类 Link List 来定义单链表变量，可以调用实现基本操作的函数来完成相应的功能。范例程序如下：

$$
\begin{aligned}
& \text { \# include <iostream> } \\
& \text { 1/引人输人输出流 } \\
& \text { using namespace std; } \\
& \text { 1/将单链表的结点结构定义、单链表类定义和各个成员函数定义写到这里 } \\
& \text { int main() } \\
& 1 \\
& \text { int } x[5]=\{1,2,3,4,5\}, i, x \text {; } \\
& \text { LinkList<int> L\{r, 5\}; } \\
& \text { cout <<"当前线性表的数据为: "; } \\
& \text { I. Printuist () ; } \\
& \text { 1/输出当前链表12345 }
\end{aligned}
$$

\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-061(1)}\\
try\\
1\\
L．Insert $(2,8)$ ； $1 /$ 在第 2 个位置插人值为 8 的结点\\
cout＜＜＂执行插入操作后数据为：＂；\\
L．PrintList（）；／／输出插入后链表182345\\
\}catch (char * str) \{cout < str \textbackslash llendl; \}\\
cout＜＜＂当前单链表的长度为：＂＜＜L．Iength（）＜endl；／／输出单链表长度 6 cout＜＜＂请输人查找的元素值：＂；\\
cin＞＞x；\\
$i=$ L．Locate（ $x$ ）；\\
if（ $i>0$ ）cout＜＜＂元素＂＜＜x＜＜＂的位置为：＂＜＜i＜＜endl；\\
else cout＜＜＂单链表中没有元素＂＜＜x \textbackslash llendl；

\begin{verbatim}
ry
|
    cout<<"请输入要删除第几个元素:";
    cin >>i;
    x = L. Delete(i); //删除第 i 个元素
    cout <<"删除的元素值是"<<x<<",执行删除操作后数据为:";
    L.PrintList();
//输出朋除后的单链表
} catch(char * str) {oout <<str <<endl;}
return 0;
\end{verbatim}

\section*{2．4．4 双链表}
如果希望快速确定单链表中任一结点的前驱结点，可以在单链表的每个结点中再设置一个指向其前驱结点的指针域，这样就形成了双链表 （double linked list）。和单链表类似，双链表一般也是由头指针唯一确定，增加头结点也能使双链表的某些操作变得方便，双链表的存储示意图\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-062}如图 2－22 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-062(1)}

图 2－22 双链表存储示意图\\
在双链表中，每个结点在存储数据元素的同时，还存储了其前驱元素和后继元素所在结点的地址信息。这三部分组成了数据元素的存储映象，双链表的结点结构如图 2－23 所示。其中，data 为数据域，存放数据元素；prior 为前驱指针域，存放该结点的前驱结点的地址；next 为后继指针域，存放该结点的后继结点的地址。下面给出双链表的结点结构定义：

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
prior & data & next \\
\hline
\end{tabular}
\end{center}

图 2－23 双链表的结点结构

\begin{verbatim}
template <typename DataType>
struct DulNode
{
    DataType data;
    DulNode<DataType> * prior, * next;
};
\end{verbatim}

在双链表中求表长、按位查找、按值查找、遍历等操作的实现与单链表基本相同，下面讨论插人和删除操作。

\section*{1．插入操作}
在结点 p 的后面插人一个新结点 s ，需要修改 4 个指针：\\
（1） $\mathrm{s}->$ prior $=\mathrm{p}$ ；\\
（2） $\mathrm{s} \longrightarrow$ next $=\mathrm{p}->$ next ；\\
（3） $\mathrm{p}->$ next $->$ prior $=\mathrm{s}$ ；\\
（4） $\mathrm{p}->\mathrm{next}=\mathrm{s}$ ；\\
注意指针修改的相对顺序，如图 2－24 所示，在修改第（2）和（3）步的指针时，要用到 $\mathrm{p}->\mathrm{next}$ 以找到结点 p 的后继结点，所以第（4）步指针的修改要在第（2）和（3）步的指针修改完成后才能进行。

\section*{2．删除操作}
设指针 $p$ 指向待删除结点，如图 2－25 所示，删除操作可通过下述两条语句完成：\\
（1）（p－＞prior）$->$ next $=\mathrm{p}->$ next ；\\
（2）（ $\mathrm{p}->$ next $)->$ prior $=\mathrm{p}->$ prior；\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-063(1)}

图 2－24 双链表插人操作示意图\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-063}

图 2－25 双链表删除操作示意图

这两个语句的顺序可以颠倒。另外，虽然执行上述语句后结点 p 的两个指针域仍指向其前驱结点和后继结点，但在双链表中已经找不到结点 p。而且，执行删除操作后，还要将结点 $p$ 所占的存储空间释放。

\section*{2．4．5 循环链表}
在单链表中，如果将终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为循环单链表 （circular singly linked list），如图 2－26 所示。

在用头指针指示的循环单链表中，找到开始结点的时间是 $O(1)$ ，然\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-063(2)}

图 2－26 循环单链表存储示意图

而要找到终端结点，则需从头指针开始遍历整个链表，其时间是 $O(n)$ 。在很多实际问题中，操作是在表的首或尾两端进行，此时头指针指示的循环单链表就显得不够方便。如果改用指向终端结点的尾指针（rear pointer）来指示循环单链表，如图 2－27 所示，则查找开始结点和终端结点都很方便，它们的存储地址分别是（rear $->$ next $)->$ next 和 rear，显然，时间都是 $O(1)$ 。因此，实际应用中多采用尾指针指示的循环单链表。

在双链表中，如果将终端结点的后继指针由空指针改为指向头结点，将头结点的前驱指针由空指针改为指向终端结点，就使整个双链表形成一个头尾相接的循环双链表 （circular double linked list），如图 2－28 所示。在由头指针指示的循环双链表中，查找开\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-064(2)}

图 2－27 带尾指针的循环单链表\\
始结点和终端结点都很方便，它们的存储地址分别是 first $->$ next 和 first $->$ prior，显然，时间开销都是 $O(1)$ 。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-064(1)}

图 2－28 循环双链表存储示意图\\
循环链表没有增加任何存储量，仅对链表的链接方式稍作改变，因此，基本操作的实现与链表类似。从循环链表中任一结点出发，可扫描到其他结点，从而提高了链表操作的灵活性。但这种方法的危险在于循环链表中没有明显的尾端，可能会使循环链表的处理操作进人死循环，所以，需要格外注意循环条件。通常判断用作循环变量的工作指针是否等于某一指定指针（如头指针或尾指针），以判定工作指针是否扫描了整个循环链表。例如，在循环链表的遍历算法中，用循环条件 $p!=f$ irst 判断工作指针 $p$ 是否扫描了整个链表。

\section*{2.5 顺序表和链表的比较}
前面给出了线性表的两种截然不同的存储结构——顺序存储结构和链接存储结构，哪一种更好呢？如果实际问题需要采用线性表来解决，应该选择哪一种存储结构呢？通常情况下，需要比较不同存储结构的时间性能\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-064}和空间性能，根据实际问题的需要，对各方面的优缺点加以综合平衡，选定比较合适的存储结构。

\section*{1．时间性能比较}
所谓时间性能是指基于某种存储结构的基本操作（即算法）的时间复杂度。\\
像取出线性表中第 $i$ 个元素这样的按位置随机访问的操作，使用顺序表更快一些，时间性能为 $O(1)$ ；相比之下，链表中按位置访问只能从表头开始依次向后扫描，直至找到那个特定的位置，所需要的平均时间为 $O(n)$ 。

在链表中进行插人和删除操作不需要移动元素，在给出指向链表中某个合适位置的指针后，插人和删除操作所需的时间仅为 $O(1)$ ；在顺序表中进行插人和删除操作需移动元素，平均时间为 $O(n)$ ，当线性表中元素个数较多时，特别是当元素占用的存储空间较多时，移动元素的时间开销很大。

作为一般规律，若线性表需频繁查找却很少进行插入和删除操作，或者操作和＂数据元素在线性表中的位置＂密切相关时，宜采用顺序表作为存储结构；若线性表需频繁进行插人和删除操作，则宜采用链表作为存储结构。

\section*{2．空间性能比较}
所谓空间性能是指某种存储结构所占用的存储空间的大小。\\
顺序表中每个结点（即数组元素）只存储数据元素，链表的每个结点除了存储数据元素，还要存储指示元素之间逻辑关系的指针。如果数据域占据的空间较小，则指针的结构性开销就占去了整个结点的大部分，因而从结点的存储密度上讲，顺序表的存储空间利用率较高。

由于顺序表需要分配一定长度的存储空间，如果事先不知道线性表的大致长度，则有可能对存储空间分配得过大，致使存储空间得不到充分利用，造成浪费；若估计得过小，则会发生上溢。链表不需要固定长度的存储空间，只要有内存空间可以分配，链表中的元素个数就没有限制。

作为一般规律，当线性表中元素个数变化较大或者未知时，最好使用链表实现；如果事先知道线性表的大致长度，使用顺序表的空间效率会更高。

\section*{2.6 扩展与提高}
\section*{2．6．1 线性表的静态链表存储}
\section*{1．静态链表的存储结构}
静态链表（static linked list）用数组来表示链表，用数组元素的下标来模拟链表的指针。由于是利用数组定义的链表，属于静态存储分配，因此叫作静态链表。最常用的是静态单链表，在不致混淆的情况下，将静态单链表简称为静态链表，存储示意图如图 2－29 所示，其中，avail 是空闲链表（全部由空闲数组单元组成的单链表）头指针，first 是静态链表头指针，为了运算方便，通常静态链表也带头结点。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-065}

图 2－29 静态链表的存储示意图

静态链表的每个数组元素由两个域构成：data 域存放数据元素，next 域存放该元素的后继元素所在的数组下标。静态链表的数组元素定义如下：

\begin{verbatim}
template <typename DataType>
struct SNode
f
    DataType data; //DataType表示不确定的数据类型
    int next; //指针域(也称游标),注意不是指针类型
);
\end{verbatim}

\section*{2．静态链表的实现}
将线性表的抽象数据类型定义在静态链表存储结构下用 C＋＋中的类实现。静态链表类定义如下，其中成员变量 first 和 avail 分别表示静态链表的头指针和空闲链表的头指针，成员函数实现线性表的基本操作。由于线性表的数据元素类型不确定，所以采用 C ++ 的模板机制。

\begin{verbatim}
const int MaxSize = 100;
//100 是示例数据,根据实际问题具休定义
template <typename DataType>
class StaList
{
public:
    StaList() ;
    Stalist (DataType a[], int n);
    ~Stalist();
    //与单链表成员函数相同
private:
    SNode SList[MaxSize]; //静态链表数组
    int first, avail; //游标,链表头指针和空闲头指针
};
\end{verbatim}

静态链表采用静态存储分配，因此析构函数为空。求表长、按位查找、按值查找、遍历等操作的实现与单链表基本相同，下面讨论插人和删除操作。\\
（1）插人操作\\
在静态链表中进行插人操作，首先从空闲链的最前端摘下一个结点，将该结点插人静态链表中，如图 2－30 所示。假设新结点插在结点 $p$ 的后面，则修改指针的操作为：

\begin{verbatim}
s == avail;
avail = SList[avail],next; //空闲链的头指针后移
SList[s].data = x; //将 x 填人下标为 s 的结点
SList[s].next = SList[p].next; //将下标为 s 的结点插人到下标为 p 的结点后面
SList[p].next = s;
\end{verbatim}

（2）删除操作\\
在静态链表中进行删除操作，首先将被删除结点从静态链表中摘下，再插人空闲链的最前端，如图 2－31 所示。假设要删除结点 $p$ 的后继结点，则修改指针的操作为：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-067(1)}

图 2－30 静态链表插人操作示意图\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-067}

图 2－31 静态链表删除操作示意图\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-067(2)}

静态链表虽然用数组来存储线性表，但在执行插人和删除操作时，只需修改游标，无须移动表中的元素，从而改进了在顺序表中插人和删除操作需要移动大量元素的缺点。

\section*{2．6．2 顺序表的动态分配方式}
2.3 节介绍的顺序表采用静态存储方式，在程序编译时分配固定长度的存储空间，由于存储空间不能扩充，一旦数组空间占满，再执行插人操作就会发生上溢。顺序表的动态分配方式是在程序执行过程中通过动态存储分配，一旦数组空间占满，另外再分配一块更大的存储空间，用来替换原来的存储空间，从而达到扩充数组空间的目的。顺序表动态分配方式的类定义如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-068}

在顺序表的动态分配方式下，求线性表的长度、按位查找、按值查找、删除、判空和遍历等基本操作的算法，与顺序表的静态分配方式相同。下面讨论其他基本操作的实现。

\section*{1．无参构造函数——初始化顺序表}
初始化顺序表需要创建顺序表的存储空间，将顺序表的当前最大长度初始化为初始长度 InitSize，将顺序表的长度初始化为 0 ，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
SeqList<DataType>::SeqList()
{
    data = new DataType[InitSize];
    maxSize = InitSize;
    length = 0;
回臨安垩回
}
\end{verbatim}

\section*{2．有参构造函数——建立顺序表}
建立一个长度为 $n$ 的顺序表需要申请长度大于 $n$ 的存储空间，一般是当前线性表长度两倍的存储空间，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
SeqList<DataType>:: SeqList (DataType a[], int n)
{
    data = new DataType[2 * n]; //申请 2n 的存储空间
    maxSize = 2 * n;
    for (int i = 0; i< n; i++)
        data[i] = a[i];
    length = n;
}
\end{verbatim}

\section*{3．析构函数——销毁顺序表}
在顺序表的动态分配方式下，由于顺序表的存储空间是在程序执行过程中动态申请的，因此，需要释放其存储单元，析构函数定义如下：

\begin{verbatim}
template <typename DataType>
SeqList<DataType> ::~SeqList()
l
    delete[] data;
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-069}
\end{center}

\section*{4．插入操作}
在顺序表的动态分配方式下执行插人操作，当数组空间都占满时，需要扩充数组空间，再执行插人操作。成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void SeqList<DataType>:: Insert(int 1, DataType x)
{
    if (i<1||>length+1) throw "插人位置错误!";
    if (length = = maxsize) { // 发生上輼,扩充存储空间
        DataType *oldData = data;
        maxSize += IncreSize;
        data = new DataType[maxSize];
        for (int j = 0; j < length; j++)
            data[j] = oldData[j];
        delete[] oldData;
    }
    for (int j = length; j >= i; j--) //j表示元素序号
        data[j] = data[j -1];
    data[i -1] = x;
    length++;
}

\section*{2.7 应 用 实 例}

\section*{2．7．1 约瑟夫环问题}

本章的引言部分给出了约瑟夫环问题及其数据模型，下面考虑算法设计与程序实现。
【算法】由于约瑟夫环问题本身具有循环性质，考虑采用循环单链表。求解约瑟夫环问题的基本思想是：设置一个计数器 count 和工作指针 $p$ ，当计数器累加到 $m$ 时删除结点 p 。为了统一对链表中任意结点进行计数和删除操作，循环单链表不带头结点；为了

便于删除操作，设两个工作指针 pre 和 p，指针 pre 指向结点 p 的前驱结点；为了使计数器从 1 开始计数，采用尾指针指示的循环单链表，将指针 pre 初始化为指向终端结点，将指针 $p$ 初始化为指向开始结点，如图 2－32 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-070.jpg?height=144&width=1220&top_left_y=423&top_left_x=193)

图 2－32 约瑟夫环的初始状态
设函数 Joseph 求解约瑟夫环问题，算法用伪代码描述如下：

算法：Joseph（rear，m）
输人：尾指针指示的循环单链表 rear，密码 m
输出：约瑟夫环的出环顺序
1．初始化：pre＝rear；p＝rear－＞next；count＝1；
2．重复下述操作，直到链表中只剩一个结点：
2.1 如果 count 小于 $m$ ，则

2－1．1 工作指针 pre 和 p 后移；
2．1．2 count＋＋；
2.2 否则，执行下述操作：

2．2．1 输出结点 p 的数据域；
2．2．2 删除结点 $p$ ；
2．2．3 p 指向 pre 的后继结点；count $=1$ 重新开始计数；
3．输出结点 $p$ 的数据域，删除结点 $p$ ；
【程序】将函数 Joseph 定义为类 JosephRing 的成员函数，类 JosephRing 的成员变量表示循环单链表的尾指针，构造函数建立由尾指针指向的循环单链表，析构函数与单链表析构函数类似，请读者自行设计。主函数首先输人约瑟夫环的长度 $n$ 和密码 $m$ ，然后定义对象变量 R ，再调用函数 Joseph 输出出环的顺序。程序如下：
\end{verbatim}

\#include <iostream>\\
using namespace std;\\
struct Node //定义约瑟夫环的结点 Node\\
\{\\
int data;\\
struct Node * next;\\
);\\
class JosephRing\\
l\\
public:\\
JosephRing(int n); //构造函数,初始化 n 个结点的循环单链表\\
\~{} JosephRing(); //析构函数,同单链表析构函数类似\\
void Joseph (int m); //密码为 m, 打印出环的顺序\\
private:\\
Node * rear;

\begin{verbatim}

\end{verbatim}

\};\\
JosephRing :: JosephRing(int n)\\
1\\
Node * s = nullptr;\\
rear = new Node;\\
rear ->data = 1; rear->next = rear; //建立长度为 1 的循环单链表\\
for (int i = 2; i<= n; it+) //依次插入数据域为 2、3、流的结点\\
|\\
s= new Node; s->data = i;\\
s->next = rear->next; //将结点s插人尾结点 rear 的后面\\
rear->next = s;\\
rear = s;\\
)\\
\}\\
void JosephRing :: Joseph(int m)\\
l\\
Node *pre = rear, * p = rear->next; //初始化工作指针 p 和 pre\\
int count = 1;\\
cout <<"出环的顺序是:";\\
while (p->next != p) // 循环直到循环链表中只剩一个结点\\
\{\\
if (count < m) | //计数器未累加到密码值\\
pre = p;p=p->next; //将工作指针 pre 和 p 同时后移\\
count++ ;\\
)\\
else 1 //计数器已经累加到密码值\\
cout <<p->data<<"\textbackslash t"; //输出出环的编号\\
pre->next = p->next; //将结点 p 摘链\\
delete p;\\
p=pre->next; //工作指针p后移,但pre不动\\
count = 1; //计数器从1开始重新计数\\
)\\
\}\\
cout <<p->data<<"\textbackslash t"; //输出最后一个结点的编号\\
delete p; ||释放最后一个结点\\
\}\\
int main()\\
f\\
int n, m;\\
cout <<"请输人约悪大环的长度:";\\
cin>>n;\\
cout <<"请输人密码:";\\
cin >>m;\\
JosephRing R\{n\};

\begin{verbatim}

\end{verbatim}

R. Joseph (m) ;\\
return 0;

\begin{verbatim}

\section*{2．7．2 一元务项式求和}

【问题】设 $A(x)=a_{0}+a_{1} x+a_{2} x^{2}+\cdots+a_{n} x^{n}, B(x)=b_{0}+b_{1} x+b_{2} x^{2}+\cdots+b_{m} x^{m}$ ，并且多项式的指数可能很高且变化很大，例如：$A(x)=7+12 x^{3}-2 x^{8}+5 x^{12}, B(x)=$ $4 x+6 x^{3}+2 x^{8}+5 x^{20}+7 x^{28}$ ，求两个一元多项式的和，即求 $A(x)+B(x)$ 。

【想法】由于一元多项式 $A(x)=a_{0}+a_{1} x+a_{2} x^{2}+\cdots+a_{n} x^{n}$ 由 $n+1$ 个系数唯一确定，因此，可以用一个线性表 $\left(a_{0}, a_{1}, a_{2}, \cdots, a_{n}\right)$ 来表示，每一项的指数 $i$ 都隐含在其系数 $a_{i}$的序号里。如果多项式的指数可能很高且变化很大，则一元多项式对应的线性表中就会存在很多零元素。一个较好的存储方法是只存储非零项，但是需要在存储非零系数的同时存储相应的指数。这样，一元多项式的每一个非零项可由系数和指数唯一表示。例如，一元多项式 $A(x)=7+12 x^{3}-2 x^{8}+5 x^{12}$ 就可以用线性表 $((7,0),(12,3),(-2,8)$ ， $(5,12))$ 来表示。

一元多项式求和实质上是合并同类项的过程，也就是将两个一元多项式对应的线性表进行合并的过程。例如，$A(x)=7+12 x^{3}-2 x^{8}+5 x^{12}$ 和 $B(x)=4 x+6 x^{3}+2 x^{8}+5 x^{20}+$ $7 x^{28}$ 的求和即是将线性表 $((7,0),(12,3),(-2,8),(5,12))$ 和 $((4,1),(6,3)$ ， $(2,8),(5,20),(7,28))$ 进行合并，结果为 $((7,0),(4,1),(18,3),(5,12)$ ， $(5,20),(7,28))$ 。

【算法】如何存储多项式对应的线性表呢？对于指数相差很多的两个一元多项式，相加会改变多项式的系数和指数。若相加的某两项的指数不等，则两项应分别加在结果中，将引起线性表的插人；若某两项的指数相等，则系数相加，若相加结果为零，将引起线性表的删除。由于在线性表的合并过程中需要频繁地执行插入和删除操作，因此考虑采用单链表存储。

在表示一元多项式的单链表中，每一个非零项对应单链表中的一个结点，且单链表应按指数递增有序排列。结点结构如图 2－33 所示。其中，coef 为系数域，存放非零项的系数；exp 为指数域，存放非零项的指数；next 为指针域，存放指向下一结
\begin{tabular}{|c|c|c|}
\hline coef & $\exp$ & next \\
\hline
\end{tabular}

图 2－33 一元多项式链表的结点结构点的指针。

下面分析一元多项式求和的执行过程。设单链表 A 和 B 分别存储两个多项式，求和结果存储在单链表 A 中，设两个工作指针 p 和 q 分别指向两个单链表的开始结点。两个多项式求和实质上是对结点 $p$ 的指数域和结点 $q$ 的指数域进行比较，有下列三种情况：
（1）若 $\mathrm{p}->\exp$ 小于 $<\mathrm{q}->\exp$ ，则结点 p 应为结果链表中的一个结点，将指针 p 后移，如图 2－34 所示。
（2）若 $\mathrm{p}->\exp$ 大于 $\mathrm{q}->\exp$ ，则结点 q 应为结果中的一个结点，将 q 插人到第一个单链表中结点 $p$ 之前，并将指针 $q$ 指向单链表 $B$ 中的下一个结点，如图 2－35 所示。为此，在单链表 A 中应该设置两个工作指针 pre 和 p，使得 pre 指向 p 的前驱结点。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-073.jpg?height=284&width=1263&top_left_y=212&top_left_x=269)

图 2－34 第一种情况示意图
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-073.jpg?height=287&width=1253&top_left_y=601&top_left_x=276)

图 2－35 第二种情况示意图
（3）若 $\mathrm{p} \rightarrow>\exp$ 等于 $\mathrm{q} \rightarrow>\exp$ ，则 p 与 q 所指为同类项，将 q 的系数加到 p 的系数上。若相加结果不为 0 ，则将指针 $p$ 后移，并删除结点 $q$ ，为此，在单链表 B 中应该设置两个工作指针 qre 和 $q$ ，使得 qre 指向 $q$ 的前驱结点，如图 2－36（a）所示；若相加结果为 0 ，则表明结果中无此项，删除结点 $p$ 和结点 $q$ ，并将指针 $p$ 和指针 $q$ 分别后移，如图 2－36（b）所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-073.jpg?height=763&width=1276&top_left_y=1220&top_left_x=270)

图 2－36 第三种情况示意图
综合上述三种情况，一元多项式相加算法用伪代码描述如下：

算法：AddPolynomial（A，B）
输人：两个单链表 A 和 B
输出：单链表 $A$ 和 $B$ 的合并结果
1．初始化工作指针 pre、p、qre、q；

2．while（ p 存在且 q 存在）执行下列三种情形之一：
2.1 如果 $p->\exp$ 小于 $q->\exp$ ，则指针 pre 和 $p$ 后移；
2.2 如果 $p->\exp$ 大于 $q->\exp$ ，则

2．2．1将结点 $q$ 插人到结点 $p$ 之前；
2．2．2指针 $q$ 指向原指结点的下一个结点；
2.3 如果 $p->\exp$ 等于 $q->\exp$ ，则

2．3．1 p－＞coef $=p->$ coef $+q->$ coef；
2．3．2 如果 $p->\operatorname{coef}$ 等于 0 ，则执行下列操作，否则，指针 $p$ 后移；
2．3．2．1 删除结点 $p$ ；
2．3．2．2使指针 p 指向它原指结点的下一个结点；
2．3．3 删除结点 $q$ ；
2．3．4使指针 $q$ 指向它原指结点的下一个结点；
3．如果 q 不为空，将结点 q 链接在第一个单链表的后面；

【程序】定义类 Polynomial，其中成员变量 first 表示单链表的头指针，构造函数生成一元多项式单链表，重载运算符＋，拷贝构造函数在语句＂ $\mathrm{A}=\mathrm{A}+\mathrm{B}$ ；＂赋值时被调用，析构函数同单链表的析构函数，请读者自行设计。主函数接收从键盘输入的系数和指数，分别建立多项式变量 $A$ 和 $B$ ，表达式 $A+B$ 实现两个一元多项式相加，再调用函数 Print打印结果。程序如下：
\end{verbatim}

\#include <iostream>\\
using namespace std;\\
struct Node //定义多项式单链表的结点\\
\{\\
int coef, exp; // coef 表示系数, exp 表示指数\\
Node * next;\\
\};\\
class Polynomial\\
\{\\
public:\\
Polynomial(): //构造函数\\
Polynomial(const Polynomial \&B); //拷贝构造函数\\
\~{}Polynomial(); //析构函数,同单链表析构函数\\
Polynomial operatox+(Polynomial \&B); //重载运算符,多项式相加\\
void Print(); //打印一元多项式单链表\\
private:\\
Node * first; //一元多项式单链表的头指针\\
\};\\
Polynomial :: Polynomial()\\
\{\\
Node * r = nullptr, * s = nullptr;\\
int coef, exp;\\
first = new Node;

\begin{verbatim}
    r = first;1／尾擂法建立单链表
    cout<<"请输人系数和指数:";
    cin >>coef >>exp; |/输人第一项的系数和指数
    while (coef != 0) //循环结束的条件是输人系数为 0
    f
        s = new Node; s->coef = coef; s->exp = exp;
        r->next = s; r = s; //将结点 s 插入单链表的尾部
        cout <<"请输入系数和指数:"";
        cin >>coef >>exp;
    }
    r->next = nullptr;
}
Po1ynomial :: Polynomial(const Polynomial &B)
|
    first = B.first;
}
Polynomial Polynomial :: operator+(Polynomial &B)
f
    Node *pre = first, *p=pre->next; //工作指针pre和 p 初始化
    Node *qre = B.flrst, * q = qre->next; //工作指针 qre和 q 初始化
    Node *qtemp = nullptz;
    while (p != nullptr && q != nullptr)
    l
        if (p->exp < q->exp) { //第1种情况
            pre = p; p = p->next;
        )
        else if (p->exp>q->exp) { //第 2 种情况
                    qtemp = q->next;
                    pre->next = q; //将结点 q 雿人到结点 p 之前
                    q->next = p;
                    q = qtemp;
                    pre = q;
                    qre->next = q;
                )
                else !
                    p->coef = p->coef + q->coef;
                    if (p->coef = 0) { //系数相加为 0,则删除结点 p
                        pre->next = p->next;
                            delete p;
                        p = pre->next;
                    )
                    else {
                            pre = p;p = p->next;
                    )
                    qre->next = q->next;
//第 3 种情况都要删除结点 q
\end{verbatim}

\begin{verbatim}
                    delete q;
                    q = qre->next;
        }
        if (q != nullptx) pre->next = q; //将结点q链接在第一个单链表的后面
        return * this;
)
void Polynomial :: Print()
{
    Node *p = first->next;
    if (p != nullptr) //输出第一项
        cout <<p->coef <<"x" <<p->exp;
    p=p->next;
    while (p != nullptr)
    i
        if (p->coef> 0) ||输出系数的正号或负号
            cout <<"+" <<p->coef <<"x" <<p->exp;
        else
            cout <<p->coef <<"x" <<p->exp;
        p = p->next;
    )
}
int main()
{
    PolynomialA{ }, B{ }; //定义多项式A和B
    A.Print(); B.Print();
    A = A + B; // +运算符重载,对象赋值调用拷贝构造函数
    cout <<"结果是:";
    A.Print(); //输出相加结果
    return 0;
)
\end{verbatim}

\section*{思想火花——好算法是反复努力和重新修正的结果}
考虑一个问题：将一个具有 $n$ 个元素的数组向左循环移动 $i$ 个位置。有许多应用程序会调用这个问题的算法，例如在文本编辑器中移动行的操作，磁盘整理时交换两个不同大小的相邻内存块等。所以，这个问题的算法要求有较高的时间和空间性能。

解法 1：先将数组中的前 $i$ 个元素存放在一个临时数组中，再将余下的 $n-i$ 个元素左移 $i$ 个位置，最后将前 $i$ 个元素从临时数组复制回原数组中后面的 $i$ 个位置。但是这个算法使用了 $i$ 个额外的存储单元，其空间复杂度是 $O(i)$ 。

解法 2：先设计一个函数将数组向左循环移动 1 个位置，然后再调用该算法 $i$ 次，显

然，这个算法的时间性能不好，其时间复杂度是 $O(n \times i)$ 。\\
解法 3：将这个问题看作把数组 ab 转换成数组 ba （ a 代表数组的前 $i$ 个元素， b 代表数组中余下的 $n-i$ 个元素），先将 a 逆置得到 $\mathrm{a}^{\mathrm{r}} \mathrm{b}$ ，再将 b 逆置得到 $\mathrm{a}^{\mathrm{r}} \mathrm{b}^{\mathrm{r}}$ ，最后将整个 $\mathrm{a}^{\mathrm{r}} \mathrm{b}^{\mathrm{r}}$逆置得到 $\left(a^{r} b^{r}\right)^{r}=b a$ 。设 Reverse 函数执行将数组元素逆置的操作，对 abcdefgh 向左循环移动 3 个位置的过程如下：

\begin{center}
\begin{tabular}{ll}
Reverse $(0, i-1) ;$ & $/ /$ 得到 cbadefgh \\
Reverse $(i, n-1) ;$ & $/ /$ 得到 cbahgfed \\
Reverse $(0, n-1) ;$ & $/ /$ 得到 defghabc \\
\hline
\end{tabular}
\end{center}

其原理可以用一个简单的游戏来理解：将两手的掌心对着自己，左手在右手上面，可以实现将一个具有 10 个元素的数组向左循环移动 5 位，如图 2－37 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-077}

图 2－37 利用数组逆置进行循环移位的示意图\\
该算法的时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ ，并且算法简短和简单，想出错都很难。Brian Kernighan 在 Software Tools in Pascal 中使用了这个算法在文本编辑器中移动各行。

\section*{习 题 2}
\section*{1．选择题}
（1）线性表的顺序存储结构是一种（ ）的存储结构，线性表的链接存储结构是一种（ ）的存储结构。\\
A．随机存取\\
B．顺序存取\\
C．索引存取\\
D．散列存取\\
（2）线性表采用链接存储时，其地址（）。\\
A．必须是连续的\\
B．部分地址必须是连续的\\
C．一定是不连续的\\
D．连续与否均可以\\
（3）循环单链表的主要优点是（）。\\
A．不再需要头指针了\\
B．从表中任一结点出发都能扫描到整个链表\\
C．已知某个结点的位置后，能够容易找到它的直接前趋

D．在进行插入、删除操作时，能更好地保证链表不断开\\
（4）链表不具有的特点是（）。\\
A．可随机访问任一元素\\
B．插人、删除不需要移动元素\\
C．不必事先估计存储空间\\
D．所需空间与线性表长度成正比\\
（5）若某线性表中最常用的操作是取第 $i$ 个元素和找第 $i$ 个元素的前趋，则采用（）存储方法最节省时间。\\
A．顺序表\\
B．单链表\\
C．双链表\\
D．单循环链表\\
（6）若线性表中最常用的操作是在最后一个元素之后插人一个元素和删除第一个元素，则采用（ ）存储方法最节省时间。\\
A．单链表\\
B．带头指针的单循环链表\\
C．双链表\\
D．带尾指针的单循环链表\\
（7）若链表中最常用的操作是在最后一个结点之后插人一个结点和删除最后一个结点，则采用（ ）存储方法最节省运算时间。\\
A．单链表\\
B．循环双链表\\
C．单循环链表\\
D．带尾指针的单循环链表\\
（8）在具有 $n$ 个结点的有序单链表中插人一个新结点并仍然保持有序的时间复杂度是（ ）。\\
A．$O(1)$\\
B．$O(n)$\\
C．$O\left(n^{2}\right)$\\
D．$O\left(n \log _{2} n\right)$\\
（9）对于 $n$ 个元素组成的线性表，建立一个有序单链表的时间复杂度是（）。\\
A．$O(1)$\\
B．$O(n)$\\
C．$O\left(n^{2}\right)$\\
D．$O\left(n \log _{2} n\right)$\\
（10）使用双链表存储线性表，其优点是可以（）。\\
A．提高检索速度\\
B．更方便数据的插人和删除\\
C．节约存储空间\\
D．很快回收存储空间\\
（11）在一个单链表中，已知 q 所指结点是 p 所指结点的直接前驱，若在 q 和 p 之间插人 s 所指结点，则执行（ ）操作。

A． $\mathrm{s}->$ next $=\mathrm{p}->$ next $; \mathrm{p}->$ next $=\mathrm{s} ;$\\
B． $\mathrm{q}->$ next $=\mathrm{s} ; \mathrm{s}->$ next $=\mathrm{p}$ ；\\
C．$p->n e x t=s->n e x t ; s->n e x t=p$ ；\\
D． $\mathrm{p}->$ next $=\mathrm{s} ; \mathrm{s}->$ next $=\mathrm{q}$ ；\\
（12）在循环双链表的 $p$ 所指结点后插入 $s$ 所指结点的操作是（ ）。\\
A．$p->n e x t=s$ ；\\
B．$p->n e x t=s$ ；\\
$s->$ prior $=p$ ；\\
p－＞next－＞prior＝s；\\
p－＞next－＞prior＝s；\\
$s->$ prior $=p$ ；\\
$\mathrm{s}->\mathrm{next}=\mathrm{p}->\mathrm{next}$ ；\\
$s->$ next $=p->$ next；\\
C．$s->$ prior $=p$ ；\\
D．$s->$ prior $=p$ ；\\
$s->$ next $=p->$ next\\
$s->$ next $=p->$ next；\\
$\mathrm{p}->\mathrm{next}=\mathrm{s}$ ；\\
p－＞next－＞prior＝s；\\
p－＞next－＞prior＝s；\\
$\mathrm{p}->$ next $=\mathrm{s}$\\
（13）用数组 $r$ 存储静态链表，结点的 next 域指向后继，工作指针 $j$ 指向链中某结点，则 j 后移的操作语句为（）。\\
A．$j=r[j]$ ．next\\
B． $\mathrm{j}=\mathrm{j}+1$\\
C．$j=j->n e x t$\\
D． $\mathrm{j}=\mathrm{r}[\mathrm{j}]->$ next\\
（14）设线性表有 $n$ 个元素，以下操作中，（ ）在顺序表上实现比在链表上实现的效率更高。

A．输出第 $i(1 \leqslant i \leqslant n)$ 个元素值\\
B．交换第 1 个和第 2 个元素的值\\
C．顺序输出所有 $n$ 个元素\\
D．查找与给定值 $x$ 相等的元素在线性表中的序号\\
（15）假设线性表只有 4 种基本操作：删除第一个元素；删除最后一个元素；在第一个元素前插人新元素；在最后一个元素之后插人新元素，则最好使用（）。

A．只设尾指针的循环单链表\\
B．只设尾指针的非循环双链表\\
C．只设头指针的循环双链表\\
D．同时设置头指针和尾指针的循环单链表\\
2．解答下列问题\\
（1）请说明顺序表和单链表有何优缺点，并分析下列情况采用何种存储结构更好些。\\
（1）若线性表的总长度基本稳定，且很少进行插人和删除，但要求以最快的速度存取线性表中的元素。\\
（2）如果 $n$ 个线性表同时并存，并且在处理过程中各表的长度会动态发生变化。\\
（2）举例说明对于相同的逻辑结构在不同的存储方式下，基本操作的效率不同。\\
（3）如果某线性表中数据元素的类型不一致，但是希望能根据下标随机存取每个元素，请为这个线性表设计一个合适的存储结构。\\
（4）设 $n$ 表示线性表中的元素个数，$E$ 表示存储数据元素所需的存储单元大小，$D$ 表示可以在数组中存储线性表的最大元素个数（ $D \geqslant n$ ），则使用顺序存储方式存储该线性表需要多少存储空间？\\
（5）设 $n$ 表示线性表中的元素个数，$P$ 表示指针所需的存储单元大小，$E$ 表示存储数据元素所需的存储单元大小，则使用单链表存储方式存储该线性表需要多少存储空间（不考虑头结点）？

\section*{3．算法设计}
（1）已知顺序表 L 中的元素递增有序排列，设计算法将元素 x 插人到表 L 中并保持表 L 仍递增有序。\\
（2）在顺序表中删除所有元素值为 x 的元素，要求空间复杂度为 $O(1)$ 。\\
（3）试分别以顺序表和单链表作存储结构，各编写一个实现线性表就地逆置的算法。\\
（4）设计算法判断非空单链表是否递增有序。\\
（5）给定一个带头结点的单链表，设计算法按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间（要求：不允许使用数组作辅助空间）。\\
（6）设单链表以非递减有序排列，设计算法实现在单链表中删去值相同的多余结点。\\
（7）已知单链表中各结点的元素值为整型且递增有序，设计算法删除链表中大于 mink 且小于 maxk 的所有元素，并释放被删结点的存储空间。\\
（8）有两个整数序列 $\mathrm{A}=\left(\mathrm{a}_{1}, \mathrm{a}_{2}, \cdots, \mathrm{a}_{\mathrm{m}}\right)$ 和 $\mathrm{B}=\left(\mathrm{b}_{1}, \mathrm{~b}_{2}, \cdots, \mathrm{~b}_{\mathrm{n}}\right)$ 已经存人两个单链表中，设计算法判断序列 $B$ 是否是序列 $A$ 的子序列。\\
（9）假设在长度大于 1 的循环链表中，即无头结点也无头指针， s 为指向链表中某个结点的指针，试编写算法删除结点 s 的前趋结点。\\
（10）判断带头结点的双循环链表是否对称。\\
（11）设计算法实现在双链表中第 i 个结点的后面插人一个值为 x 的结点。\\
（12）假设用不带头结点的单链表表示八进制数，例如八进制数 536 表示成如图2－38所示单链表。要求写一个函数 Add，该函数有两个参数 A 和 B，分别指向表示八进制数的单链表，执行函数调用 $\operatorname{Add}(A, B)$ 后，得到表示八进制数 $A$ 加八进制数 $B$ 所得结果的单链表。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-080}

图 2－38 用链表表示八进制数

\section*{实 验 题 2}
【实验 1】请上机实现 2．3．3 节顺序表的使用范例和 2．4．3 节单链表的使用范例，并用不同的线性表实例进行测试。

【实验 2】用单链表实现集合的基本操作。需要注意集合中元素的唯一性，即在单链表中不存在值相同的结点，算法思路仍然是以遍历为基础。设两个单链表 L1 和 L2 分别表示两个集合，设计算法实现并、交、差、判断 L1 是否是 L2 的子集等基本操作。

【实验 3】在单链表的具体应用中，数据元素有了具体的数据类型，因此，需要根据题目设计结点的存储结构。某商店的仓库中，对电视机按其价格从低到高建立一个单链表，链表的每个结点指出同样价格的电视机的台数。现有 $m$ 台价格为 $n$ 元的电视机人库，请应用单链表类完成仓库的进货管理。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-081(1)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-081(2)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-081}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-081(4)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-081(3)}\\
$\qquad$\\
$\qquad$

\section*{3．}
\section*{栈 和 队 列}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
本章概述 & \multicolumn{5}{|c|}{\begin{tabular}{l}
栈和队列是两种常用的数据结构，广泛应用在操作系统、编译程序等各种软件系统中。从数据结构角度看，栈和队列是操作受限的线性表，栈和队列的数据元素具有单一的前驱和后继的线性关系；从抽象数据类型角度看，栈和队列是两种重要的抽象数据类型。由于栈和队列的操作特性，在很多复杂问题的求解中，往往采用栈或队列作为辅助数据结构，例如，在表达式求值、图的遍历、拓扑排序等算法中使用栈或队列作为辅助数据结构。因此，要熟练掌握栈和队列的操作语句。 \\
本章由实际问题抽象出栈和队列的数据模型，讨论栈的顺序存储和链接存储及其实现，讨论队列的顺序存储和链接存储及其实现，最后给出栈和队列的应用实例。 \\
\end{tabular}} \\
\hline
教学重点 & \multicolumn{5}{|l|}{栈和队列的操作特性；桟和队列基本操作的实现} \\
\hline
教学难点 & \multicolumn{5}{|l|}{循环队列的存储方法；循环队列中队空和队满的判定条件} \\
\hline
\multirow{11}{*}{\begin{tabular}{l}
教学内容和 \\
教学目标 \\
\end{tabular}} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教 学 要 求} \\
\hline
 &  & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline
 & 栈的逻辑结构及操作特性 &  &  &  & $\checkmark$ \\
\hline
 & 顺序桟 &  &  &  & $\checkmark$ \\
\hline
 & 链栈 &  &  & $\checkmark$ &  \\
\hline
 & 顺序栈和链栈的比较 &  & $\checkmark$ &  &  \\
\hline
 & 队列的逻辑结构及操作特性 &  &  &  & $\checkmark$ \\
\hline
 & 顺序队列 &  &  & $\checkmark$ &  \\
\hline
 & 循环队列 &  &  &  & $\checkmark$ \\
\hline
 & 链队列 &  &  & $\checkmark$ &  \\
\hline
 & 循环队列和链队列的比较 &  & $\checkmark$ &  &  \\
\hline
\end{tabular}
\end{center}

\section*{3.1 引言}
栈和队列是两种特殊的线性表，用于组织需要后到先处理或先到先处理的数据。在实际问题的处理过程中，有些数据具有后到先处理或先到先处理的特点，请看下面几个例子。

【例 3－1】括号匹配问题。C＋＋语言对于算术表达式中括号的配对原则是：右括号＂）＂与其前面最近的尚未配对的左括号＂（＂相配对。判断给定表达式中所含括号是否正确配对。

【想法——数据模型】顺序扫描表达式，当扫描到右括号＂）＂时，查找已经扫描过的最后一个尚未配对的左括号＂（＂。＂（＂具有最后扫描最先配对的特点，因此通常用栈结构来描述这种具有后到先处理特征的数据\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-083}模型。那么，栈是如何保存已经扫描且尚未配对的左括号，当扫描到右括号时，如何将栈中最后那个左括号删除并与右括号配对呢？

【例 3－2】函数的嵌套调用。函数的嵌套调用是在函数的执行过程中再调用其他函数，例如图 3－1（a）所示函数调用过程，在函数 A 尚未执行结束时调用函数 B，在函数 B 尚未执行结束时又调用函数 C ，那么，当函数 C 执行结束时，应该返回到什么位置呢？\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-083(2)}\\
（a）函数的嵌套调用

\begin{center}
\begin{tabular}{|c|}
 \\
\hline
\begin{tabular}{c}
B的调用位置 \\
及执行环境 \\
\end{tabular} \\
\hline
\begin{tabular}{c}
A的调用位置 \\
及执行环境 \\
\end{tabular} \\
\hline
\end{tabular}
\end{center}

（b）工作栈示意图

图 3－1 函数嵌套调用过程中工作栈的作用\\
【想法——数据模型】为保证函数嵌套调用的正确执行，系统设立了工作栈保存函数的调用位置及执行环境。当被调用函数执行完毕，返回到最后保存的调用位置。对于图 3－1（a）所示函数调用过程，保存的调用次序如图3－1（b）所示。当函数 C 执行结束时，取出工作栈顶端的数据并恢复执行环境，然后继续执行调用位置的下一条语句。那么，系统工作栈是如何进行存储并保证调用次序的正确性呢？

【例 3－3】银行排队问题。在需要顺序操作且人群众多的场合，排队是现代文明的一种体现。例如，储户到银行办理个人储蓄业务需要排队等待，请实现银行排队系统。

【想法——数据模型】窗口应该保证为先来的储户优先提供服务，通常用队列来描述这种具有先到先处理特征的数据模型。储户需要领取\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-083(1)}一张排队单，在排队单上打印了储户的顺序号。窗口会按照先来先服务的原则顺次叫号，如图 3－2 所示。那么，队列是如何保存正在等待的储户，如何保证为先来的储户优先提供服务呢？\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-084}

图 3－2 银行排队办理业务\\
【例 3－4】打印缓冲区。将计算机中的数据传送到打印机上打印输出，显然，打印机的打印速度远远小于计算机处理数据的速度，如果将数据直接送到打印机上，就会导致计算机处理完一批数据就要等待打印输出。如何解决计算机处理速度与打印机输出速度不匹配的矛盾呢？

【想法——数据模型】为了提高计算机的处理效率，通常设置一个缓冲区，计算机将处理完的数据送到打印缓冲区中，打印机从打印缓冲区取出数据进行打印。由于打印机的速度比较慢，来不及打印的数据就在缓冲区排队等待。为了保证正确打印，这个缓冲区必须按照先来先服务的原则依次打印。那么，缓冲区如何存储打印任务并实现正确打印呢？

\section*{3.2 栈}
\section*{3．2．1 栈的逻辑结构}
\section*{1．栈的定义}
栈（stack）是限定仅在表的一端进行插人和删除操作的线性表，允许插入和删除的一端称为栈顶（stack top），另一端称为栈底（stack bottom），不含任何数据元素的栈称为空栈。

如图 3－3 所示，栈中有三个元素，插人元素（也称人栈、进栈、压栈）的顺序是 $a_{1} 、 a_{2} 、$ $a_{3}$ 。当需要删除元素（也称出栈、弹栈）时只能删除 $a_{3}$ ，换言之，任何时刻出栈的元素都只能是栈顶元素，即最后人栈者最先出栈，所以栈中元素除了具有线性关系外，还具有后进\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-084(1)}

图 3－3 栈的示意图先出（last in first out）${ }^{(1)}$ 的特性。

在日常生活中，有很多栈的例子，例如，一叠摞在一起的盘子，要从这叠盘子中取出或放人一个盘子，只有在其顶部操作才是最方便的；早在计算机出现之前，会计就使用栈来记账；火车扳道站、单车道死胡同等等。再如，在浏览网页时，将浏览过的网址用栈进行存储，每访问一个网页，将其地址存放到栈顶，按＂后退＂按钮即可沿相反次序返回此前刚访问过的页面。

\footnotetext{（1）需要注意的是，栈只是对线性表的插人和删除操作的位置进行了限制，并没有限定插人和删除操作进行的时间。也就是说，出栈可随时进行，只要某个元素位于栈顶就可以出栈。例如，三个元素按 $a 、 b 、 c$ 的次序依次进栈，且每个元素只允许进一次栈，则所有元素都出栈后，可能的出栈序列有 $a b c 、 a c b 、 b a c 、 b c a 、 c b a$ 五种。
}\section*{2．栈的抽象数据类型定义}
虽然对插人和删除操作的位置限制减少了栈操作的灵活性，但同时也使得栈的操作更有效更容易实现。其抽象数据类型定义为：

\begin{verbatim}
ADT Stack
DataModel
    元素具有后进先出特性,相邻元素具有前驱和后继关系
Operation
    InitStack
        输人:无
        功能:桟的初始化
        输出:一个空栈
    DestroyStack
        输人:无
        功能:栈的销毁
        输出:释放栈的存储空间
    Push
        输人:元素值 x
        功能:人栈操作,在栈顶插人一个元素 x
        输出:如果括人成功,栈顶增加了一个元素,否则返回描人失败信息
    POP
        输人:无
        功能:出栈操作,删除栈顶元素
        输出:如果删除成功,返回被删元妻值,否则返回删除失败信息
    GetTop
        输人:无
        功能:取栈顶元素,读取当前的栈顶无素
        输出:若栈不空,返可当前的栈顶元素值,否则返圆取栈顶失败信息
    Empty
        输人:无
        功能:判空操作,判断栈是否为空
        输出:如果栈为空,返可1,否则返回0
endADT
\end{verbatim}

\section*{3．2．2 栈的顺序存储结构及实现}
\section*{1．顺序栈的存储结构}
栈的顺序存储结构称为顺序栈（sequential stack）。顺序栈本质上是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底。通常把数组中下标为 0 的一端作为栈底，同时附设变量 top 指示栈顶元素在数组中的位置 ${ }^{(1)}$ 。设存储栈的数组长度为 Stack Size，则栈空时栈顶位置 top $=-1$ ；栈满时栈顶

\footnotetext{（1）在有些教材中，将 top 指向栈中第一个空闲位置，如果这样的话，空栈应该表示为 top $=0$ 。
}位置 top $=$ StackSize -1 。人栈时，栈顶位置 top 加 1 ；出栈时，栈顶位置 top 减 1 。栈操作的示意图如图 3－4 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-086}

图 3－4 栈的操作示意图

\section*{2．顺序栈的实现}
将栈的抽象数据类型定义在顺序栈存储结构下用 C ++ 的类实现。顺序栈类定义如下，其中成员变量实现顺序栈的存储结构，成员变量实现栈的基本操作。

\begin{verbatim}
const int StackSize = 10; //根据实际问题具体定义
template <typename DataType> //定义模板类 SeqStack
class SeqStack
{
public:
    SeqStack(); //构造函数,初始化一个空栈
    ~ Seqstack(); //析构函数
    void Push (DataType x); 1/人栈操作,将元素 x 人栈
    DataType Pop(); //出栈操作,将栈顶元素弹出
    DataType GetTop(); //取栈顶元素(并不删除)
    int Empty(); //判断栈是否为空
private:
    DataType data[StackSize]; //存放栈元素的数组
    int top; //栈顶元素在数组中的下标
};

根据栈的操作定义，容易写出顺序栈基本操作的算法，且时间复杂度均为 $O(1)$ 。
（1）构造函数——顺序栈的初始化
初始化一个空的顺序栈只需将栈顶指针 top 置为 -1 。
（2）析构函数——顺序栈的销毁
顺序栈是静态存储分配，在顺序栈变量退出作用域时自动释放顺序栈所占存储单元，因此，顺序栈无须销毁，析构函数为空。
（3）人栈操作
在栈中插人元素 x 只需将栈顶位置 top 加 1 ，然后在 top 的位置填人元素 x 。人栈操

作的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
void SeqStack<DataType> : : Push (DataType x)\\
(\\
if (top == StackSize -1) throw "上粪";\\[0pt]
data[++top] = x;\\
)\\
（4）出栈操作\\
出栈操作只需取出栈顶元素，然后将栈顶位置 top 减 1 。出栈操作的成员函数定义如下：

\begin{verbatim}
template <typename DataType>
DataType SeqStack<DataType> ::Pop()
f
    DataType x;
    if (top = = -1) throw "下溢";
    x = dataltop--];
    return x;
}
\end{verbatim}

\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-087}\\
（5）取栈顶元素\\
取栈顶元素只是将 top 位置的栈顶元素取出并返回，并不修改栈顶位置。\\
（6）判空操作\\
顺序栈的判空操作只需判断 top 是否等于 -1 。

\section*{3．顺序栈的使用}
在定义了顺序栈类 SeqStack 并实现了基本操作后，在程序中就可以使用 SeqStack类来定义变量，可以调用实现基本操作的函数来完成相应功能。范例程序如下：

\begin{verbatim}
#include <iostream>
using namespace std;
//将顺序栈的类定义和各个成员函数定义写到这里
int main()
l
int x;
SeqStack<int> S{);1／定义顺序栈变量 Scout＜＜＂对 15 和 10 执行人栈操作，＂；S．Push（15）；S．Push（10）；cout \ll＂当前栈顶元素为：＂＜＜S．GetTop（）\llendl；／／输出栈顶元素 10
\end{verbatim}

\begin{verbatim}
try
    $\mathrm{x}=\mathrm{S} \cdot \operatorname{POP}() ;$
    cout <<"执行一次出栈操作, 删除元素" <<x<<endl; //输出出栈元素 10
\} catch (char * str) (cout < str \llendl; )
try
    cout <<"请输人待人栈元素: ";
    cin >>x;
    S. Push (x) ;
\} catch (char * str) (cout \llstr \llendl; \}
if (S.Empty ( ) = = 1) cout <<"栈为空" <<endj;
else cout <<"栈非空" <<endl; //栈有 2 个元素, 输出栈非空
return 0 ;
\end{verbatim}

\section*{3．2．3 栈的链接存储结构及实现}
\section*{1．链栈的存储结构}
栈的链接存储结构称为链栈（linked stack），通常用单链表表示，其结点结构与单链表的结点结构相同，请参见2．4．1节。因为只能在栈顶执行插人和删除操作，显然以单链表的头部作栈顶是最方便的，而且没有必要像单链表那样为了运算方便附加头结点。通常将链栈表示成如图 3－5 的形式。

\section*{2．链栈的实现}
将栈的抽象数据类型定义在链栈存储结构下用 C＋＋的类实现。链栈类定义如下，其中成员变量 top 为栈顶指针，成员函数实现栈的基本操作。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-088}

图 3－5 链栈示意图

\begin{verbatim}
template <typename DataType>
class LinkStack
{
public:
    LinkStack(); //构造函数,初始化一个空链栈
    ~ LinkStack(); //析构函数,秚放链栈各结点的存储空间
    void Push (DataType x); //人栈操作,将元素 x 入栈
    DataType Pop(); //出栈操作,将栈顶元素出栈
    DataType GetTop(); //取栈顶元素(并不删除)
    int Empty (); //判空操作,判断链栈是否为空栈
private:
    Node<DataType> * top; //栈顶指针即链栈的头指针
);
\end{verbatim}

链栈的基本操作本质上是单链表基本操作的简化，由于插人和删除操作仅在单链表的头部进行，因此，算法的时间复杂度均为 $O(1)$ 。\\
（1）构造函数——链栈的初始化\\
由于链栈不带头结点，初始化一个空链栈只需将栈顶指针 top 置为空。\\
（2）析构函数——链栈的销毁\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-089}

链栈是动态存储分配，在链栈变量退出作用域前要释放链栈的存储空间。链栈类的析构函数与单链表类的析构函数类似，请读者自行给出。\\
（3）人栈操作\\
链栈的插人操作只需处理栈顶的情况，其操作示意图如图 3－6所示，成员函数如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-089(2)}\\
（4）出栈操作\\
链栈的删除操作只需处理栈顶的情况，其操作示意图如图 3－7 所示，成员函数如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-089(1)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-089(4)}

图 3－6 链栈插人操作示意图\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-089(3)}

图 3－7 链栈删除操作示意图\\
（5）取栈顶元素\\
取栈顶元素只需返回栈顶指针 top 所指结点的数据域，并不修改栈顶指针。\\
（6）判空操作\\
链栈的判空操作只需判断 top 指针是否为空。

\section*{3．链栈的使用}
在定义了链栈类 LinkStack 并实现了链栈的基本操作后，程序中就可以使用 LinkStack类来定义变量，可以调用实现基本操作的函数来完成相应功能。范例程序如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-090}

\section*{3．2．4 顺序栈和链桟的比较}
顺序栈和链栈基本操作的时间复杂度均为 $O(1)$ ，因此唯一可以比较的是空间性能。初始时顺序栈必须确定一个固定的长度，所以有存储元素个数的限制和浪费空间的问题。链栈没有栈满的问题，只有当内存没有可用空间时才会出现栈满，但是每个元素都需要一个指针域，从而产生了结构性开销。作为一般规律，当栈的使用过程中元素个数变化较大

时，应该采用链栈，反之，应该采用顺序栈。

\section*{3.3 队 列}
\section*{3．3．1 队列的逻辑结构}
\section*{1．队列的定义}
队列（queue）是只允许在一端进行插人操作，在另一端进行删除操作的线性表，允许插人（也称人队、进队）的一端称为队尾（queue－tail），允许删除（也称出队）的一端称为队头（queue－head）。图3－8所示是一个有 5个元素的队列，人队的顺序为 $a_{1} 、 a_{2} 、 a_{3} 、 a_{4} 、 a_{5}$ ，出队的顺序依然是 $a_{1} 、 a_{2} 、 a_{3} 、 a_{4} 、 a_{5}$ ，即最先人队者最先出队。所以队列中的元素除了具有线性关系外，还具有先进先出（first in first out）的特性。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-091}

图 3－8 队列的示意图\\
现实世界中有许多问题可以用队列描述，例如，对顾客服务部门（例如银行、电信等）的工作往往是按队列方式进行的，这类系统称为排队系统。在程序设计中，经常使用队列保存按先进先出方式处理的数据，例如键盘缓冲区、操作系统中的作业调度等。

\section*{2．队列的抽象数据类型定义}
\begin{verbatim}
ADT Queve
DataModel
    元素具有先进先出特性,相邻元素具有前驱和后继关系
Operation
    Initqueue
        输人:无
        功能:队列的初始化
        输出:一个空队列
    DestroyQueue
        输人:无
        功能:队列的销毁
        输出:秚放队列占用的存储空间
    EnQueue
        输入:元素值 x
        功能:人队操作,在队尾括人元素 *
        输出:如果插人成功,以尾增加了一个元素,否则返回插人失败信息
    Dequeue
\end{verbatim}

\begin{verbatim}
    输人:无
    功能:出队操作,删除队头元素
    输出:如果删除成功,似头减少了一个元素,否则返回删除失败信息
    GetHead
        输人:无
        功能:读取队头元素
        输出:若队列不空,迈回队头元素,否则迈回取队头失败信息
    Empty
        输人:无
        功能:判空操作,判断队列是否为空
        输出:如果队列为空,返回1,否则返回。
endADT
\end{verbatim}

\section*{3．3．2 队列的顺序存储结构及实现}
\section*{1．顺序队列的存储结构}
队列的顺序存储结构称为顺序队列（sequential queue）。假设队列有 $n$ 个元素，顺序队列把队列的所有元素存储在数组的前 $n$ 个单元。如果把队头元素放在数组中下标为 0 的一端，则人队操作相当于追加，不需要\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-092}移动元素，其时间性能为 $O(1)$ ；但是出队操作的时间性能为 $O(n)$ ，因为要保证剩下的 $n-1$ 个元素仍然存储在数组的前 $n-1$ 个单元，所有元素都要向前移动一个位置，如图 3－9（c）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-092(1)}

图 3－9 顺序队列的操作示意图\\
如果放宽队列的所有元素必须存储在数组的前 $n$ 个单元这一条件，就可以得到一种更为有效的存储方法，如图 3－9（d）所示。此时人队和出队操作的时间性能都是 $O(1)$ ，因为没有移动任何元素，但是队列的队头和队尾都是活动的，因此，需要设置队头、队尾两个位置变量 front 和 rear，人队时 rear 加 1 ，出队时 front 加 1 ，并且约定：front 指向队头元素的前一个位置，rear 指向队尾元素的位置 ${ }^{(1)}$ 。

\section*{2．循环队列的存储结构}
在顺序队列中，随着队列的插人和删除操作，整个队列向数组的高端移过去，从而产

\footnotetext{（1）这样约定的目的是为了方便运算，例如 rear—front 等于队列的长度。有些参考书约定队头指针 front 指向队头元素，队尾指针 rear 指向队尾元素；或队头指针 front 指向队头元素，队尾指针 rear 指向队尾元素的后一个位置。
}生了队列的＂单向移动性＂。当元素被插人到数组中下标最大的位置之后，数组空间就用尽了，尽管此时数组的低端还有空闲空间，这种现象叫作假溢出（false overflow），如图3－10（a）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-093}\\
（a）front $=1$ ，rear $=4$ 假溢出\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-093(2)}\\
（b）rear $=0$ 解决假溢出

图 3－10 循环队列的假溢出及其解决\\
解决假溢出的方法是将存储队列的数组看成是头尾相接的循环结构，即允许队列直接从数组中下标最大的位置延续到下标最小的位置，如图 3－10（b）所示，这可以通过取模操作来实现，设存储队列的数组长度为 QueueSize，操作语句为 rear $=($ rear +1$) \%$ QueueSize。队列的这种头尾相接的顺序存储结构称为循环队列（circular queue）。

在循环队列中，如何判定队空和队满呢？如图3－11（a）和（c）所示，队列中只有一个元素，执行出队操作，则队头位置在循环意义下加 1 后与队尾位置相等，即队空的条件是 front $=$ rear。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-093(1)}

图 3－11 循环队列队空的判定\\
如图 3－12（a）和（c）所示，数组中只有一个空闲单元，执行人队操作，则队尾位置在循环意义下加 1 后与队头位置相等，即队满的条件也是 front $=$ rear。如何将队空和队满的判定条件区分开呢？可以浪费一个数组元素空间 ${ }^{(1)}$ ，把图3－12（a）和（c）所示的情况视为队满，此时队尾位置和队头位置正好差 1 ，即队满的条件是：$(r e a r+1) \%$ QueueSize $=$ front。

\section*{3．循环队列的实现}
将队列的抽象数据类型定义在循环队列存储结构下用 C＋＋中的类实现。循环队列

\footnotetext{（1）算法设计有一个重要的原则；时空权衡，一般来说，酩牲空间或其他替代资源，通常可以减少时间代价。例如，在单链表的开始结点之前附设一个头结点，使得单链表的插人和删除等操作不用考虑表头的特殊情况；在双链表中，结点设置了指向前驱结点的指针和指向后继结点的指针，增加了指针的结构性开销，减少了查找前驱和后继的时间代价。
}\begin{center}
\begin{tabular}{|l|l|}
\hline
\multirow{3}{*}{4 $\xrightarrow{\text { front }} \begin{array}{r}3 \\ -2\end{array}$} & $a_{5}$ \\
\hline
 & $a_{4}$ \\
\hline
 &  \\
\hline
\( \underset{\text { rear }}{\longrightarrow}-1 \) & $a_{7}$ \\
\hline
0 & $a_{6}$ \\
\hline
\end{tabular}
\end{center}

（a）队满的临界状态 front＞rear\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-094(1)}\\
（b）队满 rear＝front\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-094(3)}\\
（c）队满的临界状态 front＜rear\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-094}\\
（d）队满 rear＝front

图 3－12 循环队列队满的判定\\
类定义如下，其中成员函数实现顺序队列的存储结构，循环队列是在程序中通过求模的方法实现，成员函数实现队列的基本操作。

\begin{verbatim}
const int Queuesize=100;
／／100 是示例性数据
template <typename DataType>
class CirQueue
f
public:
    CirQueve() ;
//构造函数,初姶化空队列
    ~CirQueue();
    void Enqueue (DataType x); //人队操作,将元素x人队
    DataType Dequeue(); 1/出队操作,将队头元素出队
    DataType GetHead(); //取队头元素(并不舠除)
    int Empty(); //判断队列是否为空
private:
    DataType data[QueueSize]; //存放队列元素的数组
    int front, rear; //游标,队头和队尾指针
};
\end{verbatim}

根据队列的操作定义，容易写出循环队列基本操作的算法，其时间复杂度均为 $O(1)$ 。\\
（1）构造函数——循环队列的初始化\\
初始化一个空的循环队列只需将队头 front 和队尾 rear 同时指向数组的某一个位置，一般是数组的高端，即 rear $=$ front $=$ QueueSize -1 。\\
（2）析构函数——循环队列的销毁\\
循环队列是静态存储分配，在循环队列变量退出作用域时自动释放所占内存单元，因此，循环队列无须销毁，析构函数为空。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-094(2)}\\
（3）人队操作\\
循环队列的人队操作只需将队尾位置 rear 在循环意义下加 1 ，然后将待插元素 x 插人队尾位置，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void CirQueue<DataType> :: EnQueue (DataType x)
{
    if ((rear+1) & Queuesize == front) throw "上㮎";
\end{verbatim}

\begin{verbatim}
rear = (rear + 1) % QueueSize; //队尾指针在循环意义下加 1
data [rear] = x; 1/在队尾处插人元索
\end{verbatim}

)

\begin{verbatim}
（4）出队操作
循环队列的出队操作只需将队头位置 front 在循环意义下加 1 ，然后读取并返回队头元素，成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
DataType Cirqueue<DataType>:: Dequeue()\\
\{\\
if (rear == front) throw "下溢";\\
front = (front+1) \% QueueSize;//以头在循环意义下加1\\[0pt]
return data[front]: //返国出队前的队头元素\\
\}

\begin{verbatim}
（5）取队头元素
读取队头元素与出队操作类似，唯一的区别是不改变队头位置，成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
DataType Cirqueue<DataType> : : GetHead ()\\
l\\
if (rear == front) throw "下溢";\\[0pt]
return data[(front+1) \% QueueSize]; //注意不修改队为指针\\
\}

\begin{verbatim}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-095.jpg?height=235&width=238&top_left_y=1114&top_left_x=1411)

源代码
（6）判空操作
循环队列的判空操作只需判断 front 是否等于 rear。

\section*{4．循环队列的使用}

在定义了循环队列类 CirQueue 并实现了基本操作后，程序中就可以使用 CirQueue类来定义变量，可以调用实现基本操作的函数来完成相应功能。范例程序如下：
\end{verbatim}

using namespace std;\\
//将楿环限列的类定义和各个成员函数定义写到这里\\
int main()\\
(

\begin{verbatim}
int x;
Cirqueue<int> Q{ };
\end{verbatim}

try\\
$i$\\
$\mathrm{x}=$ Q. DeQueue () ;\\
cout <<"执行一次出队操作, 出队元素是: " <<x \textbackslash llendl; //输出出队元素 5\\
\} catch (char * str) loout <<str <<endl; )\\
try\\
1\\
cout \textbackslash ll 请输人人队元素: ";\\
cin $\gg x$;\\
Q. Enqueue (x) ;\\
\} catch(char * str) \{cout <<str <<endl; \}\\
if (Q. Empty ( ) == 1) cout <<"B人列为空" <<endl;\\
else cout <<"队列非空" <<endil; //队列有 2 个元素, 输出队列非空\\
return 0 ;

\begin{verbatim}

\section*{3．3．3 队列的链接存储结构及实现}

\section*{1．链队列的存储结构}

队列的链接存储结构称为链队列（linked queue），通常用单链表表示，其结点结构与单链表的结点结构相同，请参见2．4．1节。为了使空队列和非
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-096.jpg?height=307&width=246&top_left_y=1014&top_left_x=1287)空队列的操作一致，链队列也加上头结点。根据队列的先进先出特性，为了操作上的方便，设置队头指针指向链队列的头结点，队尾指针指向终端结点，如图 3－13 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-096.jpg?height=141&width=1011&top_left_y=1444&top_left_x=290)

图 3－13 链队列示意图

\section*{2．链队列的实现}

将队列的抽象数据类型定义在链队列存储结构下用 C＋＋中的类实现，下面给出链队列的类定义，其中成员变量 front 是队头指针，rear 是队尾指针，成员函数实现队列的基本操作。
\end{verbatim}

template <typename DataType>\\
class LinkQueue\\
public:\\
LinkQueue();／／初始化空的链队列

\begin{verbatim}

\end{verbatim}

\~{}LinkQueue();\\
//释放链队列的存储空间\\
源代码\\
void Enqueue(DataType x); //人操作,将元素 x 人队\\
DataType DeQueue(); //出队操作,将队头元素出队

\begin{verbatim}

\end{verbatim}

\begin{verbatim}
DataType GetHead();
int Empty();
\end{verbatim}

private:\\
Node<DataType> * front, * rear;\\
//取链队列的队头元素\\
//判断链队列是否为空\\
//队头和队尾指针\\
\};

\begin{verbatim}

链队列基本操作的实现本质上是单链表操作的简化，且时间复杂度均为 $O(1)$ 。
（1）构造函数——链队列的初始化
初始化链队列只需申请头结点，然后让队头指针和队尾指针均指向头结点，构造函数如下：
\end{verbatim}

template <typename DataType>\\
LinkQueue<DataType> :: LinkQueue()\\
\{\\
Node<DataType> * s = nuilptr;\\
s = new Node<DataType>; s->next = nullptr;\\
front = rear = s; //将队头指针和队尾指钨都指向头结点 s\\
)\\
（2）析构函数——链队列的销毁\\
链队列是动态存储分配，需要释放链队列的所有结点的存储空间。链队列类的析构函数与单链表类的析构函数类似，请读者自行设计。\\
（3）人队操作\\
链队列的插人操作只考虑在链表的尾部进行，由于链队列带头结点，空链队列和非空链队列的插人操作语句一致，其操作示意图如图 3－14 所示。成员函数定义如下：\\
template <typename DataType>\\
void IinkQueue<DataType> : :Enqueue (DataType x)\\
1\\
Node<DataType> * $s=$ nullptr;\\
$s=$ new Node<DataType>; //申请结点 $s$\\
$s->$ data $=x ; s->$ next $=$ nullptr $;$\\
rear $->$ next $=s$; rear $=s$; $\quad / /$ 将结点 $s$ 插人到队尾\\
1\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-097}\\
（a）空链队列的人队操作\\
（b）非空链队列的入队操作

图 3－14 链队列的人队操作（（1）rear $->$ next $=\mathrm{s}$ ；（2）rear $=\mathrm{s}$ ；）\\
在不带头结点的链队列中执行人队操作，在空链队列和非空链队列的操作语句是不

同的，如图 3－15 所示，所以，为了操作方便，链队列一般都带头结点。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-098(1)}

图 3－15 不带头结点的链队列执行人队操作\\
（（1）front $=\mathrm{s}$ ；（2）rear $=\mathrm{s}$ ；（1）rear $->$ next $=\mathrm{s}$ ；（2）rear $=\mathrm{s}$ ；）\\
（4）出队操作\\
链队列的删除操作只考虑在链表的头部进行，注意队列长度等于 1 的特殊情况，其操作示意图如图 3－16 所示，成员函数定义如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-098(2)}

图 3－16 链队列出队操作\\
（5）取队头元素\\
取链队列的队头元素只需返回第一个元素结点的数据域，即返回 front $\rightarrow$ next $\rightarrow$ data。\\
（6）判空操作\\
链队列的判空操作只需判断 front 是否等于 rear。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-098}

源代码

\section*{3．链队列的使用}
在定义了链队列类 LinkList 并实现了基本操作后，程序中就可以使用 LinkList 类来

定义变量，可以调用实现基本操作的函数来完成相应功能。范例程序如下：

\begin{verbatim}
# include <iostxeam>
\end{verbatim}

using namespace std;\\
//将单链表的结点结构定义、链队列类定义和希个成员函数定义放到这里\\
int main()\\
f\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-099}\\
int x ；\\
LinkQueue＜int＞Q\textbackslash ｛ \};\\
／／定义对象变量 Q\\
cout＜＜＂对 5 和 8 执行人队操作，＂；\\
Q．Enqueue（5）；Q．Enqueue（8）；\\
cout＜＜＂当前队头元素为：＂＜＜Q．GetQueue（）＜＜endl；\\
／／输出队头元素 5\\
try\\
1\\
$\mathrm{k}=\mathrm{Q}$ ．Dequeue（）；\\
cout＜＜＂执行一次出队操作，出队元素是：＂\textbackslash llx \textbackslash llendl；\\
\} catch (char *str) \{cout <<str <<endl; \}\\
try\\
1\\
cout＜＜＂请输人人队元素：＂；\\
cin＞＞x；\\
Q．Enqueue（ x ）；\\
f catch（char＊str）（cout＜＜str＜＜endl；）\\
if（Q．Empty（ ）＝＝1）cout＜＜＂队列为空＂＜＜end ；\\
else cout＜＜＂队列非空＂＜＜endl；／／以列有 2 个元素，输出队列非空\\
return 0 ；

\section*{3．3．4 循环队列和链队列的比较}
循环队列和链队列基本操作的时间复杂度均为 $O(1)$ ，因此，可以比较的只有空间性能。初始时循环队列必须确定一个固定的长度，所以有存储元素个数的限制和浪费空间的问题。链队列没有溢出的问题，只有当内存没有可用空间时才会出现溢出，但是每个元素都需要一个指针域，从而产生了结构性开销。作为一般规律，当队列中元素个数变化较大时，应该采用链队列，反之，应该采用循环队列，如果确定不会发生假溢出，也可以采用顺序队列。

\section*{3.4 扩展与提高}
\section*{3．4．1 两栈共享空间}
在一个程序中，如果同时使用具有相同数据类型的两个顺序栈，最直接的方法是为每

个栈开辟一个数组空间，这样做的结果可能出现一个栈的空间已被占满而无法再进行插人操作，同时另一个栈的空间仍有大量剩余而没有得到利用的情况，从而造成存储空间的浪费。可以充分利用顺序栈单向延伸的特性，使用一个数组来存储两个栈，让一个栈的栈底位于该数组的始端，另一个栈的栈底位于该数组的末端，每个栈从各自的端点向中间延伸，如图 3－17 所示。其中，top1 和 top2 分别为栈 1 和栈 2 的栈顶位置，StackSize 为整个数组空间的大小，栈 1 。的底位于下标为 0 的一端；栈 2 的底位于下标为 Stack Size－1 的一端。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-100}

图 3－17 两栈共享空间示意图\\
在两栈共享空间中，由于两个栈相向增长，浪费的数组空间就会减少，同时发生上溢的概率也会减少。但是，只有当两个栈的空间需求有相反的关系时，这种方法才会奏效，也就是说，最好一个栈增长时另一个栈缩短。下面给出两栈共享空间的类定义：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-100(1)}

设整型变量 i 只取 1 和 2 两个值。当 $\mathrm{i}=1$ 时，表示对栈 1 操作；当 $\mathrm{i}=2$ 时表示对栈 2操作。下面讨论两栈共享空间的人栈和出栈操作。\\
（1）人栈操作\\
当存储栈的数组中没有空闲单元时为栈满，此时栈 1 的栈顶元素和栈 2 的栈顶元素位于数组中的相邻位置，即 top $1=\mathrm{top} 2-1$（或 top $2=\mathrm{top} 1+1$ ）。另外，当新元素插人栈 2时，栈顶位置 top 2 不是加 1 而是减 1 。成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void BothStack<DataType>:: Push (int i, DataType x)
\end{verbatim}

\begin{verbatim}
l
    if (top1 == top2 - 1) throw "上溢"; //判断是否栈满
    if (i = = 1) data [t+top1] = x; //在栈 1 插人
    if (i = = 2) data [--top2] = x; //在栈 2 挿人
l
\end{verbatim}

（2）出栈操作\\
当 top $1=-1$ 时栈 1 为空，当 top $2=$ Stack Size 时栈 2 为空。另外，当从栈 2 删除元素时，栈顶位置 top2 不是减 1 而是加 1 。成员函数定义如下：

\begin{verbatim}
template <typename DataType>
DataType BothStack<DataType>:: Pop(int i)
d
    if (i == 1) ( / 在栈 1 删除
        if (top1 = = -1) throw "下溢"; //判断栈1是否为空
        return data[top1--];
    }
    if (i = = 2) ( // 在栈 2 刪除
        if(top2 == StackSize) throw "下溢"; //判断栈 2 是否为空
        return data[top2t+];
    }
}
\end{verbatim}

\section*{3．4．2 歼端队列}
双端队列（double－ended queue）是队列的扩展，如图 3－18 所示。如果允许在队列的两端进行插人和删除操作，则称为双端队列；如果允许在两端插入但只允许在一端删除，则称为二进一出队列；如果只允许在一端插人但允许在两端删除，则称为一进二出队列。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-101}

图 3－18 双端队列的示意图\\
双端队列和普通队列一样，具有人队、出队、取队头元素等基本操作，不同的是必须指明操作的位置，其抽象数据类型定义如下：

\begin{verbatim}
ADT DoubleQuelle
DataMode1
    相邻元素具有前驱和后继关系,允许在队列的两端进行揇入和删除操作
Operation
    Initqueue
        输入:无
\end{verbatim}

\begin{verbatim}
        功能:初始化双端队列
        输出:一个空的双端队列
    DestroyQueue
        输人:无
        功能:队列的销毁
        输出:释放双端队列占用的存储空间
EnqueueHead
    输人:元素值 x
    功能:人操作,将元素 x 插人到双端队列的队头
    输出:如果插人成功,双端队列的队头增加了一个元素
EnqueueTail
    输人:元素值 x
    功能:人队操作,将元素 x 插人到双端队列的队尾
    输出:如果插人成功,双端队列的队尾增加了一个元素
DeQueueHead
    输人:无
    功能:出队操作,删除双端队列的队头元素
    输出:如果删除成功,将队头元素出队
DeQueueTail
    输人:无
    功能:出队操作,删除双端队列的队尾元素
    输出:如果删除成功,将队尾元素出队
GetHead
    输人:无
    功能:读取双端队列的队头元素
    输出:若双端队列不空,返回队头元素
GetTail
    输人:无
    功能:读取双端队列的队尾元素
    输出:若双端队列不空,返回队尾元素
Empty
    输人:无
    功能:判空操作,判断双端队列是否为空
    输出:如果双端队列为空,返回1,否则返回0
endADT
\end{verbatim}

双端队列可以采用循环队列的存储方式，基本算法可以在循环队列的基础上修改而成。不同的是，在队头人队时，先将新元素插人到 front 处，再把队头位置 front 在循环意义下减 1 ；在队尾出队时，先将 rear 处的队尾元素暂存，再把队尾位置 rear 在循环意义下减1。具体算法请读者自行设计。

\section*{3.5 应 用 举 例}
\section*{3．5．1 括号匹配问题}
在本章的引言部分给出了括号匹配问题，下面讨论算法设计和程序实现。

【算法】设函数 Match 实现括号匹配，算法用伪代码描述如下：

算法：Match（str）\\
输入：以字符串 str存储的算术表达式\\
输出：匹配结果， 0 表示匹配， 1 表示多左括号，-1 表示多右括号\\
1．栈 $S$ 初始化；\\
2．循环变量 i 从 0 开始依次读取 $\mathrm{str}[\mathrm{i}]$ ，直到字符串 str 结束：\\
2.1 如果 str［i］等于＇＇＇，则将＇＇＇压人栈 s；\\
2.2 如果 str［i］等于＇）＇，且栈 S 非空，则从栈 S 中弹出一个＇（＇与＇）＇匹配；如果栈 $S$ 为空，则多右括号，输出 -1 ；\\
3．如果栈 $S$ 为空，则左右括号匹配，输出 0 ；否则说明多左括号，输出 1 ；\\
【程序】将函数 Match 定义为类 Matcher 的成员函数，类 Matcher 的成员变量 str存储表达式。主函数首先接收键盘输人的算术表达式，然后定义对象变量 M ，再调用函数 Match 进行括号匹配。程序如下：

\begin{verbatim}
# include <iostream>
#include <string>
using namespace std;
class Matcher{
public:
    Matcher (string str) ;
    ~Matcher () ;
    int Match();
private:
    string str;
} :
Matcher : : Matcher(string str)
f
    this->str = str;
}
Matcher : : ~Matcher ()
{
)
int Matcher : : Match ()
{
    char S[];
//定义顺序栈 S
    int i, top = -1;
//顺序栈 S 的栈顶指针 top 初始化
    for (i = 0; stx [i] := ' \ 0'; i + +)
    i
        if (stx [i] = ')') (当前扫描的字符是有括号
            if (top>-1) top--;
//依次对 str [1]进行处理
    //出栈前籼断栈是否为空
\end{verbatim}

\begin{verbatim}
        else return -1;
    }
    else if (str[i] = = '(') //当前扫描的字符是左括号
        s[++top] = str[i];
)
if (top = = -1) return 0; //栈空则括号正确园配
else return 1;
int main()
{
    string str;
    cout <<"请输人一个算术表达式:";
    cin>>str;
    Matcher M(str);
    int k = M.Match():
    if (k = = 0)
        cout <<"正确兆配\n";
    else if (k== 1)
        cout <<"多左括号\n";
    else
        cout <<"多右括号\n";
    return 0;
\end{verbatim}

\section*{3．5．2 表达式求值}
【问题】表达式求值是编译程序的一个基本问题。设运算符有 + 、 - 、 $*$ 、 $\downarrow$ 井和圆括号，其中 \textbackslash ＃为表达式的定界符，对于任意给定的表达式进行求值运算，给出求值结果。

【想法】表达式求值需要根据运算符的优先级来确定计算顺序。因此，在求值过程中需要保存优先级较低的运算符以及没有参与计算的运算对象，并将当前运算符与已经扫描过的、尚未计算的运算符进行比较，以确定哪个运算符以及哪两个运算对象参与计算。这需要两个栈来辅助完成：运算对象栈 OPND 和运算符栈 OPTR。例如，表达式 $(4+2) * 3-5$ 的求值过程如表 3－1 所示。

表 3－1 表达式的求值过程

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
当前字符 & 运算对象栈 OPND & 运算符栈 OPTR & 说 明 \\
\hline
 &  & \textbackslash ＃ & 初始化 \\
\hline
（ &  & \textbackslash ＃，（ & （的优先级比\textbackslash ＃高，（人桟 OPTR \\
\hline
4 & 4 & \textbackslash ＃，（ & 4 人栈 OPND \\
\hline
＋ & 4 & \textbackslash ＃，（，＋ & ＋的优先级比（高，＋人桟 OPTR \\
\hline
\end{tabular}
\end{center}

续表

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
当前字符 & 运算对象機 OPND & 运算符桟 OPTR & 说 明 \\
\hline
2 & 4， 2 & \textbackslash ＃，（，＋ & 2 人栈 OPND \\
\hline
） & 6 & \textbackslash ＃，（ & ）的优先级比 + 低， 2 和 4 出栈，+ 出栈，执行 + 运算并将结果 6 人桟 OPND \\
\hline
） & 6 & \textbackslash ＃ & ）的优先级与（相同，括号匹配，（出栈 \\
\hline
＊ & 6 & \textbackslash ＃，＊ & ＊的优先级比\textbackslash ＃高，＊人桟 OPTR \\
\hline
3 & 6， 3 & \textbackslash ＃，＊ & 3 人栈 OPND \\
\hline
－ & 18 & \textbackslash ＃ & 一的优先级比 $*$ 低， 3 和 6 出栈，＊出栈，执行＊运算并将结果 18人栈 OPND \\
\hline
－ & 18 & \textbackslash ＃，－ & 一的优先级比井高，一人桟 OPTR \\
\hline
5 & 18，5． & \textbackslash ＃，－ & 5 人栈 OPND \\
\hline
\textbackslash ＃ & 13 & \textbackslash ＃ & \textbackslash ＃的优先级比一低， 5 和 18 出栈，一出栈，执行一运算并将结果 13入栈 OPND \\
\hline
\textbackslash ＃ & 13 & \textbackslash ＃ & \textbackslash ＃的优先级与井相同，求值结束，栈 OPND 的栈顶元素即为运算结果 \\
\hline
\end{tabular}
\end{center}

【算法】设函数 Compute 实现表达式求值，简单起见，假设运算对象均为一位十进制数，且表达式不存在语法错误，算法用伪代码描述如下：

算法：Compute（str）\\
输人：以字符串 str存储的算术表达式\\
输出：该表达式的值\\
1．将栈 OPND 初始化为空，将栈 OPTR 初始化为表达式的定界符\textbackslash ＃；\\
2．从左至右扫描表达式的每一个字符执行下述操作：\\
2.1 若当前字符是运算对象，则人栈 OPND；\\
2.2 若当前字符是运算符且优先级比栈 OPTR 的栈顶运算符的优先级高，则人栈 OPTR，处理下一个字符；\\
2.3 若当前字符是运算符且优先级比栈 OPTR 的栈顶运算符的优先级低，则从栈 OPND出栈两个运算对象，从栈 OPTR 出栈一个运算符进行运算，并将运算结果人栈 OPND，继续处理当前字符；\\
2.4 若当前字符是运算符且优先级与栈 OPTR 的栈顶运算符的优先级相同，则将栈 OPTR 的栈顶运算符出栈，处理下一个字符；\\
3．输出栈 OPND 中的栈顶元素，即表达式的运算结果；

【程序】 将函数 Compute 定义为类 Expression 的成员函数，类 Expression 的成员变量 str 存储表达式，成员函数 Comp 比较当前扫描到的运算符和运算符栈 OPTR 的栈顶元素的优先级。主函数首先接收从键盘输人的表达式，然后定义对象变量 E ，构造函数将该表达式加上定界符＇\textbackslash ＃＇，再调用函数 Compute 计算表达式的值。程序如下：

\begin{verbatim}
# include <iostream>
#include <string>
using namespace std;
class Expression
{
public:
    Expression(string str);
    ~ Expression();
    int Compute();
private:
    int Comp(char str1, char str2);
    string str;
);
Expression :: Expression(string str) //接收键盘输人并加上定界符
{
    this->str = str + "#";
}
Expression :: ~ Expression()
{
)
int Expression :: Compute()
{
    char OPND[100], OPTR[100];
    OPTR[0] = '#';
    int top1 = -1, top2 = 0;
    int i, k, x, y, z, op;
    for (i = 0; str[i] != '\0'; ) //依次扫描每一个字符
    f
        if (str[i] >= 48 && str[i] <= 57) //数字 0 的 ASCII 码是 48
            OPND[++top1] = str [i++] - 48; //将字符转换为数字压栈
        else {
            k = Comp(str[i], OPTR[top2]);
            if (k = = 1) //str[i]的优先级高
                OPTR[++top2] = str [i++];
            else if (k == -1)
            |
                y= OPND[top1--]; ||以运算对象栈出栈两个元素
                x = OPND[top1--];
                op = OPTR[top2--]; //从运算符栈出栈一个元素
                switch (op)
\end{verbatim}

\begin{verbatim}
1／定义两个顺序栈
／／栈 OPTR 初始化为定界符
／／初始化栈 OPND 和 OPTR
//比较 str1和 str2的优先级
\end{verbatim}

\begin{verbatim}
接收键盘输人并加上定界条
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-106}
\end{center}

\begin{verbatim}
／／构造函数
／／析构函数
／／计算表达式 str的值
Expression :: Expression(string str)
\end{verbatim}

\begin{verbatim}
将字符转换为数字压栈
                    case '+': z=x+y; break;
                    case '-': z = x - y; break;
                    case '* ':z =x * y; break;
                    case '//':z =x/y; break;
\end{verbatim}

\begin{verbatim}
            default: break;
        }
    OPND[++top1] = 2; //运算结果人运算对象栈
}
else{ //stx[i]与运算符栈的栈顶元察优先级相同
    top2--;
    i++;
}
}
)
return OPND[top1]; //运算对象栈的栈顶元素即为运算结果
}
int Expression :: Comp(char str1, char str2)
{ / /比较 str1 利 str2的优先级,1 表示 str1 高; 0 表示相同;-1 表示 str1 低
    switch (str1)
    {
        case '+': case ' -' : if (str2='(' || str2= ' #') return 1;
            else return -1;
            break;
        case '*':case'/':if (str2=='*'|| str2=='/') return -1;
            else return 1;
            break;
        case '(': return 1; break;
        case ')': if (str2='(') return 0; e1se return -1;
            break:
        case '#': if (str2=='#') return 0; else return -1;
            break:
        default: break:
int main()
{
    string str;
    cout <<"请输人一个表达式:"<<endl;
    cin>>st工:
    Expression E{str}; //定义对象变量 E
    int result = E.Compute(): //result保存计算结果
    cout <<"表达式的值是;"<<result<<endl;
    return 0;
)
\end{verbatim}

\section*{思想火花——好程序要能识别和处理各种输入}
计算机程序作为一种思维产品和其他工程产品相比，有着很多不同的特性，几乎所有的程序在特定条件下都会有意想不到的行为。1989 年，北美经历了一场令人难以忘记的

通信大灾难，AT\textbackslash ＆T电话系统的瘫痪致使北美的商务出现停滞并引发了各种骚乱。\\
AT\textbackslash ＆T电话中心的目击者看到了令人吃惊的一幕。巨大的北美电子地图（就像电影中看到的战争指挥室），显示了整个大陆各个结点上电话流量的状态。起初，一个结点熄灭了，几秒钟后，另一个结点也熄灭了，在几分钟内，就像链条反应一样，一个结点接一个结点地熄灭了，整个北美的长途电话网瘫痪了。人们首先想到的是对系统重新启动，但没有人能确切地知道该如何做，因为这个复杂的系统已经运行很多年了，从来就没有真正重新启动过，这也意味着它以前从未熄灭过，自然也就没有人能确切地知道该如何重新启动它。最后技术人员发现问题出在 100 万行代码中的一条错误语句上，一个函数接收了一个错误的参数。

有人可能会认为问题在于这个＂错误的值＂，但事实上，无法保证一个程序永远不会遇到一个错误的值。因此，好的程序应该尽可能识别和处理各种输人，至少应该防止这样的错误引起致命的后果。

\section*{习 题 3}
\section*{1．选择题}
（1）一个栈的人栈序列是 $1,2,3,4,5$ ，则栈的不可能的输出序列是（ ）。\\
A． 54321\\
B． 45321\\
C． 43512\\
D． 12345\\
（2）若一个栈的输人序列是 $1,2,3, \cdots, n$ ，输出序列的第一个元素是 $n$ ，则第 $i$ 个输出元素是（ ）。\\
A．不确定\\
B．$n-i$\\
C．$n-i-1$\\
D．$n-i+1$\\
（3）若一个栈的输人序列是 $1,2,3, \cdots, n$ ，其输出序列是 $p_{1}, p_{2}, \cdots, p_{n}$ ，若 $p_{1}=3$ ，则 $p_{2}$ 的值（）。\\
A．一定是 2\\
B．一定是 1\\
C．不可能是 1\\
D．以上都不对\\
（4）设计一个判别表达式中左右括号是否配对的算法，采用（ ）数据结构最佳。\\
A．顺序表\\
B．栈\\
C．队列\\
D．链表\\
（5）当字符序列 t3＿依次通过栈，输出长度为 3 且可用作 $C$ 语言标识符的序列有（）。\\
A． 4 个\\
B． 5 个\\
C． 3 个\\
D． 6 个\\
（6）从栈顶指针为 top 的链栈中删除一个结点，用 x 保存被删除结点的值，则执行（）。\\
A．$x=t o p$ ；top $=t o p->$ next；\\
B．$x=$ top $->$ data；\\
C．top $=$ top $->$ next $; \mathrm{x}=$ top $->$ data；\\
D．$x=$ top $->$ data；top $=$ top $->$ next；\\
（7）在解决计算机主机与打印机之间速度不匹配问题时通常设置一个打印缓冲区，该缓冲区应该是一个（ ）结构。\\
A．栈\\
B．队列\\
C．数组\\
D．线性表\\
（8）一个队列的人队顺序是 $1,2,3$ 和 4 ，则队列的输出顺序是（ ）。\\
A． 4321\\
B． 1234\\
C． 1432\\
D． 3241\\
（9）栈和队的主要区别在于（ ）。\\
A．它们的逻辑结构不一样\\
B．它们的存储结构不一样\\
C．所包含的运算不一样\\
D．插人、删除运算的限定不一样\\
（10）设数组 $S[n]$ 作为两个栈 $S 1$ 和 $S 2$ 的存储空间，对任何一个栈只有当 $S[n]$ 全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（ ）。

A．S1 的栈底位置为 $0, \mathrm{~S} 2$ 的栈底位置为 $\mathrm{n}-1$\\
B．S1 的栈底位置为 $0, \mathrm{~S} 2$ 的栈底位置为 $\mathrm{n} / 2$\\
C．S1 的栈底位置为 $0, \mathrm{~S} 2$ 的栈底位置为 n\\
D．S1 的栈底位置为 $0, \mathrm{~S} 2$ 的栈底位置为 1\\
（11）设栈 $S$ 和队列 $Q$ 的初始状态为空，元素 e1、e2、e3、e4、e5、e6 依次通过栈 $S$ ，一个元素出栈后即进人队列 Q ，若 6 个元素出列的顺序是 e2、e4、e3、e6、e5、e1，则栈 S 的容量至少应该是（ ）。\\
A． 6\\
B． 4\\
C． 3\\
D． 2\\
（12）表达式 $3 * 2^{\wedge}(4+2 * 2-6 * 3)-5$ 求值过程中当扫描到 6 时，对象栈和算符栈为（ ），其中 ${ }^{\wedge}$ 表示乘幂。\\
A． $3,2,4,1,1 ; \#^{*}(+*-$\\
B． $3,2,8$ ；\textbackslash ＃＊${ }^{\wedge}-$\\
C． $3,2,4,2,2 ; \#^{*}(-$\\
D． $3,2,8$ ；\textbackslash ＃＊${ }^{\wedge}(-$

\section*{2．解答下列问题}
（1）设有一个栈，元素进栈的次序为 $A 、 B 、 C 、 D$ 和 $E$ ，能否得到如下出栈序列？若能，请写出操作序列；若不能，请说明原因。\\
（1） $\mathrm{C} 、 \mathrm{E} 、 \mathrm{~A} 、 \mathrm{~B} 、 \mathrm{D}$\\
（2） $\mathrm{C} 、 \mathrm{~B} 、 \mathrm{~A} 、 \mathrm{D} 、 \mathrm{E}$\\
（2）在操作序列 push（1）、push（2）、pop、push（5）、push（7）、pop、push（6）之后，栈顶元素和栈底元素分别是什么？（push（k）表示整数 k 人栈，pop 表示栈项元素出栈。）\\
（3）在操作序列 EnQueue（1）、EnQueue（3）、DeQueue、EnQueue（5）、EnQueue（7）、 DeQueue、EnQueue（9）之后，队头元素和队尾元素分别是什么？（EnQueue（k）表示整数 k 人队，DeQueue 表示队头元素出队）。\\
（4）假设以 I 和 O 分别表示人栈和出栈操作，栈的初态和终态均为空，人栈和出栈的操作序列可表示为仅由 I 和 O 组成的序列，称可以操作的序列为合法序列，否则称为非法序列。下面序列中哪些是合法的？为什么？\\
（1） IOIIOIOO ；\\
（2）IOOIOIIO；\\
（3） IIIOIOIO ；\\
（4） IIIOOIOO

\section*{3．算法设计}
（1）假设以不带头结点的循环链表表示队列，并且只设一个指针指向队尾结点，但不设头指针。试设计相应的人队和出队的算法。\\
（2）设顺序栈 S 中有 2 n 个元素，从栈顶到栈底的元素依次为 $a_{2 n}, a_{2 n-1}, \cdots, a_{1}$ ，要求通过一个循环队列重新排列栈中元素，使得从栈顶到栈底的元素依次为 $a_{2 n}, a_{2 n-2}, \cdots, a_{2}$ ， $a_{2 n-1}, a_{2 n-3}, \cdots, a_{1}$ ，请设计算法实现该操作，要求空间复杂度和时间复杂度均为 $O(n)$ 。\\
（3）设计算法，把十进制整数转换为二至九进制之间的任一进制输出。\\
（4）在循环队列中设置一个标志 flag，当 front $=$ rear 且 flag $=0$ 时为队空，当 front $=$ rear 且 flag $=1$ 时为队满。编写相应的人队和出队算法。

\section*{实 验 题 3}
【实验 1】请上机实现 3．2．2 节顺序栈的使用范例和 3．3．2 节循环队列的使用范例，并用不同的栈和队列实例进行测试。

【实验 2】后缀表达式。运算符在两个运算对象的中间（如 $4+2$ ）称为中缀表达式；运算符在两个运算对象的后面（如 $42+$ ）称为后缀表达式，也称逆波兰式 ${ }^{(1)}$（reverse Polish notation）。例如，中缀表达式 $(4+2) * 3-5$ 对应的后缀表达式为 $42+3 * 5$一。对算术表达式的后缀形式仅做一次扫描即可得到表达式的运算结果，而无须考虑优先级和括号等因素。因此，很多编译程序在对表达式进行语法检查的同时，将其转换为对应的后缀形式。将一个中缀表达式转换为对应的后缀表达式只需用一个栈存放运算符，中缀表达式 $(4+2) * 3-5$ 转换对应的后缀表达式的过程如表 3－2 所示。设计算法实现将中缀表达式转换为对应的后缀表达式。

表 3－2 中缀表达式转换为后缀表达式的过程

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
当前字符 & 后缧表达式 & 桟 OPTR & 说 明 \\
\hline
 &  & \textbackslash ＃ & 初始化 \\
\hline
（ &  & \textbackslash ＃，（ & （的优先级比\textbackslash ＃高，（人桟 \\
\hline
4 & 4 & \textbackslash ＃，（ & 输出 4 \\
\hline
＋ & 4 & \textbackslash ＃，（，＋ & ＋的优先级比（高，＋人桟 \\
\hline
2 & 42 & \textbackslash ＃，（，＋ & 输出2 \\
\hline
） & $42+$ & \textbackslash ＃，（ & ）的优先级比 + 低，+ 出桟并输出 \\
\hline
） & 4 2＋ & \textbackslash ＃ & ）的优先级与（相同，括号匹配，（出桟 \\
\hline
＊ & $42+$ & \textbackslash ＃，＊ & ＊的优先级比\textbackslash ＃高，＊人桟 \\
\hline
3 & $42+3$ & \textbackslash ＃，＊ & 输出3 \\
\hline
－ & $42+3 *$ & \textbackslash ＃ & 一的优先级比＊低，＊出栈并输出 \\
\hline
－ & $42+3$＊ & \textbackslash ＃，一 & －的优先级比\textbackslash ＃高，－人桟 \\
\hline
5 & $42+3 * 5$ & \textbackslash ＃，－ & 输出5 \\
\hline
\textbackslash ＃ & $42+3 * 5-$ & \textbackslash ＃ & \textbackslash ＃的优先级比一低，一出桟并输出 \\
\hline
\textbackslash ＃ & $42+3 * 5-$ & \textbackslash ＃ & \textbackslash ＃的优先级与\textbackslash ＃相同，转换结束 \\
\hline
\end{tabular}
\end{center}

【实验 3】迷宫问题。迷宫问题的求解是实验心理学中的一个经典问题。心理学家把一只老鼠从一个无顶盖的大盒子的人口处赶进迷宫。迷宫中设置很多隔板，对前进方向形成了多处障碍。心理学家在迷宫的唯一出口处放置了一块奶酪，吸引老鼠在迷宫中寻找通路以到达出口。设计算法实现迷宫求解。

\footnotetext{（1） 1929 年波兰数学家提出一种前涹表示法，可以不用考虑算符的优先级而直接计算。例如， $3+4 \times 2$ 的前缀表达式是 $+3 \times 42$ ，从前向后扫描遇到运算符就与随后的两个操作数进行计算。为了便于计算机处理，避免重复扫描表达式，提出了后缨表达式，也称逆波兰式。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(2)}\\
－your－\\
呵啨三

\section*{\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-111(19)}
\end{center}}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-111(18)} $\qquad$\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-111(5)} － ．\\
your as a propy so\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(16)}\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(14)}\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-111(10)} $\qquad$ 7 $\qquad$ 11\\
$\qquad$\\
$\qquad$\\
$\qquad$ 1\\
$\qquad$\\
$\qquad$ 11，＂䨟 で米\\
$\qquad$\\
$\qquad$ 1，4\\
$\qquad$ $=$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111}\\
$\qquad$ $=$\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-111(21)} ＂ $\qquad$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(3)}\\
$\qquad$ $=$\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-111(8)} ｜｜日 $\qquad$\\
$\qquad$ － 2 － $\qquad$\\
$\qquad$\\
$\qquad$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(6)}\\
반

\begin{verbatim}
i
\end{verbatim}

\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(20)}\\
-\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(9)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(12)}\\
낭\\
110-75-25-57\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(17)}\\
v\\
", 青\\
2-30.2pose\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(11)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(7)}\\
|\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(1)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(4)}\\
$\square$\\
$\qquad$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(15)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-111(13)}\\
$\qquad$ －3－1 ＂ $\square$

\section*{普通高校本科计算机专业 特 色 教 材 精 选}
\section*{4항}
\section*{字符串和多维数组}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
本章概述 & \multicolumn{5}{|c|}{\begin{tabular}{l}
字符串（简称＂串＂）是以字符作为数据元素的线性表。字符串是重要的非数值处理对象，在事务处理程序中，顾客的姓名、货物的产地等，一般都是作为字符串处理的。在文字编辑、词法扫描、符号处理及定理证明等许多领域，字符串也得到了广泛应用。因而在程序设计语言中大都有串变量的概念，而且实现了基本的串操作。本章由实际问题引出字符串，介绍串的逻辑结构和操作特点，重点讨论串的模式匹配算法。 \\
数组作为一种数据结构，其特点是数据元素本身可以具有某种结构，但属于同一数据类型。数组是线性表的推广，例如，二维数组可以看作数据元素是线性表的线性表。在程序设计语言中大都提供了数组作为构造数据类型，本章由实际问题引出数组，介绍数组的逻辑结构、操作特点和存储结构，重点讨论矩阵的压缩存储和寻址。 \\
\end{tabular}} \\
\hline
教学重点 & \multicolumn{5}{|l|}{串的模式匹配算法；数组的寻址方法；特殊矩阵的压缩存储和寻址方法} \\
\hline
教学难点 & \multicolumn{5}{|l|}{KMP 算法；稀疏矩阵的压缩存储} \\
\hline
\multirow{10}{*}{教学内容和教学目标} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教 学 要 求} \\
\hline
 &  & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline
 & 字符串的逻辑结构 &  &  & $\checkmark$ &  \\
\hline
 & 字符串的存储结构 &  & $\checkmark$ &  &  \\
\hline
 & 模式匹配 BF 算法 &  &  & $\checkmark$ &  \\
\hline
 & 模式匹配 KMP 算法 &  & $\checkmark$ &  &  \\
\hline
 & 数组的逻辑结构 &  &  & $\checkmark$ &  \\
\hline
 & 数组的存储结构及其寻址 &  &  &  & $\checkmark$ \\
\hline
 & 特殊矩阵的压缩存储 &  &  & $\checkmark$ &  \\
\hline
 & 稀疏矩阵的压缩存储 &  & $\checkmark$ &  &  \\
\hline
\end{tabular}
\end{center}

\section*{4.1 引言}
【例 4－1】发纸牌。假设纸牌的花色有梅花、方块、红桃和黑桃，纸牌的点数有 $2 、 3 、 4 、 5 、 6 、 7 、 8 、 9 、 10 、 J 、 Q 、 K 、 A$ ，要求根据用户输入的纸牌张数 $n$ ，随机发 $n$ 张纸牌。

【想法——数据模型】在发纸牌问题的求解过程中，计算机如何保存纸牌的花色和点数呢？可用二维数组 sign［4］［13］表示某张牌的状态，\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-113}

电子课件其中行下标表示花色，列下标表示点数。在字符界面的交互环境下，如何表示和输出随机选中的 $n$ 张纸牌呢？可用字符申数组 $\operatorname{card}[\mathrm{n}]$ 存储随机发的 $n$ 张纸牌，例如 card $[0]=$＂梅花 2 ＂，在字符界面直接输出相应的字符串，如图 4－1 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-113(1)}

图 4－1 用字符串方式表示的纸牌\\
【例 4－2】 八皇后问题是数学家高斯于 1850 年提出的，问题是：在 8 $\times 8$ 的棋盘上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

【想法——数据模型】 八皇后问题首先要解决的问题就是如何表示棋盘？如何获得每个皇后的位置信息进而判断是否互相攻击？由于棋盘\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-113(3)}的每一行可以并且必须摆放一个皇后，可以用向量 $\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ 表示 $n$ 皇后问题的解，即第 $i$ 个皇后摆放在第 $i$ 行第 $x_{i}$ 列的位置（ $1 \leqslant i \leqslant n$ 且 $1 \leqslant x_{i} \leqslant n$ ）。由于两个皇后不能位于同一列，所以，$n$ 皇后问题的解向量必须满足约束条件 $x_{i} \neq x_{j}$ 。

可以将 $n$ 皇后问题的 $n \times n$ 棋盘看成是矩阵，设皇后 $i$ 和皇后 $j$ 的撰放位置分别是 $\left(i, x_{i}\right)$ 和 $\left(j, x_{j}\right)$ ，则在棋盘上斜率为 -1 的同一条斜线上，满足条件 $i-x_{i}=j-x_{j}$ ，如图 4－2（a）所示；在棋盘上斜率为 1 的同一条斜线上，满足条件 $i+x_{i}=j+x_{j}$ ，如图 4－2（b）所示。综合上述两种情况，$n$ 皇后问题的解必须满足约束条件：$|i-j| \neq\left|x_{i}-x_{j}\right|$ 。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-113(2)}

图 4－2 不在同一斜线上的约束条件

\section*{4.2 字 符 串}
\section*{4．2．1 字符串的逻辑结构}
\section*{1．字符串的定义}
字符串（string，简称＂串＂）是 $n(n \geqslant 0)$ 个字符组成的有限序列，串中所包含的字符个数称为串的长度，通常记作：

$$
S=" s_{1} s_{2} \cdots s_{n} "
$$

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-114}
\end{center}

其中，$S$ 是串名，双引号是定界符，不属于串的内容，双引号引起来的部分是串值，$s_{i}(1 \leqslant$ $i \leqslant n)$ 是一个任意字符，$s_{i}$ 在串中出现的序号称为该字符在串中的位置。

长度为 0 的串称为空串，记作＂＂，空串中不包含任何字符。由一个或多个空格组成的串称为空格串，其长度是串中包含的空格数。显然，在统计字符串的长度时需要包含其中的空格，例如，＂primary string＂的长度是 14 。

字符串中任意个连续的字符组成的子序列称为该串的子串（substring），相应地，包含子串的串称为主串（primary string）。子串的第一个字符在主串中的序号称为子串在主串中的位置（location）。例如，子串＂str＂在主串＂primary string＂中的位置是9。

计算机系统能够表示的所有字符构成系统字符集，常用的标准字符集有ASCII ${ }^{(1)}$ 和 Unicode 等。字符集中的每个字符都有一个唯一的数值表示——称为字符编码，字符间的大小关系就定义为对应字符编码之间的大小关系。例如，字符 $a$ 和字符 $b$ 的 ASCII 码分别为 97 和 98 ，则＂$a$＂$<$＂$b$＂。给定两个字符串：$X=" x_{1} x_{2} \cdots x_{n} ", Y=" y_{1} y_{2} \cdots y_{m n} "$ ，则当 $n=m$ 且 $x_{1}=y_{1}, \cdots, x_{n}=y_{m}$ 时，称 $X=Y$ ；当下列条件之一成立时，称 $X<Y$ ：\\
（1）$n<m$ ，且 $x_{i}=y_{i}(i=1,2, \cdots, n)$ ；\\
（2）存在某个 $k \leqslant \min (m, n)$ ，使得 $x_{i}=y_{i}(i=1,2, \cdots, k-1), x_{k}<y_{k}$ 。\\
例如：＂abcd＂＝＂abcd＂，＂abc＂＜＂abcd＂，＂abac＂＜＂abaec＂，＂aba fg＂＜＂abc＂。

\section*{2．字符串的抽象数据类型定义}
字符串的逻辑结构与线性表的逻辑结构相同，但字符串的基本操作和线性表的基本操作有很大差别。线性表的基本操作大多以＂单个元素＂作为操作对象，例如，在线性表中查找某个元素、在某个位置插人一个元素或删除一个元素等；而字符串的基本操作通常以 ＂字符串整体＂作为操作对象，例如，在字符串中查找某个子串、在字符串的某个位置插人一个串以及删除一个子串等。下面给出字符串的抽象数据类型定义。

\footnotetext{（1）鲍勃•贝莫（Bob Bemer，1920年出生）首先认识到标准信息编码的重要性，也是世界上最早提出千年虫问趣的人。1960年，Bemer 发布了关于 60 多种计算机编码的调查报告，从而说明了对标准编码的需要。2003年5月， Bemer 荣获 IEEE－CS 颁发的计算机先驱奖，以表彰他＂通过 ASCII 和转义符为满足世界对各种字符集和符号的需要＂所做出的贡献。
}\begin{verbatim}
ADI String
DataModel
    串中的数据元素仅由一个字符组成, 相邻元素具有前驱和后继关系
Operation
    StrAssign
        输人: 串 $S$, 串 $T$
        功能: 串赋值, 将 T 的串值赋值给串 S
        输出: 串 S
    Strlength
        输人: 串 S
        功能: 求申 S 的长度
        输出: 串 $S$ 中的字符个数
    Strcat
        输人: 中 $S$, 串 $T$
        功能: 串连接, 将串 T 放在串 S 的后面连接成一个新串 S
        输出: 连接之后的串 S
    StrSub
        输入: 串 $S$, 位置 $i$, 长度 1 en
        功能: 求子串, 返回从串 $S$ 的第 $i$ 个字符开始长为 1 en 的子串
        输出: S 的一个子串
    Strcmp
        输人: 串 $S$, 串 $T$
        功能: 串比较
        输出: 若 $S=T$, 返回 0 ; 若 $S<T$, 返回 -1 ; 若 $S>T$, 返回 1
    StrIndex
        输人: 串 $S$, 串 $T$
        功能: 子串定位
        输出: 子串 I 在主串 S 中首次出现的位置
    StrInsert
        输人: 串 $S$, 串 $T$, 位置 $i$
        功能: 串插人, 将串 T 插人到串 S 的第 i 个位置上
        输出: 插人之后的串 S
    StrDelete
        输人: 串 S , 位置 i , 长度 len
        功能: 串删除, 删除中 $S$ 中从第 $i$ 个字符开始连续 Ien 个字符
        输出: 删除之后的串 $S$
endADI
\end{verbatim}

由于字符串广泛应用在非数值处理领域，因此，程序设计语言大都有串变量的概念并实现了字符串的基本操作。例如，在 C＋＋语言的 cstring 头文件中包含求字符串长度函数 length、字符串复制函数 copy、字符串比较函数 compare 以及字符串查找函数 substr，用户只需在程序中包含该头文件，即可在程序中直接调用相关函数。

\section*{4．2．2 字符串的存储结构}
字符串是数据元素为单个字符的线性表，一般采用顺序存储，即用数组来存储串的字符序列。在 C、C ++ 、Java 等语言中，字符串都是采用顺序存储。在字符串的顺序存储中，一般有以下三种方法表示串的长度。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-116}\\
（1）用一个变量来表示串的长度，如图 4－3 所示。

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & $\cdots$ & MaxSize－1 &  \\
\hline
$a$ & $b$ & $c$ & $d$ & $e$ & $f$ & $g$ & $h$ & $i$ & 空闲 & 9. & 电的长度为9 \\
\hline
\end{tabular}
\end{center}

图 4－3 串的顺序存储方式 1\\
（2）用数组的 0 号单元存放串的长度，串值从 1 号单元开始存放，如图 4－4 所示。

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & $\cdots$ & MaxSize－1 \\
\hline
9 & $a$ & $b$ & $c$ & $d$ & $e$ & $f$ & $g$ & $h$ & $i$ &  & 空闲 \\
\hline
\end{tabular}
\end{center}

图 4－4 串的顺序存储方式 2\\
（3）在串尾存储一个不会在串中出现的特殊字符作为字符串的终结符，例如，在 C 、 C＋＋和 Java 语言中用＇$\backslash 0^{\prime}$ 来表示串的结束，如图 4－5 所示。这种存储方法不能直接得到串的长度，而是通过判断当前字符是否为＇ 0 ＇来确定串是否结束，从而求得串的长度。

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|r|l|l|l|}
\multicolumn{1}{c}{0} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & $\cdots$ & MaxSize－1 \\
\hline
$a$ & $b$ & $c$ & $d$ & $e$ & $f$ & $g$ & $h$ & $i$ & 10 &  & 空闲 \\
\hline
\end{tabular}
\end{center}

图 4－5 串的顺序存储方式 3

\section*{4．2．3 模式匹配}
给定两个字符串 $S="{ }^{n} s_{1} s_{2} \cdots s_{n} "$ 和 $T={ }^{n} t_{1} t_{2} \cdots t_{m} "$ ，在主串 $S$ 中寻找子串 $T$ 的过程称为模式匹配（pattern matching），$T$ 称为模式（pattern）。如果匹配成功，返回 $T$ 在 $S$ 中的位置；如果匹配失败，返回 0 。在文本处理、邮件过滤、杀毒软件、操作系统、编译系统、数据库系统以及搜索引擎中，模式匹配是使用最频繁的操作。

模式匹配具有下面两个明显的特征：（1）问题规模很大，常常需要在大量信息中进行匹配，因此，算法的一次执行时间不容忽视；（2）匹配操作经常被调用，执行频率高，因此，算法改进所取得的效益因积累往往比表面上看起来要大得多。

\section*{1．BF 算法}
BF 算法的基本思想是蛮力匹配，即从主串 $S$ 的第一个字符开始和模式 $T$ 的第一个字符进行比较。若相等，则继续比较两者的后续字符；否则，从主串 $S$ 的第二个字符开始和模式 $T$ 的第一个字符进行比较。重复上述过程，直至 $S$ 或 $T$ 中所有字符比较完毕。若 $T$ 中的字符全部比较完\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-116(1)}毕，则匹配成功，返回本趟匹配的开始位置；否则匹配失败，返回 0 。 BF 算法用伪代码描

述如下：

算法： $\mathrm{BF}(\mathrm{S}, \mathrm{T})$\\
输人：主串 $S$ ，模式 $T$\\
输出：$T$ 在 $S$ 中的位置\\
1．在串 $S$ 和串 $T$ 中设置比较的起始下标 $i=0, j=0$ ；\\
2．重复下述操作，直到 S 或 T 的所有字符均比较完毕：\\
2.1 如果 $S[i]$ 等于 $T[j]$ ，继续比较 $S$ 和 $T$ 的下一对字符；\\
2.2 否则，下标 $i$ 和 $j$ 分别回溯，开始下一趟匹配；

3．如果 T 中所有字符均比较完，则匹配成功，返回本趟匹配的起始位置；否则匹配失败，返回 0 ；

例 4－3 设主串 $S=$＂$a b c a b c a c b$＂，模式 $T=$＂$a b c a c$＂， BF 算法的匹配过程如图 4－6 所示。

第1趟匹配，$i=4, j=4$ 失败 i回溯到 1 ，j回溯到 0\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-117}

第2趟匹配， $\mathrm{i}=1, \mathrm{j}=0$ 失败 i 回溯到 2 ，j回溯到 0\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-117(1)}

第3趟匹配，$i=2, j=0$ 失败 i回溯到3，j回溯到 0

图 4－6 BF 算法的执行过程\\
为了便于回溯，设变量 start 记载主串 $S$ 中每一趟比较的起始位置，BF 算法的函数定义如下：

第4趟匹配， $\mathrm{i}=8, \mathrm{j}=5$ ， T中全部字符都比较完毕，匹配成功\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-117(2)}

算法的执行过程\\
int BE（char S［］，char T ］）

$$
\begin{aligned}
& \text { int start = 0; /*主害从下标 0 开始第一趟匹配 * / } \\
& \text { int } i=0, j=0 \text {; } \quad l * \text { 设置比较的起始下标 } * / \\
& \text { while ( } S[i]!='\left(0^{\prime}\right) \text { \&\& (T[j] ! = ' } \backslash 0^{\prime} \text { ) ) } \\
& \text { f } \\
& \text { if }(S[i]=T[j])\{i++; j++;\} \\
& \text { else \{ start + ; } i=s \operatorname{tar} t ; j=0 \text {; \} } / * 1 \text { 和 } j \text { 分别回溯 * / } \\
& 1 \\
& \text { if ( } \mathrm{T}[\mathrm{j}]={ }^{\prime} \backslash 0^{\prime} \text { ) return start }+1 ; \quad / * \text { 返回本趟匹配的起始位置 } * / \\
& \text { else return } 0_{\text {; }}
\end{aligned}
$$

设主串 $S$ 长度为 $n$ ，模式 $T$ 长度为 $m$ ，在匹配成功的情况下，考虑两种极端情况：\\
（1）在最好情况下，每趟不成功的匹配都发生在模式 $T$ 的第一个字符。\\
例如，$S=$＂a a a a a a a a a a b c＂,$~ T=$＂$b c$＂，设匹配成功发生在 $s_{i}$ 处，则在 $i-1$ 趟不成功的匹配中共比较了 $i-1$ 次，第 $i$ 趟成功的匹配共比较了 $m$ 次，所以总共比较了 $i-1+m$ 次，所有匹配成功的位置共有 $n-m+1$ 处。设从 $s_{i}$ 开始与模式 $T$ 匹配成功的概率为 $p_{i}$ ，在等概率情况下，平均的比较次数是：

$$
\begin{aligned}
\sum_{i=1}^{n-m+1} p_{i} \times(i-1+m) & =\sum_{i=1}^{n-m+1} \frac{1}{n-m+1} \times(i-1+m) \\
& =\frac{(n+m)}{2} \\
& =O(n+m)
\end{aligned}
$$

（2）在最坏情况下，每趟不成功的匹配都发生在模式 $T$ 的最后一个字符。\\
例如，$S=$＂$a$ аа $a$ а $a$ а $a$ а $a$ a $b$＂,$~ T=$＂$a a a b$＂，设匹配成功发生在 $s_{i}$ 处，则在 $i-1$ 趟不成功的匹配中共比较了 $(i-1) \times m$ 次，第 $i$ 趟成功的匹配共比较了 $m$ 次，所以总共比较了 $i \times$ $m$ 次。在等概率情况下，平均的比较次数是：

$$
\sum_{i=1}^{n-m+1} p_{i} \times(i \times m)=\sum_{i=1}^{n-m+1} \frac{1}{n-m+1} \times(i \times m)=\frac{m(n-m+2)}{2}
$$

一般情况下，$m \ll \mathrm{n}$ ，因此最坏情况下的时间复杂度是 $O(n \times m)$ 。

\section*{2．KMP 算法}
BF 算法简单但效率较低，一种对 BF 算法做了很大改进的模式匹配算法是 KMP 算法 ${ }^{(1)}$ ，改进的出发点是主串不进行回溯。分析 BF 算法的执行过程，造成 BF 算法效率低的原因是回溯，即在某趟匹配失败后，对于主串 $S$ 要回溯到本趟匹配开始字符的下一个字符，模式 $T$ 要回溯到第一个字符，而这些回溯往往是不必要的。如图 4－4 所示的匹配过程，在第 1 趟匹配过程中，$S[0] \sim S[3]$ 和 $T[0] \sim T[3]$ 是匹配成功的，$S[4] \neq T[4]$ 匹配失败。因为在第1趟中有 $\mathrm{S}[1]=\mathrm{T}[1]$ ，而 $\mathrm{T}[0] \neq \mathrm{T}[1]$ ，因此有 $\mathrm{T}[0] \neq \mathrm{S}[1]$ ，所以第2趟是不必要的，同理第 3 趟也是不必要的，可以直接到第 4 趟。进一步分析第 4 趟中的第一对字符 $\mathrm{S}[3]$ 和 $\mathrm{T}[0]$ 的比较是多余的，因为第 1 趟中已经比较了 $\mathrm{S}[3]$ 和 $\mathrm{T}[3]$ ，并且 $\mathrm{S}[3]=$ $\mathrm{T}[3]$ ，而 $\mathrm{T}[0]=\mathrm{T}[3]$ ，因此必有 $\mathrm{S}[3]=\mathrm{T}[0]$ ，因此第 4 趟比较可以从第二对字符 $\mathrm{S}[4]$和 T［1］开始进行，这就是说，第1趟匹配失败后，下标 i 不回溯，而是将下标 j 回溯至第 2 个字符，用 $\mathrm{T}[1]$＂对准＂ $\mathrm{S}[4]$ 继续进行比较。

综上所述，希望某趟在 $S[i]$ 和 $T[j]$ 匹配失败后，下标 $i$ 不回溯，下标 $j$ 回溯至某个位置 $k$ ，使得 $T[k]$ 对准 $S[i]$ 继续进行比较。显然，关键问题是如何确定位置 $k$ 。

观察部分匹配成功时的特征，某趟在 $S[i]$ 和 $T[j]$ 匹配失败后，下一趟比较从 $S[i]$ 和

\footnotetext{（1）KMP 算法是克努思（Knuth）、莫里斯（Morris）和普拉特（Pratt）同时设计的。
}
$T[k]$ 开始，则有 $T[0] \sim T[k-1]=S[i-k] \sim S[i-1]$ 成立，如图4－7（a）所示；在部分匹配成功时，有 $T[j-k] \sim T[j-1]=S[i-k] \sim S[i-1]$ 成立，如图 4－7（b）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-119}

图 4－7 部分匹配成功时的特征\\
由 $\mathrm{T}[0] \sim \mathrm{T}[\mathrm{k}-1]=\mathrm{S}[\mathrm{i}-\mathrm{k}] \sim \mathrm{S}[\mathrm{i}-1]$ 和 $\mathrm{T}[\mathrm{j}-\mathrm{k}] \sim \mathrm{T}[\mathrm{j}-1]=\mathrm{S}[\mathrm{i}-\mathrm{k}] \sim \mathrm{S}[\mathrm{i}-1]$ ，可得：


\begin{equation*}
\mathrm{T}[0] \sim \mathrm{T}[\mathrm{k}-1]=\mathrm{T}[\mathrm{j}-\mathrm{k}] \sim \mathrm{T}[\mathrm{j}-1] \tag{4-1}
\end{equation*}


式（4－1）说明，模式中的每一个字符 $\mathrm{T}[\mathrm{j}]$ 都对应一个 k 值，这个 k 值仅依赖于模式本身，与主串无关。用 next［ j ］表示 $\mathrm{T}[\mathrm{j}]$ 对应的 k 值 $(0 \leqslant \mathrm{j}<\mathrm{m})$ ，其定义如下：\\
$n \operatorname{ext}[j]= \begin{cases}-1 & j=0 \\ \max \{k \mid 1 \leqslant k<j \text { 且 } T[0] \cdots T[k-1]=T[j-k] \cdots T[j-1]\} & \text { 集合非空 } \\ 0 & \text { 其他情况 }\end{cases}$\\
例 4－4 设模式 $T=$＂$a b a b c$＂，求该模式的 next 值。\\
解：利用 next［j］的定义，计算过程如下：\\
$\mathrm{j}=0$ 时，next $[0]=-1$ ；\\
$\mathrm{j}=1$ 时，next $[1]=0$ ；\\
$\mathrm{j}=2$ 时， $\mathrm{T}[0] \neq \mathrm{T}[1]$ ，则 $\operatorname{next}[2]=0$ ；\\
$\mathrm{j}=3$ 时， $\mathrm{T}[0] \mathrm{T}[1] \neq \mathrm{T}[1] \mathrm{T}[2], \mathrm{T}[0]=\mathrm{T}[2]$ ，则 $\operatorname{next}[3]=1$ ；\\
$\mathrm{j}=4$ 时， $\mathrm{T}[0] \mathrm{T}[1] \mathrm{T}[2] \neq \mathrm{T}[1] \mathrm{T}[2] \mathrm{T}[3], \mathrm{T}[0] \mathrm{T}[1]=\mathrm{T}[2] \mathrm{T}[3]$ ，则 $\operatorname{next}[4]=2$ 。\\
在求得了模式 $T$ 的 next 值后，KMP 算法用伪代码描述如下：

算法：KMP（S，T，next）\\
输人：主串 $S$ ，模式 $T$ ，模式 $T$ 的 next 值\\
输出：$T$ 在 $S$ 中的位置\\
1．在串 $S$ 和串 $T$ 中分别设置比较的起始下标 $i=0, j=0$ ；\\
2．重复下述操作，直到 $S$ 或 $T$ 的所有字符均比较完毕：\\
2.1 如果 $S[i]$ 等于 $T[j]$ ，继续比较 $S$ 和 $T$ 的下一对字符；\\
2.2 否则，将下标 $j$ 回溯到 $\operatorname{next}[j]$ 位置，即 $j=n \operatorname{ext}[j]$ ；\\
2.3 如果 $j$ 等于 -1 ，则将下标 $i$ 和 $j$ 分别加 1 ，准备下一趟比较；

3．如果 T 中所有字符均比较完毕，则返回本趟匹配的开始位置；\\
否则返回 0 ；

例 4－5 设主串 $S=$＂$a b a b a a b a b c b$＂，模式 $T=$＂$a b a b c$＂，模式 $T$ 的 next 值为 $\{-1,0$ ， $0,1,2\}, \mathrm{KMP}$ 算法的匹配过程如图 4－8 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-120(1)}

图 4－8 KMP 算法的执行过程

\section*{4.3 多 维 数 组 \\
 多 维 数 组}
\section*{4．3．1 数组的逻辑结构}
\section*{1．数组的定义}
数组（array）是由类型相同的数据元素构成的有序集合，每个数据元素称为一个数组元素（简称＂元素＂），每个元素受 $n(n \geqslant 1)$ 个线性关系的约束，每个元素在 $n$ 个线性关系中的序号 $i_{1}, i_{2}, \cdots, i_{n}$ 称为该元素的下标，并称该数组为 $n$ 维数组。可以看出，数组的特点是数据元素本身可以具有某种结构，但属于同一数据类型。例如：一维数组可以看作一个线性表；二维数组可以看作元素是线性表的线性表；以此类推。所以，数组是线性表的推广，如图 4－9 所示。本节重点讨论二维数组。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-120}

图 4－9 数组是线性表的推广

\section*{2．数组的抽象数据类型定义}
数组是一个具有固定格式和数量的数据集合，在数组上一般不能执行插人或删除某

个数组元素的操作。因此，数组中通常只有如下两种基本操作。（1）读操作：给定一组下标，读取相应的数组元素。（2）写操作：给定一组下标，存储或修改相应的数组元素。这两种操作本质上对应一种操作——寻址，即根据一组下标定位相应的数组元素。下面给出数组的抽象数据类型定义。

\begin{verbatim}
ADT Matrix
DataModel
    相同类型的数据元素的有序集合
    每个数据元素受 $n(n \geqslant 1)$ 个线性关系的约束并由一组下标唯一标识
operation
    InitMatrix
        输人: 数组的维数 n 和各维的长度 $\mathrm{I}_{1}, \mathrm{I}_{2}, \cdots, \mathrm{I}_{\mathrm{n}}$
        功能: 数组的初始化
        输出: 一个空的 n 维数组
    GetMatrix
        输人: 一组下标 $i_{i}, i_{2}, \cdots, i_{n}$
        功能: 读操作, 读取这组下标对应的数组元素
        输出: 对应下标 $i_{1}, i_{2}, \cdots, i_{n}$ 的元素值
    SetMatrix
        输人: 元素值 $e$, 一组下标 $i_{1}, i_{2}, \cdots, i_{n}$
        功能: 写操作, 存储或修改这组下标对应的数组元素
        输出: 对应下标 $i_{1}, i_{2}, \cdots, i_{n}$ 的元索值改为 $e$
endADT
\end{verbatim}

\section*{4．3．2 数组的存储结构与导址}
由于数组一般不执行插入和删除操作，也就是说，一旦建立了数组，其元素个数和元素之间的关系就不再发生变动，而且，数组是一种特殊的数据结构，通常要求能够随机存取，因此，数组采用顺序存储。由于内存单元是一维结构，而多维数组是多维结构，所以，采用顺序存储结构存储\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-121}数组首先需要将多维结构映射到一维结构。常用的映射方法有两种；以行序为主序（row major order，按行优先）和以列序为主序（column major order，按列优先）。例如，C 语言中的数组是按行优先存储的。

对于二维数组，按行优先存储的基本思想是：先行后列，先存储行号较小的元素，行号相同者先存储列号较小的元素。设二维数组行下标与列下标的范围分别为 $\left[l_{1}, h_{1}\right]$ 与 $\left[l_{2}, h_{2}\right]$ ，则元素 $a_{i j}$ 的存储地址可由下式确定：


\begin{equation*}
\operatorname{LOC}\left(a_{i j}\right)=\operatorname{LOC}\left(a_{l_{1} l_{2}}\right)+\left(\left(i-l_{1}\right) \times\left(h_{2}-l_{2}+1\right)+\left(j-l_{2}\right)\right) \times c \tag{4-2}
\end{equation*}


式（4－2）中，$i \in\left[l_{1}, h_{1}\right], j \in\left[l_{2}, h_{2}\right]$ ，且 $i$ 与 $j$ 均为整数； $\operatorname{LOC}\left(a_{i j}\right)$ 是元素 $a_{i j}$ 的存储地址；LOC $\left(a_{l_{1} l_{2}}\right)$ 是二维数组中第一个元素 $a_{l_{1} l_{2}}$ 的存储地址，通常称为基地址；$c$ 是每个元素所占存储单元数目。二维数组的寻址过程如图 4－10 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-122(1)}

图 4－10 二维数组按行优先存储的寻址示意图\\
二维数组按列优先存储的基本思想是：先列后行，先存储列号较小的元素，列号相同者先存储行号较小的元素。任一元素存储地址的计算与按行优先存储类似。

\section*{4.4 矩阵的压缩存储}
在实际应用中，经常出现一些阶数很高的矩阵，同时在矩阵中有很多值相同的元素并且它们的分布有一定的规律——称为特殊矩阵（special matrix），或者矩阵中有很多零元素——称为稀疏矩阵（sparse matrix）。可以对这类矩阵进行压缩存储，从而节省存储空间，并使矩阵的各种运算能有效地进行。

矩阵压缩存储的基本思想是：（1）为多个值相同的元素只分配一个存储空间；（2）对零元素不分配存储空间。为了和 $\mathrm{C}++$ 语言的数组保持一致，在下面的讨论中，存储矩阵的一维数组下标从 0 开始。

\section*{4．4．1 特殊矩阵的压缩存储}
\section*{1．对称矩阵的压缩存储}
形如图 4－11 的矩阵称为对称矩阵。设对称矩阵是 $n$ 阶方阵，则有\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-122}

图 4－11 一个 5 阶对称矩阵 $a_{i j}=a_{j i}(1 \leqslant i, j \leqslant n)$ 。对称矩阵关于主对角线对称，因此只需存储下三角部分（包括主对角线）即可。这样，原来需要 $n \times n$ 个存储单元，现在只需要 $n \times(n+1) / 2$ 个存储单元，节约了大约一半的存储单元。当 $n$ 较大时，这是可观的一部分存储资源。

如何只存储下三角部分的元素呢？由于下三角中共有\\
$n \times(n+1) / 2$ 个元素，可将这些元素按行存储到数组 $\mathrm{SA}[\mathrm{n}(\mathrm{n}+1) / 2]$ 中，如图 4－12（a）所示。这样，下三角中的元素 $a_{i j}(i \geqslant j)$ 存储到 SA［k］中，在数组 SA 中的下标 $k$ 与 $i 、 j$ 的关系为：$k=i \times(i-1) / 2+j-1$ 。对于上三角中的元素 $a_{i j}(i<j)$ ，因为 $a_{i j}=a_{j i}$ ，则访问和它对应的下三角中的元素 $a_{j i}$ 即可，即：$k=j \times(j-1) / 2+i-1$ 。寻址的计算方法如图 4－12（c）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-123(1)}\\
（a）对称矩阵的压缩存储\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-123(2)}\\
（b）存储下三角部分\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-123}\\
（c）计算方法

图 4－12 对称矩阵按行优先存储的寻址示意图

\section*{2．三角矩阵的压缩存储}
形如图 4－13 的矩阵称为三角矩阵，其中图 4－13（a）为下三角矩阵，主对角线以上均为常数 $c$ ；图 4－13（b）为上三角矩阵，主对角线以下均为常数 $c$ 。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-123(3)}

图 4－13 三角矩阵\\
下三角矩阵的压缩存储与对称矩阵类似，不同之处仅在于除了存储下三角中的元素以外，还要存储对角线上方的常数。因为是同一个常数，所以只存储一个即可。这样，共存储 $n \times(n+1) / 2+1$ 个元素，将其按行优先存人数组 $\mathrm{SA}[\mathrm{n} \times(\mathrm{n}+1) / 2+1]$ 中，如图 4－14 所示。上三角矩阵的压缩存储思想与下三角矩阵类似，即按行存储上三角部分，最后存储对角线下方的常数，元素 $a_{i j}(i \leqslant j)$ 在 SA 中的下标 $k=(i-1) \times(2 n-i+2) / 2+$ $j-i$ ，其寻址的计算方法如图 4－15 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-124(1)}

图 4－14 下三角矩阵的压缩存储\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-124(2)}

图 4－15 三角矩阵按行优先存储的寻址示意图

\section*{3．对角矩阵的压缩存储}
在对角矩阵中，所有非零元素都集中在以主对角线为中心的带状区域，除了主对角线和若干条次对角线的元素外，所有其他元素都为零。因此，对角矩阵也称为带状矩阵，图 4－16 所示为一个三对角矩阵。

$$
A=\left(\begin{array}{ccccc}
a_{11} & a_{12} & 0 & 0 & 0 \\
a_{21} & a_{22} & a_{23} & 0 & 0 \\
0 & a_{32} & a_{33} & a_{34} & 0 \\
0 & 0 & a_{43} & a_{44} & a_{45} \\
0 & 0 & 0 & a_{54} & a_{55}
\end{array}\right)
$$

图 4－16 三对角矩阵

对角矩阵的压缩存储方法是将对角矩阵的非零元素按行存储到一维数组中，例如，三对角矩阵的压缩存储及其寻址方法如图 4－17 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-124}\\
（a）三对角矩阵

元素 $a_{i j}$ 在一维数组中的序号\\
$=$ 前 $i-1$ 行元素个数 + 第 $i$ 行元素个数\\
$=2+3(i-2)+(j-i+2)$\\
$=2 i+j-2$\\
因为一维数组下标从 0 开始\\
所以元素 $a_{i j}$ 在一维数组中的下标\\
$k=2 i+j-3$\\
（c）寻址的计算方法

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
\hline
$a_{11}$ & $a_{12}$ & $a_{21}$ & $a_{22}$ & $a_{23}$ & $a_{32}$ & $a_{33}$ & $a_{34}$ & $a_{43}$ & $a_{44}$ & $a_{45}$ & $a_{54}$ & $a_{55}$ \\
\hline
\multicolumn{3}{|l|}{第1行} & \multicolumn{2}{|l|}{第2行} & \multicolumn{3}{|c|}{第3行} & \multicolumn{3}{|c|}{第4行} & \multicolumn{2}{|c|}{第5行} \\
\hline
\end{tabular}
\end{center}

（b）按行将非零元素存储到一维数组中

图 4－17 三对角矩阵的压缩存储方法

\section*{4．4．2 稀疏矩阵的压缩存储}
稀疏矩阵是零元素居多的矩阵 ${ }^{(1)}$ 。在工程应用中，经常会遇到阶数很高的大型稀疏矩阵，如果按常规方法存储，则会存储大量的零元素，造成存储浪费。一个显然的存储方法是仅存非零元素。但对于这类矩阵，通常非零元素的分布没有规律，为了能够找到相应的非零元素，仅存储非\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-125}零元素的值是不够的，还要存储该元素所在的行号和列号，即将非零元素表示为三元组 （行号，列号，非零元素值）。三元组的存储结构定义如下：

\begin{verbatim}
template <typename DataType>
struct element
{
    int row, col;
    DataType item;
};
\end{verbatim}

将稀疏矩阵的非零元素对应的三元组所构成的集合，按行优先排列成一个线性表，称为三元组表（list of 3－tuples），则稀疏矩阵的压缩存储转化为三元组表的存储。例如，图 4－18 所示稀疏矩阵对应的三元组表是 $((1,1,3),(1,4,7),(2,3,-1),(3,1,2)$ ， （5，4，－8））。

\section*{1．三元组顺序表}
三元组表的顺序存储结构称为三元组顺序表（sequential list of 3－tuples）。\\
显然，要唯一表示一个稀疏矩阵，还需要在存储三元组表的同时存储该矩阵的行数、列数和非零元素的个数，其存储结构定义如下：

\begin{verbatim}
const int MaxTerm =100;
struct SparseMatrix
f
    element data[MaxTerm];
    int mu, nu, tu; //行数、列数、非零元个数
};
\end{verbatim}

例如，图 4－18 所示稀疏矩阵对应的三元组顺序表如图 4－19 所示。

\section*{2．十字链表}
采用三元组顺序表存储稀疏矩阵，对于矩阵的加法、乘法等操作，非零元素的个数及

\footnotetext{（1）对于稀疏矩阵无法给出确切的概念，只要非零元素的个数远远小于矩阵元素的总数，就可认为该矩阵是稀疏的。可以用稀疏因子来描述矩阵的稀疏程度，设在一个 $m$ 行 $n$ 列的矩阵中有 $t$ 个非零元素，则稀疏因子 $\delta=\frac{t}{m \times n}$ 。通常在 $\delta<0.05$ 时，就可以认为是稀疏的。Allen Weiss 等认为，对于一个 $n \times n$ 的矩阵，只要非零元素个数小于 $n^{2} / 3$ 就是稀疏矩阵。
}位置都会发生变化，则在三元组顺序表中就要进行插入和删除操作，顺序存储就十分不便。稀疏矩阵的链接存储结构称为十字链表（orthogonal list），其基本思想是：将每个非零元素对应的三元组存储为一个链表结点，结点由 5 个域组成，其结构如图 4－20 所示。其中，data 为存储非零元素对应的三元组；right 为指向同一行中的下一个三元组结点； down 为指向同一列中的下一个三元组结点。十字链表的结点结构定义如下：

$$
A=\left(\begin{array}{rrrr}
3 & 0 & 0 & 7 \\
0 & 0 & -1 & 0 \\
2 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & -8
\end{array}\right)
$$

图 4－18 稀疏矩阵 $\boldsymbol{A}$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-126(1)}

图 4－19 矩阵 $\boldsymbol{A}$ 的三元组顺序表

\begin{center}
\begin{tabular}{|c|c|}
\hline
\multicolumn{2}{|c|}{data} \\
（row，col，item） &  \\
\hline
down & right \\
\hline
\end{tabular}
\end{center}

图 4－20 十字链表的结点结构

\begin{verbatim}
struct orthNode
{
    element data;
    struct OrthNode * right, * down?
);
\end{verbatim}

将稀疏矩阵每一行的非零元素按其列号从小到大由 right 域链成一个行链表，每一列的非零元素按其行号从小到大由 down 域链成一个列链表，每个非零元素 $a_{i j}$ 既是第 $i$行链表中的一个结点，又是第 $j$ 列链表中的一个结点，故称之为十字链表。为了实现对某一行链表的头指针进行快速查找，将这些头指针存储在一个数组 HA 中。同样道理，为了实现对某一列链表的头指针进行快速查找，将这些头指针存储在一个数组 HB 中。图 4－18 所示稀疏矩阵的十字链表存储如图 4－21 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-126}

图 4－21 稀疏矩阵的十字链表存储

\section*{4.5 扩展与提高}
\section*{4．5．1 稀疏矩阵的转置运算}
稀疏矩阵的压缩存储节约了存储空间，但失去了可以按下标直接存取的特性，使得矩阵的某些运算可能变得复杂。设稀疏矩阵采用三元组顺序表存储，将稀疏矩阵 $\boldsymbol{A}$ 转置为稀疏矩阵 $\boldsymbol{B}$ ，下面讨论稀疏矩阵压缩存储下的转置运算。

\section*{1．转置算法 1——直接取，顺序存}
假设对稀疏矩阵 $A_{i j}(1 \leqslant i \leqslant n, 1 \leqslant j \leqslant m)$ 进行转置运算，算法 1 的基本思想是：在 $A$的三元组顺序表中依次查找第 1 列、第 2 列、 $\cdots$ 、最后一列的三元组，并将找到的每个三元组的行、列交换后顺序存储到 $B$ 的三元组顺序表中。算法用 $\mathrm{C}++$ 语言描述如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-127}

转置算法 1 的执行时间主要耗费在嵌套的 for 循环上，时间复杂度为 $O(n u \times t u)$ 。与常规存储方式下矩阵转置算法（时间复杂度为 $O(n u \times m u)$ ）相比，当 $t u>m u$ 时，算法的时间性能较差。

\section*{2．转置算法 2——顺序取，直接存}
转置算法 1 效率低的原因是从 $A$ 的三元组顺序表中依次寻找第 1 列、第 2 列、 $\cdots$ 、最后一列的三元组，要反复扫描 $A$ 的三元组顺序表。若能直接确定 $A$ 中每个三元组在 $B$中的位置，则对 $A$ 扫描一次即可。转置算法 2 的基本思想是：在 $A$ 的三元组顺序表中依次取三元组，交换其行号和列号放到 $B$ 中适当位置。显然，算法的关键是如何确定当前从 $A$ 中取出的三元组在 $B$ 中的位置。注意到 $A$ 中第 1 列的第一个非零元素一定存储在 $B$ 中下标为 0 的位置上，该列中其他非零元素应存放在 $B$ 中后面连续的位置上，那么第 2列的第一个非零元素在 $B$ 中的位置便等于第 1 列的第一个非零元素在 $B$ 中的位置加上

第1列的非零元素的个数，以此类推。为此，需引人两个数组作为辅助数据结构：\\
num［nu］：矩阵 $\boldsymbol{A}$ 中某列的非零元素的个数。\\
$\mathrm{cpot}[\mathrm{nu}]$ ；初值表示矩阵 $\boldsymbol{A}$ 中某列第一个非零元素在 $B$ 中的位置，并有如下递推关系：

\[
\left\{\begin{array}{l}
\operatorname{cpot}[1]=0  \tag{4-3}\\
\operatorname{cpot}[\operatorname{col}]=\operatorname{cpot}[\operatorname{col}-1]+\mathrm{num}[\operatorname{col}-1] ; \quad 2 \leqslant \operatorname{col} \leqslant n u
\end{array}\right.
\]

对于图 4－18 的稀疏矩阵 $\boldsymbol{A}$ 的 num 和 cpot 的值如图 4－22 所示，num 和 cpot 之间的关系如图 4－23 所示。

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
col & 1 & 2 & 3 & 4 & 5 \\
\hline
num［col］ & 2 & 1 & 1 & 0 & 1 \\
\hline
cpot［col］ & 0 & 2 & 3 & 4 & 4 \\
\hline
\end{tabular}
\end{center}

图 4－22 稀疏短阵 $\boldsymbol{A}$ 的 num 与 cpot 值\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-128}

图 4－23 num 与 cpot 之间关系示意图

在求出 $\operatorname{cpot}[\mathrm{nu}]$ 后只需扫描一遍 $A$ 的三元组顺序表，当扫描到一个 col 列的元素时，直接将其存放在 $B$ 中下标为 $\operatorname{cpot}[\mathrm{col}]$ 的位置上，然后将 $\mathrm{cpot}[\mathrm{col}]$ 加 1 ，即 $\mathrm{cpot}[\mathrm{col}]$ 是下一个 col 列元素（如果有的话）在 $B$ 中的位置。转置算法 2 用伪代码描述如下：

算法：Trans2（A，B）\\
输人：三元组顺序表存储的稀疏矩阵 A\\
输出：矩阵 $A$ 的转置矩阵 $B$ ，矩阵 $B$ 采用三元组顺序表存储\\
1．设置转置后矩阵 $B$ 的行数、列数和非零元素的个数；\\
2．计算 A 中每一列的非零元素个数；\\
3．计算 A 中每一列的第一个非零元素在 B 中的下标；\\
4．依次取 $A$ 中的每一个非零元素对应的三元组；\\
4.1 确定该元素在 $B$ 中的下标 $p b$ ；\\
4.2 将该元素的行号列号交换后存人 B 中 pb 的位置；\\
4.3 预置该元素所在列的下一个元素的存放位置；

下面给出转置算法 2 的 C＋＋语言实现。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-128(1)}

\begin{verbatim}
    num[j]++;
}
cpot [1] = 0;
for (i = 2; 1 <= A.nu; 1++)
    cpot[i] = cpot[i-1]+num[i-1];
for (i=0; i<A.tu; i++) //担描三元组表A
1
    j=A.data[i].col; //取肖前三元组的列号
    k = cpot[j]; //当前三元组在 B 中的下标
    B.data[k].row = A.data[i].col;
    B.data[k].col = A.data [1].row;
    B.data[k].item = A.data[i].item;
    cpot[j]++; //预置同一列下一个三元组的下标
\end{verbatim}

转置算法 2 有三个循环，分别执行 $t u 、 n u$ 和 $t u$ 次，因此时间复杂度是 $O(n u+t u)$ 。该算法需要的存储空间比转置算法 1 多了两个数组，同时，算法本身也较复杂。

\section*{4．5．2 广义表}
线性表中每个数据元素被限定为具有相同类型，有时这种限制需要放宽，数据元素也可以是一个线性表。例如，工资明细可以表示为：（编号，姓名，岗位工资，补款（业绩，酬金），扣款（公积金，医疗保险），应得工资），这种数据元素可以具有不同结构的线性表就是广义表。

\section*{1．广义表的定义}
广义表（lists）是 $n(n \geqslant 0)$ 个数据元素的有限序列，每个数据元素可以是单个的数据元素，也可以是一个广义表，分别称为广义表的单元素和子表。通常用大写字母表示广义表，用小写字母表示单元素。

当广义表非空时，称第一个元素为广义表的表头；除去表头后其余元素组成的广义表称为广义表的表尾。广义表中数据元素的个数称为广义表的长度；广义表中括号的最大嵌套层数称为广义表的深度。下面是一些广义表的例子：

\begin{center}
\begin{tabular}{ll}
$A=()$ & 空表，长度为 0, 深度为 1 \\
$B=(\mathrm{e})$ & 只有一个单元素，长度为 1, 深度为 1 \\
$C=(a,(b, c, d))$ & 有一个单元素和一个子表，长度为 2, 深度为 2 \\
$D=(A, B, C)$ & 有三个子表，长度为 3, 深度为 3 \\
$E=(a, E)$ & 递归表，长度为 2, 深度为无穷大 \\
$F=(())$ & 只有一个空表，长度为 1, 深度为 2 \\
\end{tabular}
\end{center}

可以用逻辑结构图来描述广义表，具体方法为：广义表的数据元素 $a$ 用一个结点来表示，若 $x$ 为单元素，则用矩形结点表示，若 $x$ 为广义表，则用圆形结点表示，结点之间的

边表示元素之间的包含关系。对于上面列举的广义表，其逻辑结构图如图 4－24 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-130}

图 4－24 广义表的逻辑结构图\\
从上述广义表的定义和例子可以看出，广义表具有以下特性。\\
（1）广义线性性：对任意广义表，若不考虑其数据元素的内部结构，则是一个线性表，数据元素之间是线性关系。\\
（2）元素复合性：广义表的数据元素分为两种：单元素和子表，因此，广义表中元素的类型不统一。一个子表在某一层上被当作元素，但就本身结构而言，也是广义表。\\
（3）元素递归性：广义表可以是递归的。广义表的定义并没有限制元素的递归，即广义表也可以是其自身的子表。这种递归性使得广义表具有较强的表达能力。\\
（4）元素共享性：广义表以及广义表的元素可以为其他广义表所共享。例如，表 $A$ 、表 $B$ 、表 $C$ 是表 $D$ 的共享子表。

广义表的上述特性使得广义表具有很大的使用价值，广义表可以兼容线性表、数组、树和有向图等各种常用的数据结构。例如，当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表；如果限制广义表中元素的共享和递归，广义表和树对应；如果限制广义表的递归并允许元素共享，则广义表和图对应。

\section*{2．广义表的抽象数据类型定义}
广义表有两个重要的基本操作：取表头和取表尾，通过取表头和取表尾操作，可以按递归方法处理广义表。人工智能语言 Lisp 和 Prolog 就是以广义表为数据结构，通过取表头和取表尾实现各种操作。此外，在广义表上还可以定义与线性表类似的一些基本操作，如插人、删除、遍历等。下面给出广义表的抽象数据类型定义。

\begin{verbatim}
ADT Broadlists
DataModel
    数据元素的有限序列,数据元素可以是单元素也可以是广义表
Operation
    InitLists
        输人:无
        功能:初始化广义表
        输出:空的广义表
    DestroyLists
\end{verbatim}

\begin{verbatim}
        输人;无
        功能:销毁广义表
        输出:无
    Length
        输人:无
        功能:求广义表的长度
        输出:广义表含有的数据元素的个数
    Depth
        输人:无
        功能:求广义表的深度
        输出:广义表括号嵌集的最大层数
    Head
        输人:无
        功能:求广义表的表头
        输出:广义表中第一个元素
    Tail
        输人:无
        功能;求广义表的表尾
        输出:广义表的表尾
endADT
\end{verbatim}

\section*{3．广义表的存储结构}
由于广义表中数据元素的类型不统一，因此难以用顺序存储结构来存储。而链接存储结构较为灵活，可以解决广义表的共享与递归问题，所以通常采用链接存储结构来存储广义表。若广义表不空，则可分解为表头和表尾；反之，一对确定的表头和表尾可唯一地确定一个广义表。根据这一性质可采用头尾表示法（head tail expression）来存储广义表。

由于广义表中的数据元素既可以是广义表也可以是单元素，相应地在头尾表示法中链表的结点结构有两种：一种是表结点，用以存储广义表；另一种是元素结点，用以存储单元素。为了区分这两类结点，在结点中还要设置一个标志域。如果标志为 1 ，则表示该结点为表结点；如果标志为 0 ，则表示该结点为元素结点。其结点结构如图 4－25 所示。

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
$\operatorname{tag}=1$ & hp & tp \\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|l|}
\hline
tag $=0$ & data \\
\hline
\end{tabular}
\end{center}

（a）表结点\\
（b）元素结点

图 4－25 头尾表示法的结点

其中，tag：区分表结点和元素结点的标志。\\
hp ：指向表头的指针。\\
tp ：指向表尾的指针。\\
data：存放单元素的数据域。\\
用 C＋＋语言中的结构体类型和联合类型来定义上述结点结构。

\begin{verbatim}
enum Elemtag {Atom, List};
//Atom= 0 为单元素;List=1为子表
template <typename DataType> ;
struct GLNode
{
    Elemtag tag;
    union
    f
        DataType data;
        struct
        i
            struct GLNode * hp, * tp; //hp 和 tp 分别指向表头和表尾
        } ptr;
    };
};
\end{verbatim}

对于图 4－24 所示广义表，采用头尾表示法的存储示意图如图 4－26 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-132}

图 4－26 广义表头尾表示法的存储示意图

\section*{4.6 应 用 实 例}
\section*{4．6．1 发纸牌}
在本章的引言部分给出了发纸牌问题，下面讨论算法设计和程序实现。\\
【算法】为避免重复发牌，设二维数组 $\operatorname{sign}[4][13]$ 记载是否发过某张牌，其中行下标表示花色，列下标表示点数。设字符串指针数组 $\operatorname{card}[\mathrm{n}]$ 存储随机发的 $n$ 张纸牌，例如 $\operatorname{card}[0]="$ 梅花 $2 "$ 。按以下方法依次发每一张牌：首先产生一个 $0 \sim 3$ 的随机数 $i$ 表示花色，再产生一个 $0 \sim 12$ 的随机数 $j$ 表示点数，如果这张牌尚未发出，则将 $\operatorname{sign}[i][j]$ 置 1 ，并将这张牌存储到数组 $\operatorname{card}[\mathrm{n}]$ 中。算法用伪代码描述如下：

算法：SendCards（ n ）\\
输人：牌数 n\\
输出：存储 n 张牌的数组 card $[\mathrm{n}]$\\
1．循环变量 $k$ 从 $0 \sim n-1$ 重复执行下述操作：\\
1.1 －产生 $0 \sim 3$ 的随机数；\\
$1.2 \mathrm{j} \leftarrow$ 产生 $0 \sim 12$ 的随机数；\\
1.3 如果 sign［i］［j］等于 1 ，转 1.1 重新生成第 $k$ 张牌；否则执行下述操作：

1．3．1 sign［i］［j］＝1；\\
1．3．2 将第 $k$ 张牌存储到数组 card $[k]$ 中；$k++$ ；\\
2．输出数组 card［n］；

【程序】设字符串数组 $\operatorname{str} 1$［4］和 $\operatorname{str} 2$［13］分别存储一副纸牌的花色和点数，将数组 $\operatorname{str} 1[4] 、 \operatorname{str} 2[13]$ 和 $\operatorname{sign}[4][13]$ 定义为全局变量，将函数 SendCards 定义为类 PlayCard的成员函数，类 PlayCard 的成员变量 card［13］表示发出的牌。程序如下：

\begin{verbatim}
# include <iostream>
# include <ctime>
#include <cstring>
using namespace std;
int sign [4] [13] = {0};
string str1 [4] = 1 "梅花", "黑桃", "红桃", "方块");
string str2{13}={"2","3","4","5","6","7","8","9","10","J","Q","K","A"};
class PlayCard
{
public:
    PlayCard();
    ~PlayCard();
    void SendCards (int n);
    void PrintCards();
private:
    string card {13}; //最多发 13 张牌
    int num; //发牌张数
};
PlayCard :: PlayCard()
{
    num = 0;
}
PlayCard :: ~PlayCard()
{
}
void PlayCard :: SendCards (int n)
{
    int i, j, k;
\end{verbatim}

\begin{verbatim}
    num = n;
    memset(sign, 0, n): // 初始化标志数组,所有牌均未发出
    srand(time(nullptr));
    for (k = 0; k < n;)
        i = rand() % 4; //随机生成花色的下标
        j = rand() % 13; //随机生成点数的下标
        if (sign[i][j] == 1) //这张牌已发出
            continue; //跳过循环体余下语句,注意 k 的值不变
        else {
                card[k] = str1[i] + str2[j]; //连接 str1 和 str2
                sign[i][j] = 1; //标识这张牌已发出
                k++; //准备发下一张牌
        }
)
void PlayCard::PrintCards()
{
    for (int k = 0; k < num; k++)
            cout <<card[k] <<"\t"; //输出第 k 张牌
    cout <<endl;
)
int main()
l
    int n;
    PlayCard P{ }; //创建对象变量P
    cout <<"请输人要发牌的张数:";
    cin >>n;
    P. SendCards (n) ; //发 n 张牌
    P.PrintCards (); //打印发出的曆
    return 0;
)
\end{verbatim}

\section*{4．6．2 八皇后问题}
在本章的引言部分给出了八皇后问题，下面讨论算法设计和程序实现。\\
【算法】为了简化问题，下面讨论四皇后问题的求解过程。如图 4－27 所示，从空棋盘开始，首先把皇后 1 摆放到第 1 行第 1 列；对于皇后 2 ，在经过第 1 列和第 2 列的失败尝试后，把它摆放到第 2 行第 3 列；皇后 3 摆放到第 3 行的哪列都会引起冲突，所以，回溯到皇后 2 ，把皇后 2 摆放到下一个可能的位置，也就是第 2 行第 4 列；继续下去，皇后 4 摆放到第 4 行的哪列都会引起冲突，回溯到皇后 3 再回溯到皇后 2 ，但此时皇后 2 位于棋盘的最后一列，继续回溯，回到皇后 1 ，把皇后 1 摆放到下一个可能的位置，也就是第 1 行第 2

列，接下来，把皇后 2 摆放第 2 行第 4 列的位置，把皇后 3 摆放到第 3 行第 1 列的位置，把皇后 4 摆放到第 4 行第 3 列的位置，这就是四皇后问题的一个解。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(4)}\\
（a）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(1)}\\
（f）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(2)}\\
（b）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135}\\
（g）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(8)}\\
（c）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(3)}\\
（h）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(5)}\\
（d）

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
 & $Q$ &  &  \\
\hline
 &  &  & $Q$ \\
\hline
$Q$ &  &  &  \\
\hline
 &  &  &  \\
\hline
\end{tabular}
\end{center}

（i）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(6)}\\
（e）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-135(7)}\\
（j）

图 4－27 四皇后问题的求解过程（ $\times$ 表示失败的尝试， Q 表示放置皇后）

设函数 Queen 实现任意 $n$ 皇后问题，皇后 $k$ 摆放在 $k$ 行 $\mathrm{x}[\mathrm{k}]$ 列的位置，注意数组下标从 0 开始，则 $0 \leqslant k<n$ 且 $0 \leqslant \mathrm{x}[\mathrm{k}]<n$ 。算法用伪代码描述如下：

算法：Setqueen（n）\\
输人：皇后的个数 $n$\\
输出： n 皇后问题的解 $\mathrm{x}[\mathrm{n}]$\\
1．初始化 $k=0$ ，初始化解向量 $x[n]=\{-1\}$ ；\\
2．重复执行下述操作，摆放皇后 $k$ ：\\
2.1 把皇后 $k$ 摆放在下一列的位置，即 $x[k]++$ ；\\
2.2 如果皇后 $k$ 摆放在 $x[k]$ 位置发生冲突，则 $x[k]++$ 试探下一列，直到不冲突或 x ［k］出界；\\
2.3 如果 $\mathrm{x}[\mathrm{k}]$ 没出界且所有皇后都摆放完毕，则输出一个解；\\
2.4 如果 $x[k]$ 没出界但尚有皇后没摆放，则 $k++$ ，转 2.1 摆放下一个皇后；\\
2.5 如果 $\times[k]$ 出界，则回溯，$\times[k]=-1, k--$ ，转 2.1 重新摆放皇后 $k$ ；

【程序】将函数 Set Queen 定义为类 Queen 的成员函数，类 Queen 的成员变量 x［N］表示皇后的位置，构造函数初始化皇后的位置和个数，成员函数 Place 判断皇后 k 摆放在 $x[k]$ 是否与前 $k-1$ 个皇后的摆放发生冲突，函数 PrintQueen 打印皇后问题的一个解。程序如下：

\begin{verbatim}
#include <iostream>
#include <cstring>
using namespace std;
class Queen
f
public:
\end{verbatim}

\begin{verbatim}
    ~ Queen () ;
    void SetQueen(); //填写n皇后
    void PrintQueen(); //打印草后位置
private:
    int Place(int k); //判断皇后 k 是否发牛冲突
    int *x; //皇后的位置
    int num; //皇后的个数
1:
Queen : : Queen (int n)
{
    x= new int[n];
    memset ( x , -1, n);
    num = n;
}
Queen: : ~ Queen ()
f
    delete[] x;
}
void Queen : : SetQueen ()
f
    int k = 0, count = 0; //num存储解的个数
    while (k > = 0) //䍿放皇后 k,㳯意 0 0 k < n
    l
        x[k] + +; //在下一列撰放自后k
        while (x [k] < num && Place (k) = = 1) //发生仲突
            x[k]++i //自后k试探下一列
        if (x [k] < num && k = = num - 1) //得到一个解,输出
        {
            cout <<"第"<<t+count <<"个解是:";
            PrintQueen () ;
        }
        else if (x [k] < num && k < num - 1) //尚有皇后未摆放
            k = k + 1; //准备摆放下一个斁后
        else
            x[k--] = -1; //重置x[k],回溯,重新撰放皇后 k
    }
I
int Queen :: Place(int k) //考察皇后 k 放惪在 x[k]列是否发生兆实
f
    for (int i = 0; i<k; 1++)
        if (x[i] ==x[k] || abs (i-k) = = abs (x[i]-x[k])) //违反约束条件
            return 1; //冲窖,返回1
    return 0; 1/不计突,返回0
}
void Queen : PrintQueen() //打印 n 皇后问题的一个解
\end{verbatim}

\begin{verbatim}
( 
    for (int i = 0; i< num; i++)
        cout <<x[i] + 1 <<"\t"; //数组下标从 0 开始,打印的列号从 1 开始
    cout <<endl;
}
int main()
{
    int n:
    cout <<"请输人皇后的个数(n\geqslant4):";
    cin >>n; //输人皇后个数
    Queen Q{n}; //创建对象Q
    Q.SetQueen(); //调用对象Q的函数摆放皇后
    return 0;
}
\end{verbatim}

\section*{思想火花——用常识性的思维去思考问题}
这里列举一个经典问题，求解它可以用复杂的方法，但如果用常识性的思维去思考，你会发现，解决问题的方法非常简单。

有两个城市 $A$ 和 $B$ ，相距 400 公里。两列火车同时相向开出，一列火车以每小时 40公里的速度从城市 $A$ 驶向城市 $B$ ，而另一列火车以每小时 60 公里的速度从城市 $B$ 驶向城市 $A$ 。同时，有一只忙碌的蜜蜂在第一列火车的前面开始了它有趣的旅行，它以每小时 75 公里的速度向着第二列火车飞行，一遇到第二列火车就立即逆转方向飞，以后它一遇到火车就这样逆转方向飞。小蜜蜂一直这样飞行直到两列火车相遇，请问蜜蜂一共飞行了多长的距离？

乍一看，似乎要寻求精密的计算。我们可以确定蜜蜂所飞行的每一段路径的长度，其中一段对应一次一个方向飞行的距离，然后求无限多个这种不断缩短长度的各段的总和。但有比这更好的做法。

两列火车将在 4 小时后相遇，因为它们每小时共同行驶 $40+60=100$ 公里。反过来，蜜蜂以每小时 75 公里的速度连续飞行了 4 个小时，因此，蜜蜂飞行的整个距离是 300公里。

有些问题即使你得出了答案也会觉得自己有点儿傻，因为别人可能会告诉你更简捷的方法。我们被训练成工程师和科学家，总是习惯按照符号和算法去思考问题，却容易忘记常识！

记住：有时找到问题的解其实很容易，不要自己把问题看得太难了。

\section*{习 题 4}
\section*{1．选择题}
（1）设有两个字符串 p 和 q ，求 q 在 p 中首次出现的位置的运算称作（）。\\
A．连接\\
B．模式匹配\\
C．求子串\\
D．求串长\\
（2）设模式 $T=" a b c a b c "$ ，则该模式的 next 值为（ ）。\\
A．$\{-1,0,0,1,2,3\}$\\
B．$\{-1,0,0,0,1,2\}$\\
C．$\{-1,0,0,1,1,2\}$\\
D．$\{-1,0,0,0,2,3\}$\\
（3）二维数组 A 的每个元素是由 6 个字符组成的字符串，行下标的范围从 $0 \sim 8$ ，列下标的范围是从 $0 \sim 9$ ，则存放数组 A 至少需要（ ）个字节，若 A 按行优先方式存储，元素 A［8］［5］的起始地址与当 A 按列优先方式存储时的（ ）元素的起始地址一致。\\
A． 90\\
B． 180\\
C． 240\\
D． 540\\
E． $\mathrm{A}[8][5]$\\
F． $\mathrm{A}[3][10]$\\
G． $\mathrm{A}[5][8]$\\
H． $\mathrm{A}[4][9]$\\
（4）将数组称为随机存取结构是因为（）。\\
A．数组元素是随机的\\
B．对数组任一元素的存取时间是相等的\\
C．随时可以对数组进行访问\\
D．数组的存储结构是不定的\\
（5）下面的说法中，不正确的是（）。\\
A．数组是一种线性结构\\
B．数组是一种定长的线性结构\\
C．除了插人与删除操作外，数组的基本操作还有存取、修改、检索和排序等\\
D．数组的基本操作有存取、修改、检索和排序等，没有插人与删除操作\\
（6）对特殊矩阵采用压缩存储的目的主要是为了（）。\\
A．表达变得简单\\
B．对矩阵元素的存取变得简单\\
C．去掉矩阵中的多余元素\\
D．减少不必要的存储空间\\
（7）下面（）不属于特殊矩阵。\\
A．对角矩阵\\
B．三角矩阵\\
C．稀疏矩阵\\
E．对称矩阵\\
（8）下面的说法中，不正确的是（）。\\
A．对称矩阵只需存放包括主对角线元素在内的下（或上）三角的元素即可。\\
B．对角矩阵只需存放非零元素即可。\\
C．稀疏矩阵中值为零的元素较多，因此可以采用三元组表方法存储。\\
D．稀疏矩阵中大量值为零的元素分布有规律，因此可以采用三元组表方法存储。

\section*{2．解答下列问题}
（1）对于一个 $n$ 行 $m$ 列的上三角矩阵 $\boldsymbol{A}$ ，如果以列优先的方式用一维数组 B 从 0 号位置开始存储，求元素 $a_{i j}(1 \leqslant i \leqslant n, 1 \leqslant j \leqslant m)$ 在数组 B 中的存储位置。\\
（2）设有三对角矩阵 $A_{n \times n}$ ，将其三条对角线上的元素逐行存于数组 $\mathrm{B}[3 \mathrm{n}-2]$ 中，使得 $\mathrm{B}[\mathrm{k}]=a_{i j}(1 \leqslant i, j \leqslant n)$ ，求：\\
（1）用 $i, j$ 表示 $k$ 的下标变换公式；（2）用 $k$ 表示 $i, j$ 的下标变换公式。\\
（3）一个稀疏矩阵如图 4－28 所示，写出对应的三元组顺序表和十字链表存储表示。\\
（4）对于给定的数组 $a[n][2 n-1]$ ，将 3 个顶点分别为 $a[0][n-1] 、 a[n-1][0]$ 和\\
$a[n-1][2 n-2]$ 的三角形上的所有元素按行序存放在一维数组 $B[n \times n]$ 中，且元素 $a[0][n-1]$ 存放在 $B[0]$ 中。例如当 $n=3$ 时，数组 $a[3][5]$ 中三角形如图 4－29 所示。如果位于三角形上的元素 $a[i][j]$ 存放于 $B[k]$ 中，请给出元素 $a[i][j]$ 的下标 $i, j$ 与 $k$ 的对应关系。

$$
\left(\begin{array}{llllll}
0 & 6 & 0 & 0 & 8 & 0 \\
3 & 0 & 0 & 0 & 0 & 0 \\
0 & 5 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 2 & 0
\end{array}\right)
$$

图 4－28 稀疏矩阵\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-139}

图 4－29 矩阵中的三角形\\
（5）设有五对角矩阵 $B=\left(b_{i j}\right)_{20} \cdot 20$ ，将其五条对角线上的元素存在一维数组 $\mathrm{A}[\mathrm{m}]$中，请计算 m 的值以及元素 $b_{15,16}$ 在数组 A 中的存储位置 k 。

\section*{3．算法设计}
（1）模式匹配是严格的匹配，即强调模式在主串中的连续性，例如，模式＂bc＂是主串 ＂$a b c d$＂的子串，而＂$a c$＂就不是主串＂$a b c d$＂的子串。但在实际应用中，有时不需要模式的连续性，例如，模式＂哈工大＂与主串＂哈尔滨工业大学＂是非连续匹配的，称模式＂哈工大＂是主串＂哈尔滨工业大学＂的子序列。要求设计算法，判断给定的模式是否为两个主串的公共子序列。\\
（2）若在矩阵 $\boldsymbol{A}$ 中存在一个元素 $a_{i j}(1 \leqslant i \leqslant n, 1 \leqslant j \leqslant m)$ ，该元素是第 $i$ 行的最小值元素且又是第 $j$ 列的最大值元素，则称此元素为该矩阵的一个鞍点。假设以二维数组存储矩阵，设计算法求矩阵 $\boldsymbol{A}$ 的所有鞍点，并分析最坏情况下的时间复杂度。\\
（3）给定 $n \times m$ 矩阵 $\boldsymbol{A}$ 满足 $\mathrm{A}[\mathrm{i}, \mathrm{j}] \leqslant \mathrm{A}[\mathrm{i}, \mathrm{j}+1](0 \leqslant \mathrm{i} \leqslant \mathrm{n}, 0 \leqslant \mathrm{j} \leqslant \mathrm{m}-1)$ 和 $\mathrm{A}[\mathrm{i}, \mathrm{j}] \leqslant$ $A[i+1, j](0 \leqslant i \leqslant n-1,0 \leqslant j \leqslant m)$ 。设计算法判定 $x$ 是否在 $A$ 中，要求时间复杂度为 $O(m+n)$ 。

\section*{实 验 题 4}
【实验 1】请上机实现 4．2．3 节 BF 算法和 KMP 算法，并用不同的主串和模式进行测试。

【实验 2】最长递增子序列。在数字序列 $A=\left\{a_{1}, a_{2}, \cdots, a_{n}\right\}$ 中按递增下标序列 $\left(i_{1}, i_{2}, \cdots, i_{k}\right)\left(1 \leqslant i_{1}<i_{2}<\cdots<i_{k} \leqslant n\right)$ 顺序选出一个子序列 $B$ ，如果子序列 $B$ 中的数字都是严格递增的，则子序列 $B$ 称为序列 $A$ 的递增子序列（incremental subsequence）。请找出给定数字序列的一个最长的递增子序列。例如，数字序列 $\{5,2,8,6,3,6,9,7\}$ 的一个最长的递增子序列是 $\{2,3,6,9\}$ 。

【实验 3】幻方。幻方在我国古代也称为纵横图，是在一个 $n \times n$ 的矩阵中填人 1 到 $n^{2}$ 的数字（ $n$ 为奇数），使得每一行、每一列、每条对角线的累加和（称为＂幻和＂）都相等。例如，图 4－30 就是一个三阶幻方，幻和为 15 。

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
6 & 1 & 8 \\
\hline
7 & 5 & 3 \\
\hline
2 & 9 & 4 \\
\hline
\end{tabular}
\end{center}

图 4－30 3阶幻方示例

\section*{树和二叉树}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
本章概述 & \multicolumn{5}{|c|}{\begin{tabular}{l}
前面讨论的数据结构都属于线性结构，线性结构主要描述具有单一的前驱和后继关系的数据。树结构是一种比线性结构更复杂的数据结构，适合描述具有层次关系的数据，如祖先一后代、上级一下属、整体一部分以及其他类似的关系。树结构在计算机领域有着广泛的应用，例如，在编译程序中用语法树来表示源程序的语法结构，在数据挖掘中用决策树来进行数据分类等。 \\
本章的内容分为树和二叉树两部分。由实际问题引出树结构，介绍树的定义和基本术语，给出树的抽象数据类型定义，讨论树的存储结构；给出二叉树的定义和基本性质，讨论二叉树的存储结构，实现二叉链表存储的二叉树的遍历操作，最后讨论二叉树的经典应用——哈夫曼树。 \\
\end{tabular}} \\
\hline
教学重点 & \multicolumn{5}{|c|}{二叉树的性质；二叉树和树的存储表示；二叉树的遍历及算法实现；树与二叉树的转换关系；哈夫曼树} \\
\hline
教学难点 & \multicolumn{5}{|l|}{二叉树的层序遍历算法；二叉树的建立算法；哈夫曼算法} \\
\hline
\multirow{7}{*}{} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教 学 要 求} \\
\hline
 &  & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline
 & 树的定义和基本术语 &  &  & $\checkmark$ &  \\
\hline
 & 树和二叉树的抽象数据类型定义 &  & $\checkmark$ &  &  \\
\hline
 & 树和二叉树的遍历 &  &  &  & $\checkmark$ \\
\hline
 & 树的存储结构 &  &  & $\checkmark$ &  \\
\hline
 & 二叉树的定义 &  &  &  & $\checkmark$ \\
\hline
\multirow[t]{10}{*}{教学内容和教学目标} & 二叉树的基本性质 &  &  &  & $\checkmark$ \\
\hline
 & 二叉树的顺序存储结构 &  & $\checkmark$ &  &  \\
\hline
 & 二叉链表 &  &  &  & $\checkmark$ \\
\hline
 & 三叉链表 & $\checkmark$ &  &  &  \\
\hline
 & 二叉树遍历的递归算法 &  &  &  & $\checkmark$ \\
\hline
 & 二叉树遍历的非递归算法 &  & $\checkmark$ &  &  \\
\hline
 & 二叉树的层序遍历算法 &  &  & $\checkmark$ &  \\
\hline
 & 二叉树的建立算法 &  &  & $\checkmark$ &  \\
\hline
 & 树、森林和二叉树之间的转换 &  &  & $\checkmark$ &  \\
\hline
 & 哈夫曼树及哈夫曼编码 &  &  & $\checkmark$ &  \\
\hline
\end{tabular}
\end{center}

\section*{5.1 引言}
树结构比较适合描述具有层次关系的数据，如祖先一后代、上级一下属、整体一部分以及其他类似的关系。很多实际问题抽象的数据模型是树结构，请看下面两个例子。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-141}

【例 5－1】文件统计。Windows 操作系统的文件目录结构如图 5－1（a）所示，其中，＂／＂表示文件夹，括号内的数字表示文件的大小，单位是 KB。假设文件夹本身的大小是 1 KB ，请统计每个文件和文件夹的大小。

【想法——数据模型】文件目录结构具有层次特点，每个文件夹均可包含多个子文件夹和文件，将每个文件或文件夹抽象为一个结点，文件夹与文件之间的关系抽象为结点之间的边，从而将文件目录结构抽象为一个树结构，如图5－1（b）所示。可以对树进行某种遍历，即对树中所有结点进行没有重复没有遗漏的访问，在遍历过程中统计每个文件和文件夹的大小。那么，应该如何存储文件目录结构并在遍历过程中统计大小呢？\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-141(1)}

图 5－1 文件系统目录及其数据模型\\
【例 5－2】 二叉表示树。编译系统在处理算术表达式时，通常将表达式转换为一棵二叉表示树，通过二叉表示树可以判断算术表达式是否存在语法错误。请将给定的算术表达式转换为二叉表示树。

【想法——数据模型】二叉表示树是对应一个算术表达式的二叉树，并具有以下特点：（1）叶子结点一定是操作数；（2）分支结点一定是运算符。将一个算术表达式转化为二叉表示树基于如下规则：\\
（1）根据运算符的优先顺序，将表达式结合成（左操作数 运算符 右操作数）的形式；\\
（2）由外层括号开始，运算符作为二叉表示树的根结点，左操作数作为根结点的左子树，右操作数作为根结点的右子树；\\
（3）如果某子树对应的操作数为一个表达式，则重复第（2）步的转换，直到该子树对应的操作数不能再分解。

例如，将表达式 $(A+B) *(C+D * E)$ 结合成 $((A+B) *(C+(D * E)))$ ，则二叉表示树的根结点是运算符＊，左操作数即左子树是 $(A+B)$ ，右操作数即右子树是 $(C+(D *$\\
$E))$ 。对于左子树（ $A+B$ ），其根结点是运算符＋，左子树是 $A$ ，右子树是 $B$ 。对于右子树 $(C+(D * E))$ ，其根结点是运算符＋，左子树是 $C$ ，右子树是 $(D * E)$ 。依此类推，构造过程如图 5－2 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-142}

图 5－2 二叉表示树的构造过程

\section*{5.2 树的逻辑结构}
\section*{5．2．1 树的定义和基本术语}
\section*{1．树的定义}
在树中通常将数据元素称为结点（node）。\\
树（tree）是 $n(n \geqslant 0)$ 个结点的有限集合 ${ }^{(1)}$ 。当 $n=0$ 时，称为空树；任意一棵非空树满足以下条件：\\
（1）有且仅有一个特定的称为根（root）的结点；\\
（2）当 $n>1$ 时，除根结点之外的其余结点被分成 $m(m>0)$ 个互不相交的有限集合 $T_{1}, T_{2}, \cdots, T_{m}$ ，其中每个集合又是一棵树 ${ }^{(2)}$ ，并称为这个根结点的子树（subtree）。

图 5－3（a）是一棵具有 9 个结点的树，$T=\{A, B, C, D, E, F, G, H, I\}$ ，结点 $A$ 为树 $T$ 的根结点，除根结点 $A$ 之外的其余结点分为两个不相交的集合：$T_{1}=\{B, D, E, F$ ， $I\}$ 和 $T_{2}=\{C, G, H\}, T_{1}$ 和 $T_{2}$ 构成了根结点 $A$ 的两棵子树。子树 $T_{1}$ 的根结点为 $B$ ，其余结点又分为三个不相交的集合：$T_{11}=\{D\}, T_{12}=\{E, I\}$ 和 $T_{13}=\{F\}, T_{11} 、 T_{12}$ 和 $T_{13}$ 构成了根结点 $B$ 的三棵子树。以此类推，直到每棵子树只有一个根结点为止。

需要强调的是，树中根结点的子树之间是互不相交的。例如，图5－3（b）由于根结点 $A$的两个子树之间存在交集，结点 $E$ 既属于集合 $T_{1}$ 又属于集合 $T_{2}$ ，所以不是树；图 5－3（c）中根结点 $A$ 的两个子树之间也存在交集，边 $(B, C)$ 依附的两个结点属于根结点 $A$ 的两个子集 $T_{1}$ 和 $T_{2}$ ，所以也不是树。

\footnotetext{（1）从数学角度讲，树结构是图的特例，无回路的连通图就是树，称为自由树（free tree），也是有根树（rooted tree）。本章讨论的是有序树，所谓有序树是指根结点的子树从左到右是有顺序的。\\
（2）显然，树的定义是递归的。由于树结构本身具有递归特性，因此，对树的操作通常采用递归方法。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-143}

图 5－3 树结构和非树结构的示意图

\section*{2．树的基本术语}
（1）结点的度、树的度\\
某结点所拥有的子树的个数称为该结点的度（degree）；树中各结点度的最大值称为该树的度。如图5－3（a）所示的树中，结点 $A$ 的度为 2 ，结点 $B$ 的度为 3 ，该树的度为 3 。\\
（2）叶子结点、分支结点\\
度为 0 的结点称为叶子结点（leaf node），也称为终端结点；度不为 0 的结点称为分支结点（branch node），也称为非终端结点。如图5－3（a）所示的树中，结点 $D 、 I 、 F 、 G$ 和 $H$是叶子结点，其余结点都是分支结点。\\
（3）孩子结点、双亲结点、兄弟结点\\
某结点的子树的根结点称为该结点的孩子结点（child node）；反之，该结点称为其孩子结点的双亲结点（parent node）；具有同一个双亲的孩子结点互称为兄弟结点（brother node）。如图5－3（a）所示的树中，结点 $B$ 是结点 $A$ 的孩子结点，结点 $A$ 是结点 $B$ 的双亲结点，结点 $B$ 和 $C$ 互为兄弟结点，结点 $I$ 没有兄弟结点。\\
（4）路径、路径长度\\
如果树的结点序列 $n_{1} n_{2} \cdots n_{k}$ 满足如下关系：结点 $n_{i}$ 是结点 $n_{i+1}$ 的双亲 $(1 \leqslant i<k)$ ，则 $n_{1} n_{2} \cdots n_{k}$ 称为一条由 $n_{1}$ 至 $n_{k}$ 的路径（path）；路径上经过的边数称为路径长度（path length）。显然，在树中路径是唯一的。如图5－3（a）所示的树中，从结点 $A$ 到结点 $I$ 的路径是 $A B E I$ ，路径长度为 3 。\\
（5）祖先、子孙\\
如果从结点 $x$ 到结点 $y$ 有一条路径，那么 $x$ 就称为 $y$ 的祖先（ancestor），$y$ 称为 $x$ 的子孙（descendant）。显然，以某结点为根的子树中的任一结点都是该结点的子孙。如图 5－3（a）所示的树中，结点 $A 、 B 、 E$ 均为结点 $I$ 的祖先，结点 $B$ 的子孙有 $D 、 E 、 F 、 I$ 。\\
（6）结点的层数、树的深度（高度）、树的宽度\\
规定根结点的层数（level）为 1 ，对其余任何结点，若某结点在第 $k$ 层，则其孩子结点在第 $k+1$ 层；树中所有结点的最大层数称为树的深度（depth），也称为树的高度；树中每一层结点个数的最大值称为树的宽度（breadth）。如图 5－3（a）所示的树中，结点 $D$ 的层数

为 3 ，树的深度为 4 ，树的宽度为 5 。

\section*{5．2．2 树的抽象教据类型定义}
树的应用很广泛，在不同的实际应用中，树的基本操作不尽相同。下面给出一个树的抽象数据类型定义的例子，简单起见，基本操作只包含树的遍历。

\begin{verbatim}
ADT Tree
DataModel
    树由一个根结点和若干棵子树构成,树中结点具有层次关系
Operation
    InitTree
        输人:无
        功能:初始化一樏树
        输出:一个空树
    DestroyTree
        输人:无
        功能:销毁一檪树
        输出:释放该树占用的存储空间
    Preorder
        输人:无
        功能;前序遍历树
        输出:树的前序遍历序列
    PostOrder
        输人;无
        功能:后序遍历树
        输出:树的后序遍历序列
    LeverOrder
        输人:无
        功能:层序透历树
        输出:树的层序遍历序列
endADT
\end{verbatim}

\section*{5．2．3 树的遍历橾作}
树的遍历（traverse）是指从根结点出发，按照某种次序访问树中所有结点，使得每个结点被访问一次且仅被访问一次。访问是一种抽象操作，在实际应用中，可以是对结点进行的各种处理，比如输出结点的信息、修改结点的某些数据等，对应到算法上，访问可以是一条简单语句，可以是一个复合语句，也可以是一个模块。不失一般性，在此将访问定义为输出结点的数据信息。树的遍历次序通常有前序（根）遍历和后序（根）遍历两种方式，此外，如果按树的层序依次访问各结点，则可得到另一种遍历次序：层序遍历。

树的前序遍历操作定义为：若树为空，则空操作返回；否则执行以下操作。\\
（1）访问根结点；\\
（2）按照从左到右的顺序前序遍历根结点的每一棵子树。\\
树的后序遍历操作定义为：若树为空，则空操作返回；否则执行以下操作。\\
（1）按照从左到右的顺序后序遍历根结点的每一棵子树；\\
（2）访问根结点。\\
树的层序遍历也称树的广度遍历，其操作定义为：从树的根结点开始，自上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

例如，图 5－3（a）所示树的前序遍历序列为：ABDEIFCGH，后序遍历序列为：D IEFBGHCA，层序遍历序列为：ABCDEFGHI。

\section*{5.3 树的存储结构}
在大量的实际应用中，人们使用多种存储方法来表示树。无论采用何种存储方法，都要求存储结构不仅能存储树中各结点的数据信息，还要表示结点之间的逻辑关系——父子关系。下面介绍几种基本的存储方法。

\section*{5．3．1 双亲表示法}
由树的定义可知，除根结点外，树中每个结点都有且仅有一个双亲结点，根据这一特性，可以用一维数组来存储树的各个结点（一般按层序存储），数组中的一个元素对应树中的一个结点，数组元素包括树中结点的

\begin{center}
\begin{tabular}{|c|c|}
\hline
data & parent \\
\hline
\end{tabular}
\end{center}

图 5－4 双亲表示法的数组元素数据信息以及该结点的双亲在数组中的\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-145(1)}下标。树的这种存储方法称为双亲表示法（parent expression），数组元素的结构如图 5－4 所示。其中，data存储树中结点的数据信息；parent 存储该结点的双亲在数组中的下标。数组元素的结构体类型定义如下。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-145(2)}

例如，图 5－3（a）所示树采用双亲表示法的存储示意图

\begin{center}
\begin{tabular}{c|c|c|}
下标 & \multicolumn{1}{c}{data} & \multicolumn{1}{c}{parent} \\
\cline { 2 - 3 }
0 & $A$ & -1 \\
\cline { 2 - 3 }
1 & $B$ & 0 \\
\hline
2 & $C$ & 0 \\
\hline
3 & $D$ & 1 \\
\hline
4 & $E$ & 1 \\
\hline
5 & $F$ & 1 \\
\hline
6 & $G$ & 2 \\
\hline
7 & $H$ & 2 \\
\hline
8 & $I$ & 4 \\
\hline
\end{tabular}
\end{center}如图 5－5 所示，图中 parent 域的值为 -1 表示该结点无双 图 5－5 双亲表示法的存储示意图亲，即该结点是根结点。

\section*{5．3．2 孩子表示法}
树的孩子表示法（child express）是一种基于链表的存储方法，即把每个结点的孩子排列起来，看成是一个线性表，且以单链表存储，称为该结点的孩子链表，则 $n$ 个结点共有 $n$ 个孩子链表（叶子结点的孩子链表为空\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-145}

表）。 $n$ 个孩子链表共有 $n$ 个头指针，这 $n$ 个头指针又构成了一个线性表，为了便于进行查找操作，可采用顺序存储。最后，将存放 $n$ 个头指针的数组和存放 $n$ 个结点数据信息的数组结合起来，构成孩子链表的表头数组。所以在孩子表示法中，存在两类结点：孩子结点和表头结点，其结点结构如图 5－6 所示，结点的结构体类型定义如下。

\begin{center}
\begin{tabular}{|c|c|}
\hline
child & next \\
\hline
\end{tabular}
\end{center}

（a）孩子结点

\begin{center}
\begin{tabular}{|c|c|}
\hline
data & firstChild \\
\hline
\end{tabular}
\end{center}

（b）表头结点

图 5－6 孩子表示法的结点结构\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-146(1)}

例如，图 5－7是图 5－3（a）所示树采用孩子表示法的存储示意图。孩子表示法不仅表示了孩子结点的信息，而且链在同一个孩子链表中的结点具有兄弟关系。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-146}

图 5－7 孩子表示法的存储示意图

\section*{5．3．3 孩子兄弟表示法}
树的孩子兄弟表示法（children brother expression）又称为二叉链表表示法，其方法是链表中的每个结点除数据域外，还设置了两个指针分别指向该结点的第一个孩子和右兄弟，链表的结点结构如图 5－8 所示。其中，data 存储该结点的数据信息；firstchild 存储该结点的第一个孩子结点

的存储地址；rightsib 存储该结点的右兄弟结点的存储地址。孩子兄弟表示法的结点定义如下：

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
firstChild & data & rightSib \\
\hline
\end{tabular}
\end{center}

图 5－8 孩子兄弟表示法的结点结构

\begin{verbatim}
template <typename DataType>
struct TNode
f
    DataType data;
    TNode<DataType> * firstChild, * rightSib;
};
\end{verbatim}

例如，图 5－9 是图 5－3（a）所示树采用孩子兄弟表示法的存储示意图，这种存储方法便于实现树的各种操作。例如，若要访问某结点 $x$ 的第 $i$ 个孩子，只需从该结点的第一个孩子指针找到第 1 个孩子后，沿着孩子结点的右兄弟域连续走 $i-1$ 步，便可找到结点 $x$ 的第 $i$ 个孩子。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-147(1)}

图 5－9 树的孩子兄弟表示法的存储示意图

\section*{5.4 二叉树的逻辑结构}
树结构有很多变种，二叉树是一种最简单的树结构，而且任何树都可以简单地转换为对应的二叉树。所以，二叉树是本章的重点。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-147}

5．4．1 二叉树的定义\\
二叉树（binary tree）是 $n(n \geqslant 0)$ 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树（left subtree）和右子树（right subtree）的二叉树组成。观察图 5－10 所示的一棵\\
图 5－10 一棵二叉树二叉树，可以发现二叉树具有如下特点：\\
（1）每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点；\\
（2）二叉树的左右子树不能任意颠倒，如果某结点只有一棵子树，一定要指明它是左子树还是右子树。

需要强调的是，二叉树和树是两种不同的树结构。首先，二叉树不是度为 2 的树。例如图 5－11（a）所示是一棵二叉树，但这棵二叉树的度是 1 ；假设图 5－11（b）是一棵度为 2 的树，则结点 $B$ 是结点 $A$ 的第一个孩子，结点 $C$ 是结点 $A$ 的第二个孩子，并且可以为结点 $A$ 再增加孩子。其次，树的孩子只有序的关系，即第 1 个孩子，第 2 个孩子，$\cdots$ ，第 $i$ 个孩子，但二叉树的孩子却有左右之分，即使二叉树中某结点只有一个孩子，也要区分它是左孩子还是右孩子。例如，假设图 5－11（c）所示是二叉树，则它们是两棵不同的二叉树，假设图 5－11（d）所示是树，则它们是同一棵树。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-148(1)}

图 5－11 二叉树和树是两种树结构\\
实际应用中，经常用到如下几种特殊的二叉树。\\
（1）斜树\\
所有结点都只有左子树的二叉树称为左斜树 （left oblique tree）；所有结点都只有右子树的二叉树称为右斜树（right oblique tree）；左斜树和右斜树统称为斜树（oblique tree），如图 5－12 所示。斜树的特点是：（1）每一层只有一个结点；（2）斜树的结点个数与其深度相同。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-148}

图 5－12 斜树示例\\
（2）满二叉树\\
在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树（full binary tree）。图5－13（a）是一棵满二叉树，（b）不是满二叉树 ${ }^{(1)}$ ，因为，虽然所有分支结点都存在左右子树，但叶子不在同一层上。满二叉树的特点是：（1）叶子只能出现在最下一层；（2）只有度为 0 和度为 2 的结点。\\
（3）完全二叉树\\
对一棵具有 $n$ 个结点的二叉树按层序编号，如果编号为 $i(1 \leqslant i \leqslant n)$ 的结点与同样深度的满二叉树中编号为 $i$ 的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树（complete binary tree）。显然，一棵满二叉树必定是一棵完全二叉树。完全二叉树的特点是：（1）深度为 $k$ 的完全二叉树在 $k-1$ 层是满二叉树；（2）叶子结点只能出现在最下两层，且最下层的叶子结点都集中在左侧连续的位置；（3）如果有度为 1 的结点，只可能

\footnotetext{（1）所有分支结点都存在左右子树的二叉树称为正则二叉树（regular binary tree），也称为严格二叉树。在正则二叉树中只有度为 0 和度为 2 的结点。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-149}

图 5－13 满二叉树和非满二叉树示例\\
有一个，且该结点只有左孩子。图 5－14 是完全二叉树和非完全二叉树的示例。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-149(1)}

图 5－14 完全二叉树和非完全二叉树示例

\section*{5．4．2 二叉树的基本性质}
性质 5－1 在一棵二叉树中，如果叶子结点的个数为 $n_{0}$ ，度为 2 的结点个数为 $n_{2}$ ，则 $n_{0}=n_{2}+1$ 。

证明：设 $n$ 为二叉树的结点总数，$n_{1}$ 为二叉树中度为 1 的结点个数，因为二叉树中所有结点的度均小于或等于 2 ，则有：


\begin{equation*}
n=n_{0}+n_{1}+n_{2} \tag{5-1}
\end{equation*}


考虑二叉树中的分枝数。除了根结点外，其余结点都有唯一的分枝进人，因此，对于有 $n$ 个结点的二叉树，其分枝数为 $n-1$ 。这些分枝是由度为 1 和度为 2 的结点射出的，一个度为 1 的结点射出一个分枝，一个度为 2 的结点射出两个分枝，所以有：


\begin{equation*}
n-1=n_{1}+2 n_{2} \tag{5-2}
\end{equation*}


由式（5－1）和式（5－2）可以得到：

$$
n_{0}=n_{2}+1
$$

性质 5－2 二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点 $(i \geqslant 1)$ 。\\
证明：采用归纳法证明。\\
当 $i=1$ 时，只有一个根结点，而 $2^{i-1}=2^{0}=1$ ，结论显然成立。\\
假设 $i=k$ 时结论成立，即第 $k$ 层上最多有 $2^{k-1}$ 个结点。\\
考虑 $i=k+1$ 时的情形。由于第 $k+1$ 层上的结点是第 $k$ 层上结点的孩子，而二叉树

中每个结点最多有两个孩子，故在第 $k+1$ 层上的最大结点个数为第 $k$ 层上的最大结点个数的两倍，即第 $k+1$ 层最多有 $2 \times 2^{k-1}=2^{k}$ 个结点，则在 $i=k+1$ 时结论也成立。

由此，结论成立。\\
性质 5－3 在一棵深度为 $k$ 的二叉树中，最多有 $2^{k}-1$ 个结点。\\
证明：设深度为 $k$ 的二叉树中最多有 $n$ 个结点，由性质5－1可知：

$$
n=\sum_{i=1}^{k}(\text { 第 } i \text { 层上结点的最大个数 })=\sum_{i=1}^{k} 2^{i-1}=2^{k}-1
$$

显然，具有 $2^{k}-1$ 个结点的二叉树是满二叉树，且满二叉树的深度 $k=\log _{2}(n+1)$ 。\\
性质 5－4 具有 $n$ 个结点的完全二叉树的深度为 $\left\lfloor\log _{2} n\right\rfloor+1$ 。\\
证明：设具有 $n$ 个结点的完全二叉树的深度为 $k$ ，如图 5－15 所示，根据完全二叉树的定义和性质 5－3，完全二叉树的结点个数满足如下不等式：


\begin{equation*}
2^{k-1} \leqslant n<2^{k} \tag{5-3}
\end{equation*}


对不等式（5－3）取对数，有：

$$
k-1 \leqslant \log _{2} n<k
$$

即：

$$
\log _{2} n<k \leqslant \log _{2} n+1
$$

由于 $k$ 是整数，故必有 $k=\left\lfloor\log _{2} n\right\rfloor+1$ 。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-150}

图 5－15 深度为 $k$ 的完全二叉树中结点个数的范围\\
性质 5－5 对一棵具有 $n$ 个结点的完全二叉树从 1 开始按层序编号，则对于编号为 $i$ $(1 \leqslant i \leqslant n)$ 的结点（简称为结点 $i$ ），有如下关系成立：\\
（1）如果 $i>1$ ，则结点 $i$ 的双亲的编号为 $\lfloor i / 2\rfloor$ ；否则结点 $i$ 是根结点，无双亲。\\
（2）如果 $2 i \leqslant n$ ，则结点 $i$ 的左孩子的编号为 $2 i$ ；否则结点 $i$ 无左孩子。\\
（3）如果 $2 i+1 \leqslant n$ ，则结点 $i$ 的右孩子的编号为 $2 i+1$ ；否则结点 $i$ 无右孩子。\\
证明：在证明过程中，可以从（2）和（3）推出（1），所以先证明（2）和（3）。采用归纳法证明。\\
当 $i=1$ 时，结点 $i$ 就是根结点，因此无双亲；由完全二叉树的定义，其左孩子是结点 2 ，若 $2>n$ ，即不存在结点 2 ，此时，结点 $i$ 无左孩子；结点 $i$ 的右孩子是结点 3 ，若结点 3 不存在，即 $3>n$ ，此时结点 $i$ 无右孩子。

假设 $i=k$ 时结论成立，下面讨论 $i=k+1$ 的情形。设第 $\left.j\left(1 \leqslant j<\log _{2} n\right\rfloor+1\right)$ 层上某个结点编号为 $i\left(2^{j-1} \leqslant i<2^{j}\right)$ ，其左孩子为 $2 i$ ，右孩子为 $2 i+1$ ，如果结点 $i$ 不是第 $j$ 层最后一个结点，则结点 $i+1$ 是结点 $i$ 的右兄弟或堂兄弟；如果结点 $i$ 是第 $j$ 层最后一个结点，则结点 $i+1$ 是第 $j+1$ 层的第一个结点。若结点 $i+1$ 有左孩子，则左孩子的编号必定为 $2 i+2=2 \times(i+1)$ ；若结点 $i+1$ 有右孩子，则右孩子的编号必定为 $2 i+3=2 \times(i+1)$ +1 ，如图 5－16 所示。

当 $i>1$ 时，如果 $i$ 为左孩子，即 $2 \times(i / 2)=i$ ，则 $i / 2$ 是 $i$ 的双亲；如果 $i$ 为右孩子，则\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-151}

图 5－16 归纳情况的证明\\
$i=2 j+1$ ，即结点 $i$ 的双亲应为 $j$ ，而 $j=(i-1) / 2=\lfloor i / 2\rfloor$ 。

\section*{5．4．3 二叉树的抽象数据类型定义}
同树类似，在不同的应用中，二叉树的基本操作不尽相同。下面给出一个二叉树抽象数据类型定义的例子，简单起见，基本操作只包含二叉树的遍历。

\begin{verbatim}
ADT BiTree
DataModel
    二叉树由一个根结点和两棵互不相交的左有子树构成, 二叉树中的结点具有层次关系
Operation
    InitBiTree
        输人: 无
        功能 : 初始化一棵二叉树
        输出: 一个空的二叉树
    CreatBiTree
        输人: $n$ 个结点的数据及结点之间的关系
        功能; 建立一棵二叉树
        输出: 含有 $n$ 个结点的二叉树
    DestroyBitree
        输人: 无
        功能: 销毁一棵二叉树
        输出: 释放二叉树占用的存储空间
    Preorder
        输人: 无
        功能: 前序遍历二叉树
        输出: 二叉树的前序遍历序列
    InOrder
        输人: 无
        功能; 中序遍历二叉树
        输出: 二叉树的中序遍历序列
    Postorder
        输人: 无
        功能: 后序遍历平树
        输出: 二叉树的后序遍历序列
\end{verbatim}

\begin{verbatim}
    LevelOrder
        输入:无
        功能:层序通历二叉树
        输出: 二叉树的层序遗历序列
endADT
\end{verbatim}

\section*{5．4．4 二叉树的遍历操作}
二叉树的遍历（traverse）是指从根结点出发，按照某种次序访问 ${ }^{(1)}$ 二又树中的所有结点，使得每个结点被访问一次且仅被访问一次。二叉树由根结点（D）、根结点的左子树 （L）和根结点的右子树（R）三部分组成，只要依次遍历这三部分，就可以遍历整个二叉树。这三部分共有六种全排列，分别是 DLR、LDR、LRD、DRL、RDL 和 RLD，不失一般性，约定先左子树后右子树，则有前序（根）遍历、中序（根）遍历和后序（根）遍历。如果按二叉树的层序依次访问各结点，可得到另一种遍历次序：层序遍历。

前序遍历二叉树的操作定义为：若二叉树为空，则空操作返回；否则执行下述操作。\\
（1）访问根结点；\\
（2）前序遍历根结点的左子树；\\
（3）前序遍历根结点的右子树。\\
中序遍历二叉树的操作定义为：若二叉树为空，则空操作返回；否则执行下述操作。\\
（1）中序遍历根结点的左子树；\\
（2）访问根结点；\\
（3）中序遍历根结点的右子树。\\
后序遍历二叉树的操作定义为：若二叉树为空，则空操作返回；否则执行下述操作。\\
（1）后序遍历根结点的左子树；\\
（2）后序遍历根结点的右子树；\\
（3）访问根结点。\\
层序遍历二叉树的操作定义为：从二叉树的根结点开始，从上至下逐层遍历，同一层按从左到右的顺序对结点逐个访问。

例如，图 5－10 所示二叉树的前序遍历序列为 $A B D G C E F$ ，中序遍历序列为 $D G B A E C F$ ，后序遍历序列为 $G D B E F C A$ ，层序遍历序列为 $A B C D E F G$ 。

任意一棵二叉树的遍历序列都是唯一的，反过来，前序、中序和后序遍历序列中的任何一个都不能唯一确定这棵二叉树，但是，前序遍历序列和中序遍历序列能唯一确定这棵二叉树。例如，已知一棵二叉树的前序遍历序列和中序遍历序列分别为 $A B C D E F G H$ 和 $C D B A F E H G$ ，首先，由前序序列可知，结点 $A$ 是二叉树的根结点。其次，根据中序序列，在 $A$ 之前的所有结点都是结点 $A$ 的左子树的结点，在 $A$ 之后的所有结点都是结点 $A$ 的右子树的结点，如图 5－17（a）所示，由此得到图 5－17（b）的状态。结点 $A$ 的左子树的前序

\footnotetext{（1）此处访问的含义同树的遍历中访问的含义。
}序列是 $B C D$ ，所以结点 $B$ 是左子树的根结点，结点 $A$ 的左子树的中序序列是 $C D B$ ，则 $B$之前的结点 $C D$ 是 $B$ 的左子树的结点，$B$ 的右子树为空，以此类推，分别对左右子树进行分解，得到图 5－17（c）的二叉树。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-153(1)}

图 5－17 二叉树的构造过程示例\\
显然，由二叉树的后序遍历序列和中序遍历序列也能唯一确定这棵二叉树，例如，已知一棵二叉树的后序遍历序列和中序遍历序列分别为 DCBFHGEA 和 CDBAFEHG，请读者参照图 5－17 构造这棵二叉树。

\section*{5.5 二叉树的存储结构}
存储二叉树的关键是如何表示结点之间的逻辑关系，也就是双亲和左右孩子之间的关系。在具体应用中，可能要求从任一结点能够直接访问它的孩子，或直接访问它的双亲，或同时访问其双亲和孩子。

\section*{5．5．1 顺序存储结构}
二叉树的顺序存储结构是用一维数组存储二叉树的结点，用结点的存储位置（下标）表示结点之间的逻辑关系——父子关系。由于二叉树本身不具有顺序关系，所以二叉树的顺序存储结构要解决的关键问题是如何利用数组下标来反映结点之间的父子关系。由二叉树的性质 5－5 可知，完全二\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-153}

电子课件叉树中结点的层序编号可以唯一地反映结点之间的逻辑关系，对于一般的二叉树，可以按照完全二叉树进行层序编号，然后再用一维数组顺序存储。具体步骤如下：\\
（1）将二叉树按完全二叉树编号。根结点的编号为 1 ，若某结点 $i$ 有左孩子，则其左孩子的编号为 $2 i$ ；若某结点 $i$ 有右孩子，则其右孩子的编号为 $2 i+1$ 。\\
（2）将二叉树的结点按照编号顺序存储到一维数组中 ${ }^{(1)}$ 。\\
图 5－18 给出了一棵二叉树的顺序存储示意图。显然，这种存储方法的缺点是浪费存储空间，最坏情况是右斜树，一棵深度为 $k$ 的右斜树只有 $k$ 个结点，却须分配 $2^{k}-1$ 个存储单元。事实上，二叉树的顺序存储结构一般仅适合于存储完全二叉树。

\footnotetext{（1）这种存储方法浪费下标为 0 的数组单元，但结点编号和数组下标具有一一对应关系。如果从数组下标 0 开始存储，则编号为 $i$ 的结点存储到下标为 $i-1$ 的位置。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-154}

下标：

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 \\
\hline
$A$ & $B$ & $C$ & $\wedge$ & $D$ & $E$ & $\wedge$ & $\wedge$ & $\wedge$ & $F$ & $\wedge$ & $\wedge$ & $G$ \\
\hline
\end{tabular}
\end{center}

（c）二叉树的顺序存储\\
图 5－18 二叉树及其顺序存储示意图

\section*{5．5．2 二叉链表}
\section*{1．二叉链表的存储结构}
二叉树一般采用二叉链表（binary linked list）存储，其基本思想是：令二叉树的每个结点对应一个链表结点，链表结点除了存放二叉树结点的数据信息外，还要存放指示左右孩子的指针。二叉链表的结点结构如图 5－19 所示，其中 data 存放该结点的数据信息；lchild 存放指向左孩子的指针；rchild 存放指向右孩子的指针。下面给出二叉链表的结点结构定义，图 5－10 所示二叉树的二叉链表存储如图 5－20 所示。

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Ichild & data & rchild \\
\hline
\end{tabular}
\end{center}

图 5－19 二叉树的结点结构\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-154(1)}

图 5－20 二叉链表的存储示意图

\begin{verbatim}
template <typename DataType>
struct BiNode
I
    DataType data;
    BiNode<DataIype> * lchild, * rchild;
};

\section*{2．二叉链表的实现}

将二叉树的抽象数据类型定义在二叉链表存储结构下用 C ++ 语言的类实现。二叉链表类定义如下，其中成员变量 root 为二叉链表的根指针，成员函数实现二叉树的基本操作。为了避免类的调用者访问 BiTree 类的私有变量 root，在构造函数、析构函数以及遍历函数中调用了相应的私有函数，例如，在函数 PreOrder（）中调用了私有函数 PreOrder（root）。
\end{verbatim}

template <typename DataType>\\
class BiTree\\
1\\
public:\\
BiTree()\{root = Creat(); \}\\
\~{}BiTree () \{Release (root) ; \}\\
void PreOrder () \{PreOrder (root) ; \} //前序適历二叉树\\
void InOrder () \{InOrder (root) ; \} //中序通历二叉树\\
void PostOrder () \{PostOrder (root) ; \} //后序遍历二叉树\\
void LeveIorder () ; //层序遍历二叉树\\
private:\\
BiNode<DataType> * Creat (); //构造函数调用\\
void Release (BiNode<DataType> *bt); //析构函数调用\\
void PreOrder (BiNode<DataType> *bt); $\quad / /$ 前序遍历函数调用\\
void InOrder (BiNode<DataType> *bt); //中序遍历函数调用\\
void PostOrder (BiNode<DataType> *bt); //后序遍历函数调用\\
BiNode<DataType> * root; //指向根结点的头指针\\
);

\begin{verbatim}

由于树结构本身是递归定义的，因此，对二叉树的操作大都采用递归函数实现，下面讨论二叉链表存储结构下基本操作的实现。
（1）前序遍历
由二叉树前序遍历的操作定义，容易写出前序遍历的递归实现，成员函数定义如下，对于图 5－21 所示二叉树，前序遍历递归函数的调用过程如图 5－22 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-155.jpg?height=253&width=289&top_left_y=1546&top_left_x=1329)

图 5－21 一棵二叉树
\end{verbatim}

template <typename DataType>\\
void BiTree<DataType> :: PreOrdex (BiNode<DataType> * bt)\\
\{\\
if (bt == nullptr) return; //递归调用的结束条件\\
else \{\\
cout<<bt->data<<"\textbackslash t"; //访问根结点bt的数据域\\
PreOrder (bt->lchild); //前序递归遍历五bt的左子树\\
PreOrder (bt->rchild); //前序递归遍历另bt的右子树\\
\}\\
|

\begin{verbatim}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-156.jpg?height=550&width=1373&top_left_y=240&top_left_x=71)

图 5－22 二叉树前序遍历的递归调用过程
（2）中序遍历
根据二叉树中序遍历的操作定义，访问结点的操作发生在该结点的左子树遍历完毕且尚未遍历右子树时，所以，中序遍历的递归实现只需将输出操作 cout $\ll \mathrm{bt}->\mathrm{data}$放到递归遍历左子树之后即可。
（3）后序遍历
根据二叉树后序遍历的操作定义，访问结点的操作发生在该结点的左子树和右子树均遍历完毕，所以，后序遍历的递归实现只需将输出操作 cout $\ll \mathrm{bt}->$ data 放到递归遍历右子树之后即可。
（4）层序遍历
在进行层序遍历时，访问某一层的结点后，再对各个结点的左孩子和右孩子顺序访问，这样一层一层进行，先访问的结点其左右孩子也要先访问，这符合队列的操作特性。因此，在进行层序遍历时，设置一个队列存放已访问的结点。对于图 5－10 所示二叉树，层序遍历的执行过程如图 5－23 所示，算法用伪代码描述如下：

算法：LevelOrder
输人：无
输出：层序遍历序列
1．队列 Q 初始化；
2．如果二叉树非空，将根指针人队；
3．循环直到队列 $Q$ 为空
$3.1 \mathrm{q}=$ 队列 Q 的队头元素出队；
3.2 访问结点 q 的数据域；
3.3 若结点 $q$ 存在左孩子，则将左孩子指针人队；
3.4 若结点 $q$ 存在右孩子，则将右孩子指针人队；

简单起见，队列采用顺序队列，并且假定不会发生假溢出，注意队列 Q 的元素类型是指向二叉链表结点的指针，层序遍历的成员函数定义如下：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-157.jpg?height=1173&width=1398&top_left_y=209&top_left_x=311)
（5）构造函数——建立二叉树
建立二叉树可以有多种方法，一种较为简单的方法是根据一个结点序列来建立二叉树。由于前序、中序和后序序列中的任何一个都不能唯一确定一棵二叉树，因此不能直接使用。可以对二叉树做如下处理：将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值（如 \＃），以标识其为空，把这样处理后的二叉树称为原二叉树的扩展二叉树（extended binary tree）。图 5－24 给出了一棵二叉树的扩展二叉树，以及该扩展二叉树的前序遍历序列。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-157.jpg?height=268&width=277&top_left_y=1763&top_left_x=351)
（a）一棵二叉树
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-157.jpg?height=370&width=389&top_left_y=1763&top_left_x=688)
（b）扩展二叉树

AB\＃D\＃\＃C\＃\＃
（c）扩展二叉树的前序遍历序列

图 5－24 扩展二叉树及其遍历序列
扩展二叉树的一个遍历序列就能唯一确定一棵二叉树。为简化问题，设二叉树中的结点均为一个字符，扩展二叉树的前序遍历序列由键盘输人，root 为指向根结点的指针，

二叉链表的建立过程是：首先输人根结点，若输人的是\＃字符，则表明该二叉树为空树，即 root $=$ nullptr；否则输人的字符应该赋给 bt $->$ data，之后依次递归建立它的左子树和右子树。成员函数定义如下：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-158.jpg?height=702&width=1385&top_left_y=414&top_left_x=103)
（6）析构函数——销毁二叉树
二叉链表是动态存储分配，二叉链表的结点是在程序运行过程中动态申请的，在二叉链表变量退出作用域前，要释放二叉链表的存储空间。可以对二叉链表进行后序遍历，在访问结点时进行释放处理。析构函数定义如下：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-158.jpg?height=501&width=1391&top_left_y=1361&top_left_x=95)

\section*{3．二叉链表的使用}

在定义了二叉链表类 BiTree 并实现了二叉树的基本操作后，程序中就可以使用 BiTree 类来定义变量，可以调用实现基本操作的函数来完成相应功能，范例程序如下：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-158.jpg?height=315&width=1388&top_left_y=2107&top_left_x=94)
\end{verbatim}

l\\
BiTree<char>T\{ \}; //定义对象变量T\\
cout<<"该二叉树的前序遍历序列是:";\\
T.PreOrder () ;\\
cout <<"\textbackslash n该二叉树的中序遍历序列是:";\\
T. InOrder () ;\\
cout <<n\textbackslash n 该二又树的后序遍历序列是:";\\
T.PostOrder();\\
cout<<"\textbackslash n该二叉树的层序遍历序列是:";\\
T.LevelOrder();\\
return 0;\\
\}

\begin{verbatim}

\section*{5．5．3 三叉链表}

在二叉链表存储方式下，从某结点出发可以直接访问到它的孩子结点，但要找到它的双亲结点，则需要从根结点开始搜索，最坏情况需要遍历整个二叉链表。此时，应该采用三叉链表（trident linked list）存储二叉树。在三叉链表中，每个结点由四个域组成，结点结构如图 5－25 所示，其中，data、lchild 和 rchild 三个域的含义同二叉链表的结点结构；parent 域为指向该结点的双亲结点的指针。三叉链表的结点
\begin{tabular}{|l|l|l|l|}
\hline lchild & data & rchild & parent \\
\hline
\end{tabular}

图 5－25 三叉链表的结点结构结构定义如下：
\end{verbatim}

template <typename DataType>\\
struct TriNode\\
f\\
DataIype data;\\
TriNode<DataType> * lchild, * rchild, * parent;\\
\};

\begin{verbatim}

例如，图 5－26 给出了图 5－10 所示二叉树的三叉链表示意。这种存储结构既便于查找孩子结点，又便于查找双亲结点。但是，相对于二叉链表而言，它增加了空间开销。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-159.jpg?height=445&width=901&top_left_y=1848&top_left_x=503)

图 5－26 三叉链表的存储示意图

\section*{5.6 森 林}

\section*{5．6．1 森林的逻辑结构}

森林（forest）是 $m(m \geqslant 0)$ 棵互不相交的树的集合。图5－27所示是一个由三棵树构成的森林。需要强调的是，森林是由树构成的，图 5－27 中的第三棵树是度为 2 的树而不是二叉树。任何一棵树，删去根结点就变成了森林。例如，图 5－3（a）所示的树中，删去根结点 $A$ 就变成了由两棵树构成的森林。反之，若增加一个根结点，将森林中的每一棵树作为这个根结点的子树，则森林就变成了一棵树。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-160.jpg?height=312&width=843&top_left_y=826&top_left_x=392)

图 5－27 由三棵树构成的森林
如何遍历一个森林呢？由于森林由 $m$ 棵树构成，因此，只要依次遍历这 $m$ 棵树就可以遍历整个森林。通常有前序（根）遍历和后序（根）遍历两种方式。前序遍历森林的操作定义是：前序遍历森林中的每一棵树。后序遍历森林的操作定义是：后序遍历森林中的每一棵树。例如，图 5－27 所示森林的前序遍历序列是 ABCDEFGHIJ，后序遍历序列是 BADEFCHJIG。

\section*{5．6．2 树、森林与二叉树的转换}

从物理结构上看，树的孩子兄弟表示法和二叉树的二叉链表是相同的，树的孩子兄弟表示法的第一个孩子指针和右兄弟指针分别相当于二叉链表的左孩子指针和右孩子指针。换言之，给定一棵树，采用孩子兄弟表示法存储，在内存中就对应唯一的一棵二叉树，因此，树和二叉树之间存在一一对
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-160.jpg?height=307&width=251&top_left_y=1524&top_left_x=1305)应关系，可以相互转换。

\section*{1．树转换为二叉树}

将一棵树转换为二叉树的方法是：
（1）加线一一树中所有相邻兄弟结点之间加一条连线；
（2）去线——对树中的每个结点，只保留它与第一个孩子结点之间的连线，删去它与其他孩子结点之间的连线；
（3）层次调整——按照二叉树结点之间的关系进行层次调整。
图 5－28 给出了树转换为二叉树的过程。可以看出，在二叉树中，左分支上的各结点在原来的树中是父子关系，而右分支上的各结点在原来的树中是兄弟关系。由于树的根

结点没有兄弟，所以转换后，二叉树根结点的右子树必为空。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-161.jpg?height=623&width=1477&top_left_y=267&top_left_x=169)

图 5－28 树转换为二叉树的过程
树的遍历序列与对应二叉树的遍历序列之间具有如下对应关系：树的前序遍历序列等于对应二叉树的前序遍历序列，树的后序遍历序列等于对应二叉树的中序遍历序列。例如，图 5－28（a）所示树的前序遍历序列是 $A B E F C D G$ ，后序遍历序列是 $E F B C G D A$ ；图 5－28（d）所示二叉树的前序遍历序列是 $A B E F C D G$ ，中序遍历序列是 $E F B C G D A$ 。

\section*{2．森林转换为二叉树}

将一个森林转换为二叉树的方法是：
（1）将森林中的每棵树转换为二叉树；
（2）将每棵树的根结点视为兄弟，在所有根结点之间加上连线；
（3）按照二叉树结点之间的关系进行层次调整。
图 5－29 给出了森林转换为二叉树的过程。可以看出，转换后，二叉树根结点的右子树不空，并且根结点及其右分支上的结点个数就是原来森林中树的个数。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-161.jpg?height=687&width=1228&top_left_y=1676&top_left_x=309)

图 5－29 森林转换为二叉树的过程

森林的遍历序列与对应二叉树的遍历序列之间具有如下对应关系：森林的前序遍历序列等于对应二叉树的前序遍历序列，森林的后序遍历序列等于对应二叉树的中序遍历序列。例如，图 5－29（a）所示森林的前序遍历序列是 ABCDEFGHIJ，后序遍历序列是 BADEFCHJIG；图5－29（b）所示二叉树的前序遍历序列是 ABCDEFGHIJ，中序遍历序列是 BADEFCHJIG。

\section*{3．二叉树转换为树或森林}

树和森林都可以转换为二叉树，二者不同的是树转换成的二叉树，其根结点无右子树，而森林转换后的二叉树，其根结点有右子树。显然这一转换过程是可逆的，即可以将一棵二叉树还原为树或森林，具体转换方法如下：
（1）加线一 若某结点 $x$ 是其双亲 $y$ 的左孩子，则把结点 $x$ 的右孩子、右孩子的右孩子、 $\cdots$ ，都与结点 $y$ 用线连起来；
（2）去线——删去原二叉树中所有的双亲结点与右孩子结点的连线；
（3）层次调整——整理由（1）、（2）两步所得到的树或森林，使之层次分明。
图 5－30 给出了一棵二叉树还原为森林的过程。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-162.jpg?height=700&width=1299&top_left_y=1111&top_left_x=164)

图 5－30 二叉树转换为森林的过程

\section*{5.7 最优二叉树}

\section*{5．7．1 哈失曼算法}

最优二叉树是由哈夫曼（1）提出，也称哈夫曼树，在实际中有着广泛的
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-162.jpg?height=310&width=254&top_left_y=1956&top_left_x=1311)

\footnotetext{
（1）哈夫曼（David A．Huffman 1925－1999）美国计算机科学家，1949 年从俄亥俄州立大学获得硕士学位，1953年在麻省理工学院获得博士学位。1962 年在麻省理工学院任教授，1967 年到加州大学圣克鲁斯分校创办计算机系。 1982年获得 IEEE 计算机先驱奖，提出的哈大曼编码方法被广泛应用于数据的压缩和传输。
}

应用。下面先介绍几个相关的概念。
叶子结点的权值（weight）是对叶子结点赋予的一个有意义的数值量。设二叉树具有 $n$ 个带权值的叶子结点，从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和称为二叉树的带权路径长度（weighted path length），记为：

$$
\begin{equation*}
W P L=\sum_{k=1}^{n} w_{k} l_{k} \tag{5-4}
\end{equation*}
$$


其中，$w_{k}$ 为第 $k$ 个叶子结点的权值；$l_{k}$ 为从根结点到第 $k$ 个叶子结点的路径长度。
给定一组权值对应的叶子结点，可以构造出形状不同的多棵二叉树。例如，给定 4 个叶子结点，其权值分别为 $\{2,3,4,5\}$ ，图5－31给出了 3 棵不同形状的二叉树，它们具有不同的带权路径长度。带权路径长度最小的二叉树称为最优二叉树（optimal binary tree），也称哈夫曼树（Huffman tree）。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-163.jpg?height=386&width=1492&top_left_y=827&top_left_x=172)

图 5－31 具有 4 个叶子结点和不同带权路径长度的二叉树
根据哈夫曼树的定义，一棵二叉树要使其带权路径长度最小，必须使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点，而且不存在度为 1 的结点。哈夫曼依据这一特点提出了哈夫曼算法，对于给定权值集合 $W=\{2,3,4,5\}$ ，图 5－32 给出了哈夫曼树的构造过程，哈夫曼算法的基本思想用伪代码描述如下：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-163.jpg?height=371&width=1436&top_left_y=1533&top_left_x=205)

图 5－32 哈夫曼树的建立过程

算法：HuffmanTree
输人：n 个权值 $\left\{\mathrm{w}_{1}, \mathrm{w}_{2}, \cdots, \mathrm{w}_{\mathrm{n}}\right\}$
输出：哈夫曼树
1．初始化：由 $\left\{\mathrm{w}_{1}, \mathrm{w}_{2}, \cdots, \mathrm{w}_{\mathrm{n}}\right\}$ 构造 n 棵只有一个根结点的二叉树，从而得到一个二叉树集合 $\mathrm{F}=\left\{\mathrm{T}_{1}, \mathrm{~T}_{2}, \cdots, \mathrm{~T}_{\mathrm{n}}\right\}$ ；
2．重复下述操作，直到集合 F 中只剩下一棵二叉树
2.1 选取与合并：在 F 中选取根结点的权值最小的两棵二叉树分别作为左右子树构造一棵新的二叉树，新根结点的权值为其左右子树根结点的权值之和。
2.2 删除与加人：在 E 中删除作为左右子树的两棵二叉树，并将新建立的二叉树加人到 E 中。

由上述构造过程可以看出，具有 $n$ 个叶子结点的哈夫曼树中有 $n-1$ 个分支结点，它们是在 $n-1$ 次的合并过程中生成的，因此，哈夫曼树共有 $2 n-1$ 个结点。可以设置一个数组 huffTree $[2 n-1]$ 保存哈夫曼树中各结点的信息，为了便于选取根结点权值最小的二叉树以及合并操作，数组元素除了存储结点的权值外，还应存储该结点的双亲以及左右孩子的信息。数组元素的结点结构如图 5－33 所示。其中，weight 保存该结点的权值；lchild 保存该结点的左孩子结点在数组中的下标；rchild 保存该结点的右孩子
\begin{tabular}{|c|c|c|c|}
\hline weight & lchild & rchild & parent \\
\hline
\end{tabular}

图 5－33 哈夫曼树的结点结构结点在数组中的下标；parent 保存该结点的双亲结点在数组中的下标。哈夫曼树的结点结构定义如下：
\end{verbatim}

struct ElemType\\
f\\
int weight; //假定权值为整数\\
int parent, lchild, rchild; //游标\\
);

\begin{verbatim}

首先初始化 $n$ 棵只有根结点的二叉树集合，并将 $n$ 个权值的叶子结点存放到数组 huffTree 的前 $n$ 个分量中，然后不断将两棵子树合并为一棵子树，并将新子树的根结点顺序存放到数组 huffTree 的前 $n$ 个分量的后面。图 5－32 所示哈夫曼树构造过程中存储空间的初始状态和最后状态如图 5－34 所示，哈夫曼算法用伪代码描述如下：
\begin{tabular}{l|c|c|c|c|}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{ weight } & \multicolumn{1}{c}{ parent } & \multicolumn{1}{c}{ lchild } & \multicolumn{1}{c}{ rchild } \\
\cline { 2 - 5 } 0 & 2 & -1 & -1 & -1 \\
\cline { 2 - 5 } 1 & 3 & -1 & -1 & -1 \\
\hline 2 & 4 & -1 & -1 & -1 \\
\hline 3 & 5 & -1 & -1 & -1 \\
\hline 4 & & -1 & -1 & -1 \\
\hline 5 & & -1 & -1 & -1 \\
\hline 6 & & -1 & -1 & -1 \\
\hline
\end{tabular}
（a）初始状态
\begin{tabular}{l|c|c|c|c|} 
& \multicolumn{1}{c}{ weight } & \multicolumn{1}{c}{ parent } & \multicolumn{1}{c}{ lchild } & \multicolumn{1}{c}{ rchild } \\
\cline { 2 - 5 } 0 & 2 & 4 & -1 & -1 \\
\cline { 2 - 5 } 1 & 3 & 4 & -1 & -1 \\
\hline 2 & 4 & 5 & -1 & -1 \\
\hline 3 & 5 & 5 & -1 & -1 \\
\hline 4 & 5 & 6 & 0 & 1 \\
\hline 5 & 9 & 6 & 2 & 3 \\
\hline 6 & 14 & -1 & 4 & 5 \\
\hline
\end{tabular}
（b）最后状态

图 5－34 哈夫曼树构造过程存储空间的状态

算法：HuffmanTree
输人： n 个权值 $\mathrm{w}[\mathrm{n}]$
输出：哈夫曼树 huffTree［2n－1］
1．数组 huffTree 初始化，所有数组元素的双亲、左右孩子都置为 -1 ；

2．数组 huffTree 的前 n 个元素的权值置给定权值；
3．循环变量 $k$ 从 $n \sim n-2$ 进行 $n-1$ 次合并：
3.1 选取两个权值最小的根结点，其下标分别为 $i 1, i 2$ ；
3.2 将二叉树 11 和 12 合并为一棵新的二叉树 $k$ ；

设 n 个叶子的权值保存在数组 $\mathrm{w}[\mathrm{n}]$ 中，Select 函数用来在数组 huff Tree 中选取两个权值最小的根结点并返回根结点的下标 i 1 和 i 2 ，哈夫曼算法的 $\mathrm{C}++$ 描述如下：
\end{verbatim}

void HuffmanTree(ElemType huffTree[], int w[], int n)\\
i\\
int i, k, i1, i2;\\
for (i = 0; i<2\textit{n-1; i++) //所有结点均没有双亲和孩子\\
\{\\[0pt]
huffTree[i].parent = -1;\\[0pt]
huffTree[i].lchild = huffTree[i],rchild = -1;\\
\}\\
for (i = 0; i<n; i++) //存储叶子结点的权值\\[0pt]
huffTree[i] weight = w[i];\\
for (k=n; k<2}n-1; k++) //n-1 次合并\\
\{\\
Select (huffTree, i1, i2); //权值最小的根结点下标为 il 和 i2\\[0pt]
huffTree[k].weight = huffTree[i1].weight + huffTree[i2].weight;\\[0pt]
huffTree[i1].parent = k; huffTree[i2].parent = k;\\[0pt]
huffTree[k].lchild = il; huffTree[k].rchild = i2;\\
\}\\
\}

\begin{verbatim}

\section*{5．7．2 哈夫曼编码}

表示字符集的简单方法是列出所有字符，给每个字符赋予一个二进制位串，称为编码（coding）。假设所有编码都等长，则表示 $n$ 个不同的字符需要 $\left\lceil\log _{2} n\right\rceil$ 位，这称为等长编码（equal－length code）。如果每个字符的使用频率相等，等长编码是空间效率最高的方法。例如，标准 ASCII 码把每个字符分别用一个 7 位二进制数表示，这种方法使用最少的位表示了所有 ASCII 码中的 128 个字符。如果字符出现的频率不等，可以让频率高的字符采用尽可能短的编码，频率低的字符采用稍长的编码，来构造一种不等长编码（unequal－length code），则会获得更好的空间效率，这也是文件压缩技术的核心思想。

对于不等长编码，如果设计得不合理，会给解码（decoding）带来困难。例如 $\{A, B, C$ ， $D, E\}$ 五个字符，使用频率分别为 $\{35,25,15,15,10\}$ ，采用如下编码方案 $\{0,1,01,10,11\}$ ，对于字符串＂$A A B A C D$＂，编码为＂ 00100110 ＂，则可以有多种解码方法，它可以解码为 ＂$A C A A E A$＂，也可以解码为＂$A A D C D$＂。因此，设计不等长编码时，还必须考虑解码的唯一性。如果一组编码中任一编码都不是其他任何一个编码的前缀，则称这组编码为前缀

无歧义编码，简称前缀编码（prefix code），前缀编码保证了解码时不会有多种可能。
哈夫曼树可用于构造最短的不等长编码方案，具体做法如下：设字符集为 $\left\{d_{1}, d_{2}\right.$ ， $\left.\cdots, d_{n}\right\}$ ，它们在字符串中出现的频率为 $\left\{w_{1}, w_{2}, \cdots, w_{n}\right\}$ ，以 $d_{1}, d_{2}, \cdots, d_{n}$ 作为叶子结点，$w_{1}, w_{2}, \cdots, w_{n}$ 作为叶子结点的权值，构造一棵哈夫曼编码树，规定哈夫曼编码树的左分支代表 0 ，右分支代表1，则从根结点到叶子结点所经过的路径组成的 0 和 1 的序列便为该叶子结点对应字符的编码，称为哈夫曼编码（Huffman code）。对于 $\{A, B, C, D$ ， $E\}$ 五个字符，使用的频率分别为 $\{35,25,15,15,10\}$ ，图5－35给出了哈夫曼编码树及哈夫曼编码。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-166.jpg?height=391&width=424&top_left_y=705&top_left_x=265)
（a）哈夫曼编码树
\begin{tabular}{|c|c|c|}
\hline 字符 & 频率 & 编码 \\
\hline$A$ & 35 & 11 \\
\hline$B$ & 25 & 00 \\
\hline$C$ & 15 & 100 \\
\hline$D$ & 15 & 01 \\
\hline$E$ & 10 & 101 \\
\hline
\end{tabular}
（b）字符编码表

图 5－35 哈夫曼编码示例
哈夫曼解码将编码串从左到右逐位判别，直到确定一个字符。具体地，在哈夫曼编码树中，从根结点开始，根据每一位的值是＇0＇还是＇ 1 ＇确定选择左分支还是右分支——直至到达一个叶子结点，然后再从根出发，开始下一个字符的翻译。如对编码串＂ 110100101 ＂进行解码，根据图 5－35 所示哈夫曼编码树，从根结点开始，由于第一位是＇ 1 ＇，所以选择右分支，下一位是＇ 1 ＇，选择右分支，到达叶子结点对应的字符 $A$ ；再从根结点起，下一位是＇ 0 ＇，选择左分支，下一位是＇ 1 ＇，选择右分支，到达叶子结点对应的字符 $D$ ，依次类推，解码为 ＂ADBE＂。

在哈夫曼编码树中，叶子结点的平均深度即是平均编码长度，树的带权路径长度是各个字符的码长与其出现次数的乘积之和，即编码总长度。所以采用哈夫曼树构造的编码是一种能使字符串的编码总长度最短的不等长编码。由于哈夫曼编码树的每个字符结点都是叶子结点，它们不可能在根结点到其他字符结点的路径上，所以一个字符的哈夫曼编码不可能是另一个字符的哈夫曼编码的前缀，从而保证了解码的唯一性。

\section*{5.8 扩展与提高}

\section*{5．8．1 二叉树遍厉的非递归算法}

递归算法虽然简洁，但一般而言，其执行效率不高。因此，有时需要把递归算法转化为非递归算法。对于二叉树的遍历算法，可以仿照递归执行过程中工作栈的状态变化得到非递归算法。

\section*{1．前序遍历非递归算法}

二叉树前序遍历非递归算法的关键是：在前序遍历过某结点的整个左子树后，如何找到该结点的右子树的根指针。对于图 5－36 所示的二叉树，在前序遍历过程中，工作栈 S 和当前根指针 bt 的变化情况以及树中各结点的访问次序如表 5－1 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-167.jpg?height=251&width=276&top_left_y=224&top_left_x=1308)

图 5－36 一棵二叉树

表 5－1 二叉树前序遍历算法的执行过程
\begin{tabular}{|l|l|l|l|l|}
\hline 步骤 & 访问结点 & 桟S 内容 & 指针 bt & 解 释 \\
\hline 初始 & & 空 & A & 栈初始化，准备遍历以 A 为根结点的二叉树 \\
\hline 1 & A & A & B & 访问结点 A，将 A 压栈，准备遍历 A 的左子树 B \\
\hline 2 & B & A，B & $\wedge$ & 访问结点 B，将 B 压栈，准备遍历 B 的左子树 A \\
\hline 3 & & A， & D & B 的左子树为空，弹出栈顶元素 B ，找到 B 的右子树 D ，准备遍历 B 的右子树 D \\
\hline 4 & D & A，D & $\wedge$ & 访问结点 D，将 D 压桟，准备遍历 D 的左子树 $\wedge$ \\
\hline 5 & & A， & $\wedge$ & D 的左子树为空，弹出栈顶元素 D ，找到 D 的右子树 $\wedge$ ，准备遍历 D 的右子树 A \\
\hline 6 & & 空 & $\wedge$ & D 的右子树为空，弹出栈顶元素 A ，找到 A 的右子树 C ，准备遍历 A 的右子树 C \\
\hline 7 & C & C & $\wedge$ & 访问结点 C，将 C 压栈，准备遍历 C 的左子树 A \\
\hline 8 & & 空 & $\wedge$ & C 的左子树为空，弹出栈顶元素 C ，我到 C 的右子树 $\Lambda$ ，准备遍历 C 的右子树 $\wedge$ \\
\hline 9 & & 空 & $\wedge$ & 此时，栈为空并且根指针也为空，遍历结束 \\
\hline
\end{tabular}

分析二叉树前序遍历的执行过程可以看出，在访问某结点后，应将该结点的指针保存在栈中，以便以后能通过它找到该结点的右子树。一般地，在前序遍历中，设要遍历二叉树的根指针为 bt，可能有两种情况：
（1）若 $\mathrm{bt} \neq \mathrm{nullptr}$ ，则表明当前的二叉树不空，此时，应输出根结点 bt 的值并将 bt 保存到栈中，准备继续遍历 bt 的左子树；
（2）若 $\mathrm{bt}=$ nullptr ，则表明以 bt 为根指针的二叉树遍历完毕，并且 bt 是栈顶指针所指结点的左子树。若栈不空，则弹出栈顶指针并根据栈顶指针找到待遍历右子树的根指针并赋予 bt，以继续遍历下去；若栈空，则表明整个二叉树遍历完毕，算法结束。

二叉树前序遍历的非递归算法用伪代码描述如下：

算法：PreOrder
输人：二叉链表的根指针 bt
输出：前序遍历序列
1．栈 S 初始化；
2．循环直到 bt 为空且栈 $S$ 为空

2．1当 $b t$ 不空时循环
2．1．1 输出 $b t->$ data；
2．1．2将指针bt保存到栈中；
2．1．3 准备遍历 bt 的左子树
2.2 如果栈 S 不空，则

2．2．1 将栈顶元素弹出至 $b t$ ；
2．2．2 准备遍历 bt 的右子树；

简单起见，栈采用顺序存储结构并假定不会发生溢出，下面给出二叉树前序遍历成员函数的非递归实现。
\end{verbatim}

template <typename Data Type>\\
void BiTree<DataType> :: PreOrder ()\\
\{\\
BiNode<DataType> *bt = root;\\
BiNode<DataType> * S [100]; //顺序栈,最多 100个结点指针\\
int top=-1; ||顺序栈初始化\\
while (bt != nullptr || top != -1) //两个条件都不成立才退出循环\\
\{\\
while (bt != nullptr)\\
l\\
cout <<bt->data;\\
S[++topI=bt; //将根指针bt 人栈\\
bt = bt->lchild;\\
\}\\
if (top != -1) \{ //栈非空\\[0pt]
bt = s[top--];\\
bt = bt->rchild;\\
)\\
\}\\
\}

\begin{verbatim}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-168.jpg?height=319&width=244&top_left_y=784&top_left_x=1265)

\section*{2．中序遍历非递归算法}

在二叉树的中序遍历中，访问结点的操作发生在该结点的左子树遍历完毕并准备遍历右子树时，所以，在遍历过程中遇到某结点时并不能立即访问它，而是将它压栈，等到它的左子树遍历完毕后，再从栈中弹出并访问之。中序遍历的非递归算法只需将前序遍历非递归算法中的输出操作 cout $\ll \mathrm{bt}->$ data 移到出栈操作 $\mathrm{bt}=\mathrm{S}[\mathrm{top}--]$ 之后即可。

\section*{3．后序遍历非递归算法}

后序遍历与前序遍历和中序遍历不同，在后序遍历过程中，当遍历完左子树，由于右子树尚未遍历，因此栈顶结点不能出栈，而是通过栈顶结点找到它的右子树，当遍历完右

子树，才能将栈顶结点出栈并访问。
为了区别对栈顶结点的不同处理，设置标志变量flag。flag $=1$ 表示遍历完左子树，栈顶结点不能出栈；flag $=2$ 表示遍历完右子树，栈顶结点可以出栈并访问。栈元素的结构体类型定义如下。
\end{verbatim}

template <typename DataType>\\
struct element\\
f\\
BiNode<DataType> * ptr;\\
int flag;\\
\};

\begin{verbatim}

设要遍历二叉树的根指针为 $b t$ ，则有以下两种情况：
（1）若 $\mathrm{bt} \neq$ nullptr ，则 bt 及标志 flag（置为 1 ）人栈，遍历其左子树。
（2）若 $\mathrm{bt}=$ nullptr，此时若栈空，则整个遍历结束；若栈不空，则表明栈顶结点的左子树或右子树已遍历完毕。若栈顶结点的标志 flag $=1$ ，则表明栈顶结点的左子树遍历完毕，将 flag 修改为 2 ，并遍历栈顶结点的右子树；若栈顶结点的标志 flag $=2$ ，则表明栈顶结点的右子树也遍历完毕，出栈并输出栈顶结点。

二叉树后序遍历的非递归算法用伪代码描述如下：

算法：PostOrder
输人：二叉链表的根指针bt
输出：后序遍厉序列
1．栈 S 初始化；
2．循环直到 $b t$ 为空且栈 $S$ 为空
2.1 当 $b t$ 非空时执行下述操作

2．1．1 将 bt 连同标志 flag＝ 1 人栈；
2．1．2 继续遍历 bt的左子树；
2．2当栈 S 非空且栈顶元素的标志为 2 时执行下述操作
2．2．1将栈顶元素弹出至 $b t$ ；
2．2．2 访问 bt；
2.3 若栈非空，将栈顶元素的标志改为 2 ，准备遍历栈顶结点的右子树；

简单起见，栈采用顺序存储结构并假定不会发生溢出，下面给出二叉树后序遍历成员函数的非递归实现。
\end{verbatim}

template <typename DataType>\\
void BiTree<DataType> :: PostOrder ()\\
\{\\
BiNode<DataType> * bt = root;\\[0pt]
element S[100]; //顺序栈,最多100个元素\\
int top = -1; ///顺序栈初始化

\begin{verbatim}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-169.jpg?height=309&width=243&top_left_y=2023&top_left_x=1431)
\end{verbatim}

\begin{verbatim}
while (bt != nullptr || top != -1) //两个条件都不成立才退出循环
\end{verbatim}

\begin{verbatim}

\end{verbatim}

\begin{verbatim}
i
    while (bt != nullptr)
    {
        topt+;
        S[top].ptr = bt; S[top].flag = 1; //bt连同标志 flag 人栈
        bt = bt->lchild;
    )
    while (top != -1 && S[top].flag == 2)
    {
        bt = s[top--].ptr;
        cout <<bt->data;
    }
    if (top != -1)
        S[top].flag = 2;
        bt = S[top].ptr->rchild;
    }
\end{verbatim}

\begin{verbatim}

\section*{5．8．2 线索链表}

\section*{1．线索链表的存储结构}

在具体应用中，有时需要访问二叉树的结点在某种遍历序列中的前驱和后继，此时，在存储结构中应保存结点在某种遍历序列中的前驱和后继信息。考虑到一个具有 $n$ 个结点的二叉链表，在 $2 n$ 个指针域中只有 $n-1$ 个指针域用来存储孩子结点的地址，存在 $n+$ 1 个空指针域，可以利用这些空指针指向该结点在某种遍历序列中的前驱和后继结点。这些指向前驱和后继结点的指针称为线索（thread），加上线索的二叉链表称为线索链表 （thread linked list），相应地，加上线索的二叉树称为线索二叉树（thread binary tree）。

在线索链表中，对任意结点，若左指针域为空，则用左指针域存放该结点的前驱线索；若右指针域为空，则用右指针域存放该结点的后继线索。为了区分某结点的指针域存放的是指向孩子的指针还是指向前驱或后继的线索，每个结点再增设两个标志位 ltag 和 rtag，线索链表的结点结构如图 5－37 所示，线索链表的结点结构定义如下：
\end{verbatim}

template <typename DataType>\\
Struct ThrNode\\
i\\
DataType data;\\
int ltag, rtag;\\
ThrNode<DataType> * lchild, * rchild;\\
\};

\begin{verbatim}

由于二叉树的遍历次序有 4 种，故有 4 种意义下的前驱和后继，相应地有 4 种线索链

$$
\begin{gathered}
\hline \text { Itag } \\
\text { Itag }=\left\{\begin{array}{l}
\text { lchild } \\
0: \text { lchild指向该结点的左孩子 } \\
1: \text { lchild指向该结点的前驱 }
\end{array}\right. \\
\hline
\end{gathered} \quad \text { rtag }=\left\{\begin{array}{l}
0: \text { rchild指向该结点的右孩子 } \\
1: \text { rchild指向该结点的后继 }
\end{array}\right.
$$


图 5－37 线索链表的结点结构
表：前序线索链表、中序线索链表、后序线索链表、层序线索链表。图 5－38 所示是一个中序线索链表，图中实线表示指向孩子结点的指针，虚线表示指向前驱或后继的线索，例如， $G$ 的中序前驱是 $D, G$ 的中序后继是 $B, B$ 的中序后继是 $A, E$ 的中序前驱是 $A, E$ 的中序后继是 $C$ 。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-171.jpg?height=506&width=1191&top_left_y=767&top_left_x=353)

图 5－38 中序线索链表的存储示意图

\section*{2．线索链表的实现}

中序线索链表类定义如下，其中成员变量 root 为线索链表的根指针，成员函数实现线索二叉树的基本操作。为了避免类的调用者访问 InThrBiTree 类的私有变量 root，在构造函数和析构函数中调用了相应的私有函数，例如，在构造函数中调用了私有函数 Creat 和 ThrBiTree。
\end{verbatim}

template <typename DataType>\\
class InThrBiTree\\
\{\\
public:\\
InThrBiTree(); //构造函数,建立中序线索链表\\
\~{}InThrBiTree(); //析构函数,释放各结点的存储空间\\
ThrNode<DataType> * Next (ThrNode<DataType> * p);\\
void InOrder(): //中序遍历线索链表\\
private:\\
ThrNode<DataType> * Creat (ThrNode<DataType> * bt); //构造函数调用\\
void ThrBiTree(ThrNode<DataType> * bt, ThrNode<DataType> * pre);\\
void Release(ThrNode<DataType> *bt); //析构函数调用

\begin{verbatim}

\end{verbatim}

ThrNode<DataType> * root;\\
//指向线索链表的头指针

\begin{verbatim}

下面的讨论以中序线索链表为例，其他线索链表与此类似，请读者自行给出。
（1）构造函数
线索链表的构造函数需要执行两步操作：首先建立带线索标志的二叉链表，再对二叉链表进行线索化。构造函数定义如下：
\end{verbatim}

template <typename DataType>\\
InThrBiTree<DataType> :: InThrBiTree()\\
l\\
root = Creat(root); //建立带线索标志的二叉链表\\
ThrBiTree(root, nullptr); //遍历二叉链表,建立线索\\
\}\\
回话虫回

\begin{verbatim}
（2）建立带标志的二叉链表
建立带标志的二叉链表与建立二叉链表类似，区别仅是将所有标志初始化为 0 。请读者参见二叉链表的 Creat 函数自行设计。
（3）二叉链表的线索化
对二叉链表进行线索化就是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历二叉树时才能得到。具体地，在遍历的过程中，对当前访问的结点 bt 执行下述操作：
（1）检查结点 bt 的左、右指针域，如果为空，则将相应标志置1。
（2）由于结点 bt 的前驱刚被访问过，所以若左指针为空，则可令其指向它的前驱；但由于 bt 的后继尚未访问到，所以它的右指针不能建立线索，要等到访问结点 bt 的后继结点时才能进行。为实现这一过程，设指针 pre始终指向刚刚访问过的结点，即若指针 bt 指向当前结点，则 pre 指向它的前驱，显然 pre的初值为空，如图 5－39 所示。
（3）令 pre 指向刚刚访问过的结点 root。
建立中序线索链表的算法用伪代码描述
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-172.jpg?height=358&width=649&top_left_y=1483&top_left_x=838)

图 5－39 访问结点 bt 的操作示意图如下：

算法：InThrBiTree
输人：二叉链表（带标志）的根指针 bt
输出：无
1．如果二叉链表 bt 为空，则空操作返回；
2．对 bt 的左子树建立线索；
3．访问根结点 bt，执行下述操作
3.1 如果 bt 没有左孩子，则为 bt 加上前驱线索；
$\square$
3.2 如果 bt 没有右孩子，则将 bt 的右标志置为 1 ；
3.3 如果结点 pre 的右标志为 1 ，则为其加上后继线索；
3.4 令 pre 指向刚访问的结点 bt；

4．对 bt 的右子树建立线索；
对二叉链表进行线索化的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
void InThrBiTree<DataType>::ThrBiTree(ThrNode<DataType>\\
* bt, ThrNode<DataType> * pre)\\
l\\
if (bt == nullptr) return;\\
ThrBiTree(bt->Ichild, pre);\\
if (bt->lchild = = nullptr) \{ //对bt的左指针进行处理\\
bt ->Itag = 1;\\
bt->lchild = pre; //设置 pre 的前驱线索\\
J\\
if (bt->rchild == nullptr) bt->rtag = 1; //对bt 的右指针进行处理\\
if (pre->rtag == 1) pre->rchild = bt; //设䈯 pre的后继线索\\
pre = bt;\\
ThrBiTree (bt->rchild, pre);\\
)

\begin{verbatim}
（4）查找后继结点
对于中序线索链表的任意结点 p ，其后继结点有以下两种情况：
（1）如果结点 p 的右标志为 1 ，表明该结点的右指针是线索，则其右指针所指向的结点便是它的后继结点。例如，在图 5－38 所示中序线索链表上，结点 B 的右标志为 1 ，则结点 $B$ 的右指针指向的结点 $A$ 即是结点 $B$ 的后继结点。
（2）如果结点 p 的右标志为 0 ，表明该结点有右孩子，无法直接找到其后继结点。然而，根据中序遍历的操作定义，它的后继结点应该是遍历其右子树时第一个访问的结点，即右子树中的最左下结点。这只需沿着其右孩子的左指针向下查找，当某结点的左标志为 1 时，就是所要找的后继结点。例如，在图 5－38 所示中序线索链表上，结点 A 的右标志为 0 ，则结点 A 的右子树的最左下结点 E 即是结点 A 的后继结点。

在中序线索链表上查找结点 $p$ 的后继结点的成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
ThrNode <DataType> * InThrBiTree<DataType> :: Next (ThrNode\\
<DataType> * p)\\
r\\
ThrNode<DataType> * q = nullptr;\\
if (p->rtag == 1) q = p->rchild; //直接得到后继结点\\
else \{\\
q=p->rchild;

\begin{verbatim}
    while (q->Itag = = 0)
        q = q->lchild;
}
    return q;
}
\end{verbatim}

（5）中序遍历\\
在中序线索链表上进行遍历，只需找到中序遍历序列中的第一个结点，然后依次找每个结点的后继结点，直至某结点无后继为止。成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void InThrBiTree<DataType>:: Inorder()
{
    if (root = = nullptr) return; //如果线索链表为空,则空操作返回
    ThrNode<DataTyoe> * p = root;
    while (p->1taq = = 0) //查找遍历序列的第一个结点 p
        p=p->lchild;
    cout <<p->data;
    while (p->rchild != nullptr) //当结点 p 存在后继,依次访问其后继结点
    {
        p=Next (p);
        cout <<p->data;
\end{verbatim}

在中序线索链表上进行中序遍历，虽然时间复杂度亦为 $O(n)$ ，但常数因子比在二叉链表上进行的递归与非递归遍历算法小，且不需要设工作栈。因此，若某问题中所用的二叉树需经常遍历或查找结点在某种遍历序列中的前驱和后继，则应采用线索链表作为存储结构。

\section*{5.9 应 用 实 例}
\section*{5．9．1 堆与优光队列}
\section*{1．堆的定义}
优先队列（priority queue）是按照某种优先级进行排列的队列，优先级越高的元素出队越早，优先级相同者按照先进先出的原则进行处理。优先队列的基本算法可以在普通队列的基础上修改而成。例如，人队时将元素插人到队尾，出队时找出优先级最高的元素出队；或者人队时将元素按照优先级插人到合适的位置，出队时将队头元素出队。这两种实现方法，人队或出队总有一个时间复杂度为 $O(n)$ 。采用堆来实现优先队列，人队和出队的时间复杂度均为 $O\left(\log _{2} n\right)$ 。

堆（heap）是具有下列性质的完全二叉树 ${ }^{(1)}$ ：每个结点的值都小于或等于其左右孩子结点的值（称为小根堆）；或者每个结点的值都大于或等于其左右孩子结点的值（称为大根堆）。如果将堆按层序从 1 开始编号，则结点之间满足如下关系：

$$
\left\{\begin{array} { l } 
{ k _ { i } \leqslant k _ { 2 i } } \\
{ k _ { i } \leqslant k _ { 2 i + 1 } }
\end{array} \quad \text { 或 } \quad \left\{\begin{array}{l}
k_{i} \geqslant k_{2 i} \\
k_{i} \geqslant k_{2 i+1}
\end{array} \quad(1 \leqslant i \leqslant\lfloor n / 2\rfloor)\right.\right.
$$

从堆的定义可以看出，一个完全二叉树如果是堆，则根结点（称为堆顶）一定是当前堆中所有结点的最大者（大根堆）或最小者（小根堆）。图 5－40 给出了堆的示例，用小根堆实现的优先队列称为极小队列，用大根堆实现的优先队列称为极大队列，不失一般性，下面仅讨论极大队列。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-175}

图 5－40 堆的示例

\section*{2．极大队列的存储结构}
由于堆是完全二叉树，因此采用顺序存储，即将大根堆按层序从 1 开始连续编号，将结点以编号为下标存储到一维数组 data 中。如图 5－41 所示，用大根堆实现极大队列，队头元素存储在 data［1］中，因此不用表示队头位置。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-175(1)}\\
（a）大根堆按完全二叉树编号

下标：

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
\hline
50 & 40 & 45 & 36 & 32 & 18 & 22 & 30 \\
\hline
\end{tabular}
\end{center}

（b）大根堆的顺序存储

图 5－41 极大队列的存储结构

\section*{3．极大队列基本操作的实现}
极大队列类定义如下，其中成员变量实现极大队列的顺序存储，成员函数实现极大队列的基本操作。

\footnotetext{（1）有些参考书将堆直接定义为序列，但是，从逻辑结构上讲，还是将堆定义为完全二又树更好。虽然堆的典型实现方法是使用数组，但是从逻辑结构的角度来看，堆实际上是一种树结构。
}\begin{verbatim}
template <typename DataType>
//定义模板类 Priqueue
class Priqueue
1
public:
    Priqueue () ; //构造函数, 初姶化空极大队列
    ~Priqueue () ; //析构函数
    void Enqueue (DataType x) ; //人队操作, 将元素 x 人队
    DataType DeQueue () ; //出队操作, 将队头元素出队
    DataType GetHead () ; //取队头元素 (并不删除)
    int Empty () ; //判断队列是否为空
private:
    DataType data[QueueSize]; //存放队列元素的数组
    int rear; $1 /$ 游标, 队尾指针
);
\end{verbatim}

由于极大队列对应大根堆并按层序编号存储到一维数组 data 中下标 1 开始的单元，由完全二叉树的性质，元素 data［i］的双亲是 data［i／2］、左孩子是 data［2i］、右孩子是 data $[2 i+1]$ 。由于 rear 指示队尾元素的位置，则队空时 rear $=0$ 。 初始化一个空的优先队列只需将队尾位置 rear 置为 0 ，优先队列的判空操作只需判断 rear 是否等于 0 ，取队头元素只需返回 data［1］。下面讨论优先队列的人队和出队操作。\\
（1）人队操作\\
优先队列的人队操作先将待插元素 x 插人队尾位置，然后将新插人元素从叶子向根方向进行调整，若新插入元素比双亲大，则进行交换，这个过程一直进行到根结点或新插人元素小于其双亲结点的值。操作示意图如图 5－42 所示，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void PriQueue<DataType> : : Enoueue (DataType x)
{
    int i, temp;
    if (rear == MaxSize -1) throw "上㳑";
    i=++ rear; //i 记载新元素在数组中的下标
    data[i] = x;
    while (i/2 >0 && data [i/2] < x)
    {
        temp = data[i]; data[i] = data[i/2]; data[i/2]= temp;
        i = i/2; //新插人元素被调整到 i/2
    }
}
\end{verbatim}

（2）出队操作\\
由于优先队列的队头元素位于堆顶，因此出队操作直接输出堆顶元素，为维护堆的性质，将队尾元素放到根结点，然后调整根结点重新建堆。操作示意图如图 5－43 所示，成员函数定义如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-177(1)}

图 5－42 优先队列人队操作的过程示例

\begin{verbatim}
template <typename DataType>
DataType Priqueue<DataType> :: Dequeue()
{
    int i, j, x, temp;
    if (rear == 0) throw "下溢";
    x = data[1];
    data[1] = data[rear--];
    i = 1; j = 2 * i; //i 是被调整的结点, j 是 i 的左孩子
    while (j <= rear) //调整要进行到叶子
    {
        if (j < rear && data[j] < data[j+1]) j++;
        if (data[i] > data[j]) break; //根结点大于左右孩子中的较大者
        else {
            temp = data[i]; data[i] = data[j]; data[j] = temp;
            i = j; j = 2 * i; // 被调篥结点位于原来结点 j 的位置
    }
    }
    return x;
)
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-177}
\end{center}

图 5－43 优先队列出队操作的过程示例

\section*{5．9．2 并查集}
\section*{1．并查集的存储结构}
不相交集合是对集合的一种划分，将集合 $S$ 划分为若干个子集，这些子集之间没有

交集，且所有子集合并即为集合 $S$ 。不相交集合的两个基本操作是查找和合并，查找是找出某个元素属于哪个子集，合并是把两个子集合并成一个子集。由于不相交集合的两个基本操作是并和查，因此不相交集合也被称为并查集（union find set）。

可以用树结构来实现并查集，将每个子集表示为一棵树，子集中的每个元素是树上的一个结点。如图 5－44 所示，查找操作给出待查元素所在树的根结点，这需要从该结点沿着双亲结点进行回溯，直到根结点。合并操作将两棵树合并为一棵树，由于并查集只关心哪些元素在同一棵树上，并不关心树的形状，因此可以将一棵树作为另一棵树根结点的子树。由于查和并都只涉及某结点的双亲，因此，树可以采用双亲表示法存储。数组元素的结点结构定义如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-178}

图 5－44 并查集的操作示意图

\section*{2．并查集的实现}
下面给出并查集的类定义，其中成员变量实现并查集的双亲表示法存储，成员函数实现并查集的基本操作。

\begin{verbatim}
const int MaxSize = 100;／／假设集合最多 100 个元素
class UnionEind
{
public:
    UnionFind(char ch[ ], int n); //每个元素构成一个子集
    ~UnionFind();
    int Find(char x); //查找元素 x 所在子树的根结点
    void Union (char x, char y); //合并元素 x 和 y 所在子集
private:
    ElemType elem[MaxSize]; //双亲表示法存储
\end{verbatim}

\begin{verbatim}
    int length; //集合的元素个数
};
\end{verbatim}

由于并查集采用双亲表示法存储，基本操作都是在数组上进行，下面讨论基本操作的实现。\\
（1）构造函数。构造函数将成员变量进行初始化，即将 n 个元素存储到 data 域，同时将 parent 初始化为 -1 。构造函数比较简单，请读者自行设计。\\
（2）析构函数。并查集采用静态存储分配，在并查集变量退出作用域时自动释放成员变量所占存储空间，因此，析构函数为空。\\
（3）查找。查找某元素所在子集即是返回该元素所在树的根结点的下标，这只需查找 x 的双亲，直到根结点。假设元素 x 是并查集的元素，成员函数定义如下：

\begin{verbatim}
int UnionFind :: Find(char x)
{
    int i;
    for (i = 0; i<length; i++)
        if (elem[i].data == x) break;
    while (elem[i].parent != -1)
        i=elem[i].parent;
    return i;
}
\end{verbatim}

\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-179}\\
（4）合并。合并两个元素所在集合需要查找两个集合所在树的根结点，然后进行合并，假定元素 x 和 y 均是并查集的元素，成员函数定义如下：

\begin{verbatim}
void UnionFind :: Union (char x, char y)
l
    int vex1 = Find (x);
    int vex2 = Find (y);
    if (vex1 != vex2) elem[vex2],parent = vex1;
}
\end{verbatim}

\section*{思想火花——调试程序与魔术表演}
每个程序员都知道，调试程序是一件很困难的事情，但是，熟练的程序员可以使调试程序的工作看起来很简单。有些人心烦意乱地描述他们已经花了好几个小时查找 bug，都不知道问题出现在什么地方，但是优秀的程序员问了几个问题后，就能够确定故障代码的位置。优秀的程序员决不会忘记：不管系统的行为看起来有多么神秘，程序里面必定存在一定的逻辑解释。

下面发生的事情都是真实的。\\
在 IBM 的约克城研究中心，一位程序员安装了一个新的工作站。当他坐下来登录时

一切正常，但是当他站起来时就不能登录系统。我们当中的大多数人都只会把头靠在椅子背上，百思不得其解：那个工作站怎么知道这个可怜的家伙在登录时是站着还是坐着呢？但是优秀的程序员知道里面一定有文章。一个同事问了一个问题：程序员站着和坐着时分别是如何登录的？伸出手再试试。问题就出现在键盘上：两个键的键帽松动了，程序员坐下时因为他是触摸打字，没有注意到这个问题，但是当他站起来时，是在寻找和敲击键盘，键帽就接触不好了。了解这点之后，程序员拿了把改锥，拧紧了那两个键帽，之后一切都正常了。

芝加哥的一个银行系统已经正常运作好几个月了，但是想不到的是，第一次处理国际数据就停止工作了。程序员花了几天的时间追踪代码，始终找不到任何停止该程序的命令。当更仔细地观察这个问题时，他们发现当输入厄瓜多尔的某些数据时，该程序就会停止。更加仔细的检测显示，当用户输入厄瓜多尔首都的名字（Quito，基多）时，该程序将它解释为请求停止运行程序！

曾经有一个系统，在第一次处理事务时都是正确的，而在后续的事务处理中总是出现错误。系统重新启动后，它在处理第一次事务时又是正常的，但是后续事务的处理又出现问题。有经验的程序员立刻知道应该去查找某个变量，程序加载时这个变量被正确地初始化了，但是第一次事务处理之后就没有被重新正确设定。

无论在什么情况下，恰当的提问都会引导聪明的程序员迅速找到令人讨厌的 bug： ＂你站着和坐着的时候做了不同的事情吗？＂＂退出程序之前你输入了什么？＂＂程序在开始失败前正常工作过吗？＂等。

程序的错误行为就和魔术表演类似。我们都知道，魔术表演都是魔术师的精心演绎，看起来于理不通，其实里面都大有文章；同样，程序出现了错误行为，有经验的程序员都知道程序里面一定存在着逻辑解释，然后通过错误现象去准确定位有故障的代码。

\section*{习 题 5}
\section*{1．选择题}
（1）一个高度为 $h$ 的满二叉树共有 $n$ 个结点，其中有 $m$ 个叶子结点，则有（）成立。\\
A．$n=h+m$\\
B．$h+m=2 n$\\
C．$m=h-1$\\
D．$n=2 m-1$\\
（2）设二叉树有 $n$ 个结点，则其深度为（）。\\
A．$n-1$\\
B．$n$\\
C．$\left\lfloor\log _{2} n\right\rfloor+1$\\
D．不能确定\\
（3）二叉树的前序序列和后序序列正好相反，则该二叉树一定是（ ）的二叉树。\\
A．空或只有一个结点\\
B．高度等于其结点数\\
C．任一结点无左孩子\\
D．任一结点无右孩子\\
（4）线索二叉树中某结点 $R$ 没有左孩子的充要条件是（ ）。\\
A．R．lchild＝NULL\\
B．R． $\operatorname{ltag}=0$\\
C．R． $\operatorname{ltag}=1$\\
D．R．rchild＝NULL\\
（5）深度为 $k$ 的完全二叉树至少有（ ）个结点，至多有（ ）个结点。\\
A． $2^{k-2}+1$\\
B． $2^{k-1}$\\
C． $2^{k}-1$\\
D． $2^{k-1}-1$\\
（6）任何一棵二叉树的叶子结点在前序、中序、后序遍历序列中的相对次序（\\
A．肯定不发生改变\\
B．肯定发生改变\\
C．不能确定\\
D．有时发生变化\\
（7）设森林中有 4 棵树，树中结点的个数依次为 $n_{1} 、 n_{2} 、 n_{3} 、 n_{4}$ ，则把森林转换成二叉树后，其根结点的右子树上有（ ）个结点，根结点的左子树上有（ ）个结点。\\
A．$n_{1}-1$\\
B．$n_{1}$\\
C．$n_{1}+n_{2}+n_{3}$\\
D．$n_{2}+n_{3}+n_{4}$\\
（8）讨论树、森林和二叉树的关系，目的是为了（ ）。\\
A．借助二叉树上的运算方法去实现对树的一些运算\\
B．将树、森林按二叉树的存储方式进行存储并利用二叉树的算法解决树的有关问题\\
C．将树、森林转换成二叉树\\
D．体现一种技巧，没有什么实际意义\\
（9）为5个使用频率不等的字符设计哈夫曼编码，不可能的方案是（）。\\
A． $111,110,10,01,00$\\
B． $000,001,010,011,1$\\
C． $100,11,10,1,0$\\
D． $001,000,01,11,10$\\
（10）为 5 个使用频率不等的字符设计哈夫曼编码，不可能的方案是（ ）。\\
A． $000,001,010,011,1$\\
B． $0000,0001,001,01,1$\\
C． $000,001,01,10,11$\\
D． $00,100,101,110,111$

2．解答下列问题\\
（1）在孩子表示法中查找双亲比较困难，把双亲表示法和孩子表示法结合起来，就形成了双亲孩子表示法，即在孩子表示法的表头结点中增设一个域存储该结点的双亲结点在数组中的下标。请画出图 5－3（a）所示树采用双亲孩子表示法的存储示意图。\\
（2）证明：对任一满二叉树中的分枝数 $B=2\left(n_{0}-1\right)$ 。（其中，$n_{0}$ 为终端结点数）\\
（3）证明：已知一棵二叉树的前序序列和中序序列，则可唯一确定该二叉树。\\
（4）已知一棵度为 $m$ 的树中有：$n_{1}$ 个度为 1 的结点，$n_{2}$ 个度为 2 的结点，$\cdots, n_{m}$ 个度为 $m$ 的结点，问该树中共有多少个叶子结点？\\
（5）已知二叉树的中序和后序序列分别为 CBEDAFIGH 和 CEDBIFHGA，试构造该二叉树。\\
（6）假设用于通信的电文由字符集 $\{a, b, c, d, e, f, g\}$ 中的字符构成，它们在电文中出现的频率分别为 $\{0.31,0.16,0.10,0.08,0.11,0.20,0.04\}$ 。请为这 7 个字符设计哈夫曼编码。\\
（7）已知某电文中出现了 10 种不同的字符，每个字符出现的频率分别为 $\{\mathrm{A}: 8, \mathrm{~B}: 5$ ， C：3，D：2，E：7，F：23，G：9，H：11，I：2，J：35\}, 现在对这段电文用三进制进行编码 (即编码由 $0 、 1 、 2$ 组成），问电文编码的总长度至少有多少位？

\section*{3．算法设计}
（1）设计算法求二叉树的结点个数。\\
（2）设计算法按前序次序打印二叉树中的叶子结点。\\
（3）设计算法求二叉树的深度。\\
（4）一棵具有 $n$ 个结点的二叉树采用顺序存储结构，编写算法对该二叉树进行前序遍历。\\
（5）已知深度为 $h$ 的二叉树以一维数组 $\operatorname{BT}\left[1 . .2^{h}-1\right]$ 作为其存储结构。试编写算法，求该二叉树中叶子结点的个数。为简单起见，设二叉树中元素结点为非零整数。\\
（6）设一棵有 $n(n \leqslant 100)$ 个结点的二叉树按顺序存储方式存储在 bt［1．．n］中，编写算法，求二叉树中编号为 $i$ 和 $j$ 的两个结点的最近公共祖先结点。\\
（7）以二叉链表为存储结构，编写算法求二叉树中结点 $x$ 的双亲。\\
（8）以二叉链表为存储结构，在二叉树中删除以值 $x$ 为根结点的子树。\\
（9）编写算法交换二叉树中所有结点的左右子树。\\
（10）以孩子兄弟表示法做存储结构，求树中结点 $x$ 的第 $i$ 个孩子。

\section*{实 验 题 5}
【实验 1】请上机实现 5．5．2 节二叉链表类的使用范例，增加统计结点个数、计算二叉树的深度等成员函数，并用不同的二叉树实例进行测试。

【实验 2】哈夫曼树的应用。假设某文本文档只包含 26 个英文字母，应用哈夫曼算法对该文档进行压缩和解压缩操作，使得该文档占用较少的存储空间。

【实验 3】小球下落。一棵深度为 $h$ 的满二叉树从 1 开始进行层序编号，每个分支结点有一个开关，初始全部关闭。在结点 1 处放置一个小球会下落，当小球落到一个分支结点时，根据该结点的状态选择下一步的落点，如果开关关闭，则小球往左落，否则往右落，直到落到叶子结点。当小球离开时会改变该结点的状态。设有 $n$ 个小球从结点 1 处开始下落，问最后一个小球会落到哪个结点？\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$ 2 $\qquad$直B $\qquad$ $\because$\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-183} $\qquad$等 $\qquad$\\
$\qquad$\\
$\qquad$\\
$\square$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\square$\\
$\square$\\
$\square$\\
$\qquad$\\
1 .\\
1\\
告告中\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$

$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$

\section*{－}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-183(2)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-183(3)}\\
$\square$）\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
$\qquad$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-183(1)}\\
$\qquad$\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-183(4)}\\
$\qquad$

\section*{普通高校本科计算机专业 特 色 教 材 精 选}
\section*{$6_{\text {훙 }}$}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
本章概述 & \multicolumn{5}{|c|}{\begin{tabular}{l}
图结构是一种比树结构更复杂的非线性结构，在图结构中，任意两个顶点之间都可能有关系。图结构具有极强的表达能力，可用于描述各种复杂的数据对象。图的应用十分广泛，典型的应用领域有电路分析、项目规划、鉴别化合物、统计力学、遗传学、人工智能、语言学等。本章是本课程的难点和重点。 \\
本章由实际问题引出图结构，介绍图的定义、分类和基本术语，讨论图的邻接矩阵存储和邻接表存储，讨论图的遍历操作及具体实现，最后介绍图的 4 个经典应用：最小生成树、最短路径、拓扑排序和关键路径。 \\
\end{tabular}} \\
\hline
教学重点 & \multicolumn{5}{|l|}{图的基本术语；图的存储表示；图的遍历；图的经典应用} \\
\hline
教学难点 & \multicolumn{5}{|c|}{图的遍历算法；Prim 算法；Kruskal 算法；Dijkstra 算法；Floyd 算法；拓扑排序算法；关键路径算法} \\
\hline
\multirow{6}{*}{} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教 学 要 求} \\
\hline
 &  & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline
 & 图的定义和基本术语 &  &  & $\checkmark$ &  \\
\hline
 & 图的抽象数据类型定义 &  & $\checkmark$ &  &  \\
\hline
 & 图的邻接矩阵存储及实现 &  &  &  & $\checkmark$ \\
\hline
 & 图的邻接表存储及实现 &  &  & $\checkmark$ &  \\
\hline
\multirow{3}{*}{教学内容和教学目标} & 邻接矩阵和邻接表的比较 &  & $\checkmark$ &  &  \\
\hline
 & Prim 算法 &  &  & $\checkmark$ &  \\
\hline
 & Kruskal 算法 &  & $\checkmark$ &  &  \\
\hline
\multirow{6}{*}{} & Dijkstra 算法 &  &  & $\checkmark$ &  \\
\hline
 & Floyd 算法 &  & $\checkmark$ &  &  \\
\hline
 & AOV 网的定义及性质 &  & $\checkmark$ &  &  \\
\hline
 & 拓扑排序算法 &  &  & $\checkmark$ &  \\
\hline
 & AOE 网的定义及性质 &  & $\checkmark$ &  &  \\
\hline
 & 关键路径算法 &  & $\checkmark$ &  &  \\
\hline
\end{tabular}
\end{center}

\section*{6.1 引言}
在图结构中，任意两个顶点之间都可能有关系，可用于描述各种复杂的数据对象。在实际应用中，很多问题抽象出的数据模型是图结构。下面请看两个例子。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-185}

【例 6－1】 七巧板涂色问题。假设有如图 6－1（a）所示七巧板，使用至多 4 种不同颜色对七巧板涂色，要求每个区域涂一种颜色，相邻区域的颜色互不相同。

【想法——数据模型】为了识别不同区域的相邻关系，可以将七巧板的每个区域看成一个顶点，如果两个区域相邻，则这两个顶点之间有边相连，从而将七巧板抽象为图结构，如图 6－1（b）所示。这种图结构有什么特点？如何进行存储？如何求得涂色方案呢？\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-185(1)}

图 6－1 七巧板及其数据模型\\
【例 6－2】农夫过河问题。一个农夫带着一只狼、一只羊和一筐菜，想从河一边（左岸）乘船到另一边（右岸）。由于船太小，农夫每次只能带一样东西过河。但是如果没有农夫看管，则狼会吃羊，羊会吃菜。农夫怎样过河才能把每样东西安全地送过河呢？

【想法——数据模型】在某一时刻，农夫、狼、羊和菜或者在河的左岸，或者在河的右岸，可以用 0 表示在河的左岸，用 1 表示在河的右岸，如图6－2（a）所示。例如， 1010 表示农夫和羊在河的右岸、狼和菜在河的左岸。将每一个可能的状态抽象为一个顶点，边表示状态转移发生的条件，从而将农夫过河问题抽象为一个图模型，如图 6－2（b）所示。这种图结构有什么特点？如何进行存储？如何求解得到过河方案呢？\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-185(2)}

图6－2 农夫过河问题及其数据模型

\section*{6.2 图的逻辑结构}
\section*{6．2．1 图的定义和基本术语}
在图中常常将数据元素称为顶点 ${ }^{(1)}$（vertex）。

\section*{1．图的定义}
图（graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-186}表示为：

$$
G=(V, E)
$$

其中，$G$ 表示一个图，$V$ 是顶点的集合，$E$ 是顶点之间边的集合。例如，在图6－3（a）所示 $G 1$ 中，顶点集合 $V=\left\{v_{0}, v_{1}, v_{2}, v_{3}, v_{4}\right\}$ ，边的集合 $E=\left\{\left(v_{0}, v_{1}\right),\left(v_{0}, v_{3}\right),\left(v_{1}, v_{2}\right)\right.$ ， $\left.\left(v_{1}, v_{4}\right),\left(v_{2}, v_{3}\right),\left(v_{2}, v_{4}\right)\right\}$ 。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-186(1)}

图 6－3 图的示例

在图中，若顶点 $v_{i}$ 和 $v_{j}$ 之间的边没有方向，则称这条边为无向边，用无序偶对 $\left(v_{i}, v_{j}\right)$表示；若从顶点 $v_{i}$ 到 $v_{j}$ 的边有方向，则称这条边为有向边（也称为弧，以区别于无向边），用有序偶对 $\left\langle v_{i}, v_{j}\right\rangle$ 表示，$v_{i}$ 称为弧尾，$v_{j}$ 称为弧头。如果图的任意两个顶点之间的边都是无向边，则称该图为无向图（undirected graph），否则称该图为有向图（directed graph）。例如，图 6－3（a）所示是一个无向图，图 6－3（b）所示是一个有向图 ${ }^{(2)}$ 。

在图中，权（weight）通常是对边赋予的有意义的数值量 ${ }^{(3)}$ ，在实际应用中，权可以有具体的含义。例如，对于城市交通线路图，边上的权表示该条线路的长度或者等级；对于工程进度图，边上的权表示活动所需要的时间，等等。边上带权的图称为带权图或网图（network graph）。例如，图6－3（c）所示是一个无向网图，（d）所示是一个有向网图。

\footnotetext{（1）有些教材将图的顶点称为节点（node）。新华字典对结点的定义是直线或曲线的终点或交点；对节点的定义是电路中连接三个或三个以上的点，物体的分段或两段之间连接的部分；对顶点的定义是角的两条边的交点。英文的结点和节点都是 node，都表示交叉点、集结点。\\
（2）若图 $G=(V, E)$ 中同时包含无向边和有向边，则称为混合图。将每条无向边等效地替换为对称的一对有向边，可将混合图转化为有向图。\\
（3）在图中，权可以是边的属性也可以是顶点的属性。本书只讨论边上带权的图，且权值是非负整数的情况。
}\section*{2．图的基本术语}
（1）邻接、依附\\
在无向图中，对于任意两个顶点 $v_{i}$ 和 $v_{j}$ ，若存在边 $\left(v_{i}, v_{j}\right)$ ，则称顶点 $v_{i}$ 和 $v_{j}$ 互为邻接点 ${ }^{(1)}$（adjacent），同时称边 $\left(v_{i}, v_{j}\right)$ 依附（adhere）于顶点 $v_{i}$和 $v_{j}$ 。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-187}

在有向图中，对于任意两个顶点 $v_{i}$ 和 $v_{j}$ ，若存在弧 $\left\langle v_{i}, v_{j}\right\rangle$ ，则称顶点 $v_{i}$ 邻接到 $v_{j}$ ，顶点 $v_{j}$ 邻接自 $v_{i}$ ，同时称弧 $\left\langle v_{i}, v_{j}\right\rangle$ 依附于顶点 $v_{i}$ 和 $v_{j}$ 。在不致混淆的情况下，通常称 $v_{j}$ 是 $v_{i}$ 的邻接点。\\
（2）顶点的度、人度、出度\\
在无向图中，顶点 $v$ 的度（degree）是指依附于该顶点的边的个数，记为 $T D(v)$ 。在具有 $n$ 个顶点 $e$ 条边的无向图中，有下式成立：


\begin{equation*}
\sum_{i=0}^{n-1} T D\left(v_{i}\right)=2 e \tag{6-1}
\end{equation*}


在有向图中，顶点 $v$ 的入度（in－degree）是指以该顶点为弧头的弧的个数，记为 $I D(v)$ ；顶点 $v$ 的出度（out－degree）是指以该顶点为弧尾的弧的个数，记为 $O D(v)$ 。在具有 $n$ 个顶点 $e$ 条边的有向图中，有下式成立：


\begin{equation*}
\sum_{i=0}^{n-1} I D\left(v_{i}\right)=\sum_{i=0}^{n-1} O D\left(v_{i}\right)=e \tag{6-2}
\end{equation*}


（3）无向完全图、有向完全图\\
在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图（undirected complete graph）。含有 $n$ 个顶点的无向完全图有 $n \times(n-1) / 2$ 条边。

在有向图中，如果任意两顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图（directed complete graph）。含有 $n$ 个顶点的有向完全图有 $n \times(n-1)$ 条边。\\
（4）稠密图、稀疏图\\
称边数很少的图为稀疏图（sparse graph），反之，称为稠密图 ${ }^{(2)}$（dense graph）。\\
（5）路径、路径长度、回路\\
在无向图 $G=(V, E)$ 中，顶点 $v_{p}$ 到 $v_{q}$ 之间的路径（path）是一个顶点序列 $v_{p}=v_{i 0} v_{i 1} \cdots$ $v_{i m}=v_{q}$ ，其中，$\left(v_{i j-1}, v_{i j}\right) \in E(1 \leqslant j \leqslant m)$ ；如果 $G$ 是有向图，则 $<v_{i j-1}, v_{i j}>\in E(1 \leqslant j \leqslant$ $m)$ 。路径上边的数目称为路径长度（path length）。第一个顶点和最后一个顶点相同的路径称为回路（circuit）。显然，在图中路径可能不唯一，回路也可能不唯一。\\
（6）简单路径、简单回路\\
在路径序列中，顶点不重复出现的路径称为简单路径（simple path）。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路（simple circuit）。通

\footnotetext{（1）在线性结构中，数据元素之间的逻辑关系表现为前驱——后继；在树结构中，结点之间的逻辑关系表现为双亲——孩子；在图结构中，顶点之间的逻辑关系表现为邻接。\\
（2）稀疏和稠密本身就是模糊的概念，稀疏图和稠密图常常是相对而言的。显然，最稀疏图的边数是 0 ，最稠密图是完全图，边数达到最多。
}常情况下，路径指的都是简单路径，回路指的都是简单回路。\\
（7）子图\\
对于图 $G=(V, E)$ 和 $G^{\prime}=\left(V^{\prime}, E^{\prime}\right)$ ，如果 $V^{\prime} \subseteq V$ 且 $E^{\prime} \subseteq E$ ，则称图 $G^{\prime}$ 是 $G$ 的子图 ${ }^{(1)}$ （subgraph）。图 6－4 给出了子图的示例，显然，一个图可以有多个子图。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-188(2)}

图 6－4 子图的例子\\
（8）连通图、连通分量\\
在无向图中，若顶点 $v_{i}$ 和 $v_{j}(i \neq j)$ 之间存在路径，则称 $v_{i}$ 和 $v_{j}$ 是连通的。若任意顶点 $v_{i}$ 和 $v_{j}(i \neq j)$ 之间均有路径，则称该图是连通图（connected graph）。例如，图 6－4（a）是连通图，图 6－5（a）是非连通图。非连通图的极大连通子图称为连通分量（connected component），极大的含义是指子图在满足连通的条件下，包括所有连通的顶点以及与这些顶点相关联的所有边。图6－5（a）所示非连通图有两个连通分量，如图6－5（b）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-188}

图 6－5 非连通图及连通分量\\
（9）强连通图、强连通分量\\
在有向图中，对任意顶点 $v_{i}$ 和 $v_{j}(i \neq j)$ ，若从顶点 $v_{i}$ 到 $v_{j}$ 均有路径，则称该有向图是强连通图（strongly connected graph）。图 6－6（a）是强连通图，图 6－6（b）是非强连通图。非强连通图的极大强连通子图 ${ }^{(2)}$ 称为强连通分量（strongly connected component）。图6－6（b）所示非强连通图有两个强连通分量，如图6－6（c）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-188(1)}

图 6－6 强连通图、非强连通图及强连通分量

\footnotetext{（1）通俗地说，子图是原图的一部分，是由原图中一部分顶点和这些顶点之间的一部分边构成的图。\\
（2）此处极大的含义同连通分量。
}\section*{6．2．2 图的抽象数据类型定义}
图是一种与具体应用密切相关的数据结构，其基本操作往往随应用不同而有很大差别。下面给出一个图的抽象数据类型定义的例子，简单起见，基本操作仅包含图的遍历，针对具体应用，需要重新定义其基本操作。

\begin{verbatim}
ADT Graph
DataModel
    顶点的有穷非空集合和顶点之间边的集合
Operation
    CreatGraph
        输人:n个顶点e 条边
        功能:图的建立
        输出:构造一个含有 n 个顶点 e 条边的图
    DestroyGraph
        输人:无
        功能:图的销段
        输出:释放图占用的存储空间
    DFTraverse
        输人:遍历的起始顶点 v
        功能:从顶点v出发深度优先遍历图
        输出:图的深度优先遍历序列
    BFTraverse
        输人:遍历的起姶顶点v
        功能:从顶点v出发广度优先遍历图
        输出:图的广度优先遍历序列
endADT
\end{verbatim}

\section*{6．2．3 图的遍历操作}
图的遍历（traverse）是从图中某顶点出发，对图中所有顶点访问 ${ }^{(1)}$ 一次且仅访问一次。由于图结构本身的复杂性，所以图的遍历操作比较复杂，须解决的关键问题是：\\
（1）在图中，没有一个确定的开始顶点，任意一个顶点都可作为遍历\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-189}的起始顶点，那么，如何选取遍历的起始顶点？\\
（2）从某个顶点出发可能到达不了所有其他顶点，例如非连通图，从一个顶点出发，只能访问它所在连通分量上的所有顶点，那么，如何才能遍历图的所有顶点？\\
（3）由于图中可能存在回路，某些顶点可能会被重复访问，那么，如何避免遍历不会因回路而陷人死循环？

\footnotetext{（1）此处访问的含义同树的遍历中访问的含义。不失一般性，在此将访问定义为输出顶点的数据信息。
}
（4）在图中，一个顶点可以和其他多个顶点相邻接，当这样的顶点访问过后，如何选取下一个要访问的顶点？

问题（1）的解决：既然图中没有确定的开始顶点，那么可从图中任一顶点出发，不妨将顶点进行编号，先从编号小的顶点开始。在图中，由于任何两个顶点之间都可能存在边，顶点没有确定的先后次序，所以，顶点的编号不唯一。在图的存储实现上，一般采用一维数组存储图的顶点信息，因此，可以用顶点的存储位置（即下标）表示该顶点的编号。为了和 C＋＋语言中的数组保持一致，图的编号从 0 开始。

问题（2）的解决：要遍历图中所有顶点，只需多次重复从某一顶点出发进行图的遍历。以下仅讨论从某一顶点出发遍历图的问题。

问题（3）的解决：为了在遍历过程中区分顶点是否已被访问，设置一个访问标志数组 visited $[\mathrm{n}]$（ $n$ 为图中顶点的个数），其初值为未被访问标志 0 ，如果某顶点 $i$ 已被访问，则将该顶点的访问标志 visited［i］置为 1 。

问题（4）的解决：这就是遍历次序的问题。图的遍历通常有深度优先遍历和广度优先遍历两种方式，这两种遍历次序对无向图和有向图都适用。

深度优先遍历 ${ }^{(1)}$（depth－first traverse）类似于树的前序遍历。从图中某顶点 $v$ 出发进行深度优先遍历的基本思想是：\\
（1）访问顶点 $v$ ；\\
（2）从 $v$ 的未被访问的邻接点中选取一个顶点 $w$ ，然后从 $w$ 出发进行深度优先遍历；\\
（3）重复上述两步，直至图中所有和 $v$ 有路径相通的顶点都被访问到。\\
显然，深度优先遍历图是一个递归过程，算法思想用伪代码描述如下 ${ }^{(2)}$ ：

\begin{verbatim}
算法: DFTraverse
输人:顶点的编号 v
输出:无
    1.访问顶点v; 修改标志 visited [v]=1;
    2. w= 顶点 v 的第一个邻接点;
    3. while (w 存在)
        3.1 if (w 未被访问) 从顶点 w出发递归执行该算法;
        3.2 W=顶点 v 的下一个邻接点;
\end{verbatim}

图 6－7 给出了对无向图进行深度优先遍历的过程示例。在访问 $v_{0}$ 后选择未曾访问的邻接点 $v_{1}$ ，访问 $v_{1}$ 后选择末曾访问的邻接点 $v_{4}$ 。由于 $v_{4}$ 没有末曾访问的邻接点，递归返回到顶点 $v_{1}$ ，选择未曾访问的邻接点 $v_{2}$ 。以此类推，得到深度优先遍历序列为 $v_{0} v_{1} v_{4} v_{2} v_{3} v_{5}$ 。

广度优先遍历（breadth－first traverse）类似于树的层序遍历。从图中某顶点 $v$ 出发进行广度优先遍历的基本思想是：

\footnotetext{（1）深度优先追历睢法由约翰•霍普克洛夫特和罗伯特•陶尔扬发明。当他们的研究成果在 ACM 上发表以后，引起学术界很大的轰动，深度优先遍历算法在信息检索、人工智能等领域得到成功应用。\\
（9）该算法不依赖于图的存储结构，不涉及具体的实现细节，仅描述算法的基本思路。读者要学习并掌握这种用伪代码描述顶层算法（或算法思想）的方法。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-191(3)}

图 6－7 无向图的深度优先遍历示例\\
（1）访问顶点 $v$ ；\\
（2）依次访问 $v$ 的各个未被访问的邻接点 $v_{1}, v_{2}, \cdots, v_{k}$ ；\\
（3）分别从 $v_{1}, v_{2}, \cdots, v_{k}$ 出发依次访问它们未被访问的邻接点，直至图中所有与顶点 $v$有路径相通的顶点都被访问到。

广度优先遍历 ${ }^{(1)}$ 图以顶点 $v$ 为起始点，由近至远，依次访问和 $v$ 有路径相通且路径长度为 $1 、 2 、 \cdots$ 的顶点。为了使＂先被访问顶点的邻接点＂先于 ＂后被访问顶点的邻接点＂被访问，设置队列存储已被访问的顶点。例如，对图 6－8 所示有向图进行广度优先遍历，访问 $v_{0}$ 后将 $v_{0}$ 人队；将 $v_{0}$ 出队并依次访问 $v_{0}$ 的未曾访问的邻接点 $v_{1}$ 和 $v_{2}$ ，将 $v_{1}$ 和 $v_{2}$ 人队；将 $v_{1}$ 出队并访问 $v_{1}$ 的末曾访问的邻接点 $v_{4}$ ，将 $v_{4}$ 人队；重复上述过程，得到顶点访问序列\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-191(2)}

图 6－8 一个有向图 $v_{0} v_{1} v_{2} v_{4} v_{3}$ ，图 6－9 给出了广度优先遍历过程中队列的变化。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-191(1)}\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-191}\\
（d）$v_{2}$ 出队，$v_{3}$ 入队\\
$\qquad$\\
$\qquad$\\
（e）$v_{4} v_{3}$ 出队，队空

图 6－9 广度优先遍历过程中队列的变化

广度优先遍历的算法思想用伪代码描述如下：

算法：BFTraverse\\
输人：顶点的编号 V\\
输出：无\\
1．队列 $Q$ 初始化；\\
2．访问顶点 $v$ ；修改标志 visited $[v]=1$ ；顶点 $v$ 人队列 $Q$ ；\\
3．while（队列Q非空）\\
$3.1 \mathrm{v}=$ 队列 Q 的队头元素出队；\\
$3.2 \mathrm{w}=$ 顶点 v 的第一个邻接点；

\footnotetext{（1）广度优先遍历算法由美国计算机科学家 Edward F．Moore 在 1950 年发明，此外他还发明了有限状态自动机。
}3． 3 while（ $w$ 存在）\\
3．3．1 如果 $w$ 末被访问，则\\
访问顶点 $w$ ；修改标志 visited $[w]=1$ ；顶点 $w$ 人队列 $Q$ ；\\
$3.3 .2 \mathrm{w}=$ 顶点 v 的下一个邻接点；

\section*{6.3 图的存储结构及实现}
图是一种复杂的数据结构，任意两个顶点之间都可能存在边，所以无法通过顶点的存储位置反映顶点之间的邻接关系，因此图没有顺序存储结构。从图的定义可知，一个图包括两部分：顶点的信息以及顶点之间边的信息。无论采用什么方法存储图，都要完整、准确地表示这两方面的信息。一般来说，图的存储结构应根据具体问题的要求来设计，下面介绍两种常用的存储结构一一邻接矩阵和邻接表。

\section*{6．3．1 邻接矩阵}
\section*{1．邻接矩阵的存储结构}
图的邻接矩阵（adjacency matrix）存储也称数组表示法，用一个一维数组存储图中的顶点，用一个二维数组存储图中的边（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。设图 $G=$ $(V, E)$ 有 $n$ 个顶点，则邻接矩阵是一个 $n \times n$ 的方阵，定义为：

\[
\text { edge }[i][j]= \begin{cases}1 & \text { 若 }\left(v_{i}, v_{j}\right) \in E \text { 或 }\left\langle v_{i}, v_{j}\right\rangle \in E  \tag{6-3}\\ 0 & \text { 否则 }\end{cases}
\]

若 $G$ 是网图，则邻接矩阵定义为：

\[
\text { edge }[i][j]=\left\{\begin{array}{cl}
w_{i j} & \text { 若 }\left(v_{i}, v_{j}\right) \in E \text { 或 }\left\langle v_{i}, v_{j}\right\rangle \in E  \tag{6-4}\\
0 & \text { 若 } i=j \\
\infty & \text { 否则 }
\end{array}\right.
\]

其中，$w_{i j}$ 表示边 $\left(v_{i}, v_{j}\right)$ 或弧 $\left\langle v_{i}, v_{j}\right\rangle$ 上的权值；$\infty$ 表示一个计算机允许的、大于所有边上权值的数。图 6－10 所示为一个无向图及其邻接矩阵存储示意图，图 6－11 所示为一个有向网图及其邻接矩阵存储示意图。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-192}

图 6－10 无向图及其邻接矩阵存储示意图\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-192(1)}

图 6－11 有向网图及其邻接矩阵存储示意图

显然，无向图的邻接矩阵一定是对称矩阵，而有向图的邻接矩阵则不一定对称。在图的邻接矩阵存储中容易实现下述基本操作：\\
（1）对于无向图，顶点 $i$ 的度等于邻接矩阵中第 $i$ 行（或第 $i$ 列）非零元素的个数。对于有向图，顶点 $i$ 的出度等于邻接矩阵中第 $i$ 行非零元素的个数；顶点 $i$ 的人度等于邻接矩阵中第 $i$ 列非零元素的个数。\\
（2）判断顶点 $i$ 和 $j$ 之间是否存在边，只需测试邻接矩阵中相应位置的元素 edge［i］［j］，若其值为 1 ，则有边；否则，顶点 $i$ 和 $j$ 之间不存在边。\\
（3）查找顶点 $i$ 的所有邻接点，扫描邻接矩阵的第 $i$ 行，若 edge［i］［j］的值为 1 ，则顶点 $j$ 是顶点 $i$ 的邻接点。

\section*{2．邻接矩阵的实现}
将图的抽象数据类型定义在邻接矩阵存储结构下用 C ++ 的类实现，下面给出邻接矩阵存储的类定义，其中成员变量实现图的邻接矩阵存储，成员函数实现图的基本操作。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-193}

下面讨论邻接矩阵基本操作的实现。\\
（1）构造函数——图的建立\\
建立一个含有 $n$ 个顶点 $e$ 条边的图，顶点信息由参数 $a[n]$ 给出，边的信息由键盘输人，假设建立无向图，算法用伪代码描述如下：

算法：构造函数 MGraph\\
输人：顶点的数据信息 $a[n]$ ，顶点个数 $n$ ，边的个数 $e$\\
输出：图的邻接矩阵存储\\
1．存储图的顶点个数和边的个数；\\
2．将顶点信息存储在一维数组 vertex 中；\\
3．初始化邻接矩阵 edge；\\
4．依次输人每条边并存储在邻接矩阵 edge 中：\\
4.1 输人边依附的两个顶点的编号 $i$ 和 $j$ ；\\
4.2 将 edge［i］［j］和 edge［j］［i］的值置为 1 ；

建立无向图邻接矩阵的构造函数定义如下。

\begin{verbatim}
template <typename DataType>
MGraph<DataType> : : MGraph (DataType a [ ], int n, int e)
(
\end{verbatim}

\begin{verbatim}
int i, j, k;
vertexNum $=n$; edgeNum $=e$;
for ( $i=0$; $i$ < vertexNum; $i++$ ) //存储顶点
    vertex $[i]=a[i]$;
for ( $i=0$; $i$ < vertexNum ; $i++$ ) //初始化邻接矩阵
    for ( $j=0 ; j<$ vertexNum; $j++$ )
        edge [i] [j] $=0$;
for $(k=0 ; k<$ edgeNum; $k++) \quad / /$ 依次输人每一条边
1
    cin $\gg$ i $\gg$ j; $\quad$ //输人边依附的两个顶点的编号
    edge $[\mathrm{i}][\mathrm{j}]=1$; edge $[\mathrm{j}][\mathrm{i}]=1$; //置有边标志
\end{verbatim}

（2）析构函数——图的销毁\\
图的邻接矩阵存储是静态存储分配，在图变量退出作用域时自动释放所占内存单元，因此，图的邻接矩阵存储无须销毁，析构函数为空。\\
（3）深度优先遍历\\
在邻接矩阵存储结构下实现 $6,2,3$ 节深度优先遍历算法，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void MGraph<DataType> : : DFTraverse(int v)
{
    cout <<vertex[v]; visited[v] = 1;
    for (int j = 0; j < vertexNum; j++)
        if (edge[v][j] == 1 && visited[j] = = 0) DFTraverse(j);
\end{verbatim}

\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-194}\\
（4）广度优先遍历\\
在邻接矩阵存储结构下实现 $6,2,3$ 节广度优先遍历算法，简单起见，队列采用顺序存储且假定不会发生溢出，成员函数定义如下：

\begin{verbatim}
template <typename DataType>
void MGraph<DataType> :: BFTraverse(int v)
l
    int w, j, Q[MaxSize]; //采用顺序队列
    int front = -1, rear = -1; // 初始化队列
    cout <<vertex[v]; visited[v] = 1;
    Q[++rear] = v; // 被访问顶点人队
    while (front != rear) //当队列非空时
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-194(1)}
\end{center}

\begin{verbatim}
w = Q [++front];
1/将队头元素出以并送到 v中
for (j= 0; j < vextexNum; j++)
    if (edge[w][j] == 1 && visited[j] == 0) {
    cout <<vertex[j]; visited[j]=1;Q[++rear]=j;
\end{verbatim}

在遍历过程中，对图中每个顶点至多调用一次遍历算法，因为一旦某个顶点被标志成已被访问，就不再从它出发进行遍历。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程。图采用邻接矩阵存储，查找每个顶点的邻接点所需时间为 $O\left(n^{2}\right)$ ，所以，深度优先和广度优先遍历图的时间复杂度均为 $O\left(n^{2}\right)$ ，其中 $n$ 为图中顶点个数。

\section*{3．邻接矩阵的使用}
在定义了图的邻接矩阵存储类 MGraph 并实现了基本操作后，程序中就可以使用 MGraph 类来定义图变量，可以调用实现基本操作的函数完成相应功能。范例程序如下：

\begin{verbatim}
# include <iostream>
using namespace std;
int visited[MaxSize] = {0}; //全局数组变量 visited 初始化
//把邻接矩阵存储的类定义和各个成员函数定义放到这里
int main()
I
    int i;
    char ch[] = {'A', 'B', 'C', 'D', 'E'};
    MGraph<char> MG{ch, 5, 6}; //建立具有 5 个顶点 6条边的无向图
    for (i = 0; i < MaxSize; i ++)
        visited[i] = 0;
    cout <<"深度优先遍历序列是:";
    MG.DFTraverse(0); //从顶点0出发进行深度优先遍历
    for (i = 0; i < MaxSize; i++)
        visited[i] = 0;
    cout <<"广度优先遍历序列是:";
    MG.BFTraverse(0); //以顶点0出发进行广度优先遍历
    return 0;
}
\end{verbatim}

\section*{6．3．2 邻接表}
\section*{1．邻接表的存储结构}
\begin{verbatim}
邻接表（adjacency list）是一种顺序存储与链接存储相结合的存储方

法，类似于树的孩子表示法。对于图的每个顶点 $v$ ，将 $v$ 的所有邻接点链成一个单链表，称为顶点 $v$ 的边表（有向图则称为出边表），为了方便对所有边表的头指针进行存取操作，可以采取顺序存储。存储边表头指针的数组和存储顶点的数组构成了邻接表的表头数组，称为顶点表。所以，在邻接表中存在两种结点结构：顶点
\begin{tabular}{|l|l|}
\hline vertex & firstEdge \\
\hline
\end{tabular}

顶点表结点
adjvex
边表结点

图 6－12 邻接表的结点结构
为数据域，存放顶点信息；firstEdge 为指针域，指向边表的第一个结点；adjvex 为邻接点域，存放该顶点的邻接点在顶点表中的下标 ${ }^{(1)}$ ；next 为指针域，指向边表的下一个结点。对于网图，边表结点还需增设 info 域存储边上信息（如权值）。顶点表结点和边表结点的结构体定义如下，图 6－13 给出了无向图的邻接表存储示意图，图 6－14 给出了有向网图的邻接表存储示意图。
\end{verbatim}

struct EdgeNode\\
i\\
Int adjvex;\\
EdgeNode * next;\\
\};\\
template <typename DataType>\\
struct VertexNode\\
\{\\
DataType vertex;\\
EdgeNode * firstEdge;\\
\};

\begin{verbatim}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-196.jpg?height=307&width=1100&top_left_y=1478&top_left_x=261)

图 6－13 无向图的邻接表存储示意图
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-196.jpg?height=307&width=1047&top_left_y=1884&top_left_x=290)

图 6－14 有向网图的邻接表存储示意图

\footnotetext{
（1）注意 adjvex 不能存储邻接点的数据信息，否则会产生重复存储浪费存储空间，更严重的后果是可能出现修改不一致。
}

在图的邻接表存储结构中容易实现下述基本操作：
（1）对于无向图，顶点 $i$ 的度等于顶点 $i$ 的边表中的结点个数。对于有向图，顶点 $i$ 的出度等于顶点 $i$ 的出边表中的结点个数；顶点 $i$ 的人度等于所有出边表中以顶点 $i$ 为邻接点的结点个数。
（2）判断从顶点 $i$ 到顶点 $j$ 是否存在边，只需测试顶点 $i$ 的边表中是否存在邻接点域为 $j$ 的结点。
（3）查找顶点 $i$ 的所有邻接点，只需遍历顶点 $i$ 的边表，该边表中的所有结点都是顶点 $i$ 的邻接点。

\section*{2．邻接表的实现}

用 C＋＋语言中的类实现基于邻接表存储结构下图的抽象数据类型定义，图的邻接表存储的类定义如下，其中成员变量实现图的邻接表存储结构，成员函数实现基本操作。由于图中顶点的数据类型不确定，所以采用 C ++ 的模板机制。
\end{verbatim}

const int MaxSize = 10;／／图的最多顶点数\\
template <typename DataType>\\
class ALGraph\\
f\\
public:\\[0pt]
ALGraph (DataType a [ ], int n, int e); //构造函数\\
\~{}ALGraph(); //析构函数\\
void DFTraverse(int v); //深度优先遍历图\\
void BFTraverse(int v); //广度优先遍历图\\
private:\\
VertexNode<DataType> adjlist[MaxSize]; // 存放顶点表的数组\\
int vertexNum,edgeNum; //图的顶点数和边数\\
);

\begin{verbatim}

下面讨论邻接表基本操作的实现。
（1）构造函数——图的建立
建立一个含有 $n$ 个顶点 $e$ 条边的图，顶点信息由参数 $a[n]$ 给出，边的信息由键盘输人，假设建立有向图，算法用伪代码描述如下：

算法：构造函数 ALGraph
输人：顶点的数据信息 $a[n]$ ，顶点个数 $n$ ，边的个数 $e$
输出：图的邻接表
1．存储图的顶点个数和边的个数；
2．将顶点信息存储在顶点表中，将该顶点边表的头指针初始化为NULL；
3．依次输人边的信息并存储在边表中：
3.1 输入边所依附的两个顶点的编号 $i$ 和 $j$ ；
3.2 生成边表结点 $s$ ，其邻接点的编号为 $j$ ；
3.3 将结点 $s$ 插人到第 $i$ 个边表的表头；

建立有向图邻接表存储的构造函数定义如下。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-198.jpg?height=973&width=1396&top_left_y=309&top_left_x=174)
（2）析构函数——图的销毁
在图的邻接表存储中，边表结点是在程序运行过程中申请的，因此，需要释放所有边表结点的存储空间，析构函数定义如下：
\end{verbatim}

template <typename DataType>\\
ALGraph<DataType> : : \~{}ALGraph ()\\
f\\
EdgeNode * p = nullptr, *q = nullptr;\\
for (int i=0; i < vertexNum; i++)\\
l\\[0pt]
p=q= adjlist[i].firstEdge;\\
while (p != nullptr)\\
\{\\
p=p->next;\\
delete q; q = p;\\
\}\\
\}\\
\}

\begin{verbatim}
（3）深度优先遍历
在邻接表存储结构下实现 6．2．3 节深度优先遍历算法，成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
void ALGraph<DataType> : : DFTraverse(int v)\\
l\\
int j;\\
EdgeNode * p = nullptr;\\[0pt]
cout <<adjlist[v].vertex; visited[v] = 1;\\[0pt]
p = adjlist[v].firstEdge; //工作指针 p 指向顶点 v 的边表\\
while(p != nullptr) //依次搜索顶点 v 的邻接点 j\\
\{\\
j = p->adjvex;\\[0pt]
if(visited[j] == 0) DFTraverse(j);\\
p = p->next;\\
\}\\
\}

\begin{verbatim}
（4）广度优先遍历算法
在邻接表存储结构下实现 6.2 .3 节广度优先遍历算法，简单起见，队列采用顺序存储并且假定不会发生溢出，成员函数定义如下：
\end{verbatim}

template <typename DataType>\\
void ALGraph<DataIype> :: BETraverse(int v)\\
l\\[0pt]
int w, j, Q[MaxSize]: //来用顺序队列\\
int front = -1, rear = -1; // 初始化队列\\
EdgeNode * p = nullptr;\\[0pt]
cout <<adjlist[v].vertex; visited[v] = 1;\\[0pt]
Q[++rear] = v; // 被访问顶点人队\\
while (front != rear) //当队列非空时\\
\{\\[0pt]
W = Q[++front];\\[0pt]
p = adjlist[w],firstEdge; //工作指针 p 指向顶点 v 的边表\\
while (p != nullptr)\\
\{\\
j = p->adjvex;\\[0pt]
if (visited [j] == 0\} \{\\[0pt]
cout <<adjlist[j].vertex; visited[j] = 1;\\[0pt]
Q[++rear] = j;\\
l\\
p = p->next;\\
\}\\
\}\\
\}

\begin{verbatim}

如前所述，遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取

决于所采用的存储结构。图采用邻接表作为存储结构，遍历需要访问所有 $n$ 个顶点，查找顶点的所有邻接点所需时间为 $O(e)$ ，所以，深度优先和广度优先遍历图的时间复杂度均为 $O(n+e)$ 。

\section*{3．邻接表的使用}

在定义了图的邻接表存储类 ALGraph 并实现了基本操作后，程序中就可以使用 ALGraph 类来定义图变量，可以调用实现基本操作的函数完成相应功能，范例程序如下：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-200.jpg?height=1021&width=1391&top_left_y=675&top_left_x=146)

\section*{6．3．3 邻接矩阵和邻接表的比较}

邻接矩阵和邻接表是图的两种常用存储结构，均可用于存储有向图和无向图，也均可用于存储网图。设图 $G$ 含有 $n$ 个顶点 $e$ 条边，下面比较邻接矩阵和邻接表存储结构。

\section*{1．空间性能比较}

图的邻接矩阵是一个 $n \times n$ 的矩阵，所以其空间代价是 $O\left(n^{2}\right)$ 。邻接表的空间代价与图的边数及顶点数有关，每个顶点在顶点表中都要占据一个数组元素，且每条边必须出现在某个顶点的边表中，所以邻接表的空间代价是 $O(n+e)$ 。

邻接表仅存储实际出现在图中的边，而邻接矩阵则需要存储所有可能的边，但是，邻接矩阵不需要指针的结构性开销。一般情况下，图越稠密，邻接矩阵的空间效率相应地越高，而对稀疏图使用邻接表存储，则能获得较高的空间效率。

\section*{2．时间性能比较}

在图的算法中访问某个顶点的所有邻接点是较常见的操作。如果使用邻接表，只需要检查此顶点的边表，即只检查与它相关联的边，平均需要查找 $O(e / n)$ 次；如果使用邻接矩阵，则必须检查所有可能的边，需要查找 $O(n)$ 次。从这个操作角度来讲，邻接矩阵比邻接表的时间代价高。

\section*{3．唯一性比较}

当图中每个顶点的编号确定后，图的邻接矩阵表示是唯一的；但图的邻接表表示不是唯一的，边表中结点的次序取决于边的输人次序以及结点在边表的插人算法。

\section*{4．对应关系}

图的邻接矩阵和邻接表虽然存储方法不同，但存在着对应关系。邻接表中顶点 $i$ 的边表对应邻接矩阵的第 $i$ 行，整个邻接表可看作是邻接矩阵的带行指针的链接存储。

\section*{6.4 最小生成树}

连通图的生成树（spanning tree）是包含图中全部顶点的一个极小连通子 ${ }^{(1)}{ }^{(1)}$ 。在生成树中添加任意一条属于原图中的边必定会产生回路，因为新添加的边使其所依附的两个顶点之间有了第二条路径；在生成树中减少任意一条边，则必然成为非连通，所以一棵具有 $n$ 个顶点的生成树有且仅有 $n-1$ 条边。图6－15给出了连通图的生成树示例，显然，生成树可能不唯一。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-201.jpg?height=317&width=1090&top_left_y=1494&top_left_x=393)

图6－15 连通图及其生成树
无向连通网的生成树上各边的权值之和称为该生成树的代价，在图的所有生成树中，代价最小的生成树称为最小生成树（minimal spanning tree）。最小生成树的概念可以应用到许多实际问题中，例如，在 $n$ 个城市之间建造通信网络，至少需要架设 $n-1$ 条通信线路，每两个城市之间架设通信线路的造价是不一样的，那么如何设计才能使得总造价最小？如果用图的顶点表示城市，用边 $(u, v)$ 上的权值表示建造城市 $u$ 和 $v$ 之间的通信线路所需的费用，则最小生成树给出了建造通信网络的最优方案。

\footnotetext{
（1）极小的含义是包含全部顶点的连通子图中，生成树的边数是最少的。
}

\section*{6．4．1 Prim 算法}

设 $G=(V, E)$ 是无向连通网，$T=(U, T E)$ 是 $G$ 的最小生成树，Prim算法 ${ }^{(1)}$ 的基本思想是：从初始状态 $U=\{v\}(v \in V) 、 T E=\{ \}$ 开始，重复执行下述操作：在所有 $i \in U 、 j \in V-U$ 的边中找一条代价最小的边 $(i, j)$ 并人集合 $T E$ ，同时 $j$ 并人 $U$ ，直至 $U=V$ 为止，此时 $T E$ 中有 $n-1$ 条边，$T$ 是一棵最小生成树。Prim算法的基本思想用伪代码描述如下：
\end{verbatim}

算法:Prim\\
输人:无向连通网 G= (V,E)\\
输出:最小生成树 T=(U,TE)\\
1. 初始化: U=\{v\}; TE=\{\};\\
2. 重复下述操作直到 U= V:\\
2.1在E中寻找最短边 (i, j),且满足 i \}=U,j\textbackslash inV-U\textbackslash mathrm\{ ;\\
2.2 U=U+\{j\};\\
2.3TE=TE+\{(i,j)\};

\begin{verbatim}

显然，Prim算法的关键是如何找到连接 $U$ 和 $V-U$ 的最短边来扩充生成树 $T$ 。设当前 $T$ 中有 $k$ 个顶点，则所有满足 $i \in U$ 且 $j \in V-U$ 的边最多有 $k \times(n-k)$ 条，从如此之大的边集中选取最短边需要花费较多时间。注意到，对于 $V-U$ 中的每个顶点，只需保留从该顶点到 $U$ 中某顶点的最短边，则 $V-U$ 中 $n-k$ 个顶点所关联的 $n-k$ 条最短边构成候选最短边集。

对于图 6－16（a）所示连通网，图6－16（b）～（f）给出了从顶点 $v_{0}$ 出发，用 Prim 算法构造最小生成树的过程，其中粗线的顶点属于顶点集 $U$ ，粗边属于边集 $T E$ ，cost 表示候选最短边集，cost 中的黑体表示将要加人 $T E$ 的最短边。

下面讨论 Prim 算法基于的存储结构。
（1）图的存储结构：由于在算法执行过程中，需要不断读取任意两个顶点之间边的权值，所以，图采用邻接矩阵存储。
（2）候选最短边集：设数组 adjvex $[\mathrm{n}]$ 和 lowcost $[\mathrm{n}]$ 分别表示候选最短边的邻接点和权值，数组元素 adjvex $[i]$ 和 lowcost $[i]$ 的值如式（6－5）所示，其含义是候选最短边 $(i, j)$ 的权值为 $w$ ，其中 $i \in V-U, j \in U$ 。

$$
\left\{\begin{array}{l}
\operatorname{adjvex}[\mathrm{i}]=\mathrm{j}  \tag{6-5}\\
\operatorname{low} \operatorname{cost}[\mathrm{i}]=\mathrm{w}
\end{array}\right.
$$


初始时，$U=\{v\}$, lowcost $[v]=0$ 表示顶点 $v$ 已加人集合 $U$ 中，数组元素 adjvex $[i]=$ v ，low cost $[\mathrm{i}]=$ 边 $(v, i)$ 的权值 $(1 \leqslant i \leqslant n-1)$ 。每一轮迭代时，在数组 lowcost $[\mathrm{n}]$ 中选取最小权值 lowcost $[j]$ ，由于顶点 $j$ 从集合 $V-U$ 进入集合 $U$ 后，候选最短边集发生了变

\footnotetext{
（1）普里姆（Robert Clay Prim，1921年出生）1941 年获得电气工程学士学位，1949 年获得普林斯顿大学硕士学位。1941年到1944年任通用电器公司的工程师，1944年到1949年任美国海军军械实验室的工程师，1948年到1949年任普林斯顿大学的副研究员，1958 年到1961年任贝尔电话实验室的数学与力学研究部主任，以及圣地亚公司的研究副总裁。
}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-203.jpg?height=325&width=406&top_left_y=230&top_left_x=215)
（a）连通网，$U=\left\{v_{0}\right\}$
cost $=\left\{\left(v_{0}, v_{1}\right) 34,\left(v_{0}, v_{2}\right) 46\right.$ ，
$\left.\left(v_{0}, v_{3}\right) \infty,\left(v_{0}, v_{4}\right) \infty,\left(v_{0}, v_{5}\right) 19\right\}$
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-203.jpg?height=325&width=394&top_left_y=743&top_left_x=226)
（d）$U=\left\{v_{0}, v_{5}, v_{2}, v_{3}\right\}$
cost $=\left\{\left(v_{0}, v_{1}\right) 34,\left(v_{5}, v_{4}\right) 26\right\}$
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-203.jpg?height=325&width=399&top_left_y=230&top_left_x=739)
（b）$U=\left\{v_{0}, v_{5}\right\}$
cost $=\left\{\left(v_{0}, v_{1}\right) 34,\left(v_{5}, v_{2}\right) 25\right.$ ， $\left.\left(v_{5}, v_{3}\right) 25,\left(v_{5}, v_{4}\right) 26\right\}$
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-203.jpg?height=330&width=394&top_left_y=743&top_left_x=744)
（e）$U=\left\{v_{0}, v_{5}, v_{2}, v_{3}, v_{4}\right\}$ cost $=\left\{\left(v_{4}, v_{1}\right) 12\right\}$
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-203.jpg?height=330&width=407&top_left_y=228&top_left_x=1255)
（c）$U=\left\{v_{0}, v_{5}, v_{2}\right\}$ cost $=\left\{\left(v_{0}, v_{1}\right) 34,\left(v_{2}, v_{3}\right) 17\right.$ ， $\left.\left(v_{5}, v_{4}\right) 26\right\}$
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-203.jpg?height=330&width=394&top_left_y=743&top_left_x=1264)
（f）$U=\left\{v_{0}, v_{5}, v_{2}, v_{3}, v_{4}, v_{1}\right\}$ cost $=\{ \}$

图 6－16 Prim 算法构造最小生成树的过程

化，依据式（6－6）对数组 adjvex［n］和 lowcost［n］进行更新，然后将 lowcost［j］置为 0，表示将顶点 $j$ 加人集合 $U$ 中。

$$
\left\{\begin{array}{l}
\operatorname{lowcost}[i]=\min \{\operatorname{low} \operatorname{cost}[i], \text { 边 }(i, j) \text { 的权值 }\}  \tag{6-6}\\
\operatorname{adjvex}[i]=j(\text { 如果边 }(i, j) \text { 的权值 }<\text { lowcost }[i])
\end{array}\right.
$$


表 6－1 给出了 Prim 算法对图 6－16 所示无向连通网构造最小生成树的过程中，数组 adjvex 和 lowcost 及集合 $U$ 的变化情况，黑体表示将要加入 $T E$ 中的最短边。

表 6－1 Prim 算法构造最小生成树过程中各参数的变化
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
\hline shortEdge & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$ & $v_{5}$ & U & 输 出 \\
\hline adjvex lowcost & 0 0 & 0 34 & 0 46 & 0 $\infty$ & 0 $\infty$ & 0 19 & $\left\{v_{0}\right\}$ & $\left(v_{0}, v_{5}\right) 19$ \\
\hline adjvex lowcost & \multirow{5}{*}{} & 0 34 & 5 25 & 5 25 & 5 26 & 0 0 & $\left\{v_{0}, v_{5}\right\}$ & $\left(v_{5}, v_{2}\right) 25$ \\
\hline adjvex lowcost & & 0 34 & 5 0 & 2 17 & 5 26 & \multirow{4}{*}{} & $\left\{v_{0}, v_{5}, v_{2}\right\}$ & $\left(v_{2}, v_{3}\right) 17$ \\
\hline adjvex lowcost & & 0 34 & \multirow{3}{*}{} & 2 0 & 5 26 & & $\left\{v_{0}, v_{5}, v_{2}, v_{3}\right\}$ & $\left(v_{5}, v_{4}\right) 26$ \\
\hline adjvex lowcost & & 4 12 & & \multirow{2}{*}{} & 5 0 & & $\left\{v_{0}, v_{5}, v_{2}, v_{3}, v_{4}\right\}$ & $\left(v_{4}, v_{1}\right) 12$ \\
\hline adjvex lowcost & & 4 0 & & & & & $\left\{v_{0}, v_{5}, v_{2}, v_{3}, v_{4}, v_{1}\right\}$ & \\
\hline
\end{tabular}

Prim 算法采用邻接矩阵作为存储结构，可以将 Prim 函数作为 MGraph 的公有成员函数，也可以将 Prim 函数设为 Mgraph 的友元函数，函数定义如下。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-204.jpg?height=1024&width=1391&top_left_y=365&top_left_x=136)

MinEdge 函数实现在数组 lowcost 中查找最小权值并返回其下标，请读者自行完成。
分析 Prim 算法，设连通网中有 $n$ 个顶点，则第一个进行初始化的循环语可需要执行 $n$ 次，第二个循环共执行 $n-1$ 次，内嵌两个循环，其一是在长度为 $n$ 的数组中求最小值，需要执行 $n-1$ 次，其二是调整辅助数组，需要执行 $n-1$ 次，所以，Prim 算法的时间复杂度为 $O\left(n^{2}\right)$ ，与网中的边数无关，因此适用于求稠密网的最小生成树。

\section*{6．4．2 Kruskal 算法}

设 $G=(V, E)$ 是无向连通网，$T=(U, \mathrm{TE})$ 是 $G$ 的最小生成树， Kruskal 算法 ${ }^{(1)}$ 的基本思想是：初始状态为 $U=V 、 T E=\{ \}$ ，即 $T$ 中的顶点各自构成一个连通分量，然后按照边的权值由小到大的顺序，依次考察边集 $E$ 中的各条边。若被考察边的两个顶点属于两个不同的连通分量，则将此边加人到 TE 中，同时把两个连通分量连接为一个连通分量；若被考察边的两个顶点属于同一个连通分量，则舍去此边，以免造成回路，如此下去，当 $T$ 中的连通分量个数为 1时，此连通分量便为 $G$ 的一棵最小生成树。Kruskal算法的基本思想用伪代码描述如下：

\footnotetext{
（1）克鲁斯卡尔（Joseph Bernard Kruskal，1928年出生），1954年获得普林斯顿大学博士学位。当克鲁斯卡尔还是二年级的研究生时，发明了最小生成树算法，当时他甚至不能肯定关于这个题目的 2 页半的论文是否值得发表。除了最小生成树之外，克鲁斯卡尔还因对多维分析的贡献而著名。
}

算法：Kruska1算法
输人：无向连通网 $G=(V, E)$
输出：最小生成树 $\mathrm{T}=(\mathrm{U}, \mathrm{TE})$
1．初始化：$U=V ; T E=\{ \}$ ；
2．重复下述操作直到所有顶点位于一个连通分量：
2．1在 E 中选取最短边（ $\mathrm{u}, \mathrm{v}$ ）；
2.2 如果顶点 $u 、 v$ 位于两个连通分量，则

2．2．1 将边 $(u, v)$ 并人TE；
2．2．2 将这两个连通分量合成一个连通分量；
2,3 在 $E$ 中标记边 $(u, v)$ ，使得 $(u, v)$ 不参加后续最短边的选取；

显然，实现 Kruskal 算法的关键是：如何判断被考察边的两个顶点是否位于两个连通分量（即是否与生成树中的边形成回路）。如果将同一个连通分量的顶点放人一个集合中，则 Kruskal 算法需要判断被考察边的两个顶点是否位于两个集合，以及将两个集合进行合并等操作。对于图 6－16（a）所示无向连通网，图 6－17 给出了用 Kruskal 算法构造最小生成树的过程。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-205.jpg?height=934&width=1383&top_left_y=1073&top_left_x=293)

图 6－17 Kruskal 算法构造最小生成树的过程

下面讨论 Kruskal 算法基于的存储结构。
（1）图的存储结构：因为 Kruskal 算法依次对图中的边进行操作，因此考虑采用边集数组（edge set array）存储。为了提高查找最短边的速度，可以先对边集数组按边上的权值排序。图 6－18 给出了无向连通网的边集数组存储示意图，边集数组元素的结构体定义如下：
struct
int from，to，weight；
\} EdgeType;
／／定义边集数组的元素类型
$/ /$ 假设权值为整数
vertex［6］$=$\begin{tabular}{|l|l|l|l|l|l|}
\hline$v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$ & $v_{5}$ \\
\hline
\end{tabular}
\begin{tabular}{r|r|r|r|r|r|r|r|r|r|}
\multirow{2}{*}{\begin{tabular}{r} 
下标 \\
from \\
to \\
weight
\end{tabular}} & \multicolumn{1}{r}{0} & \multicolumn{1}{r}{1} & \multicolumn{1}{r}{2} & \multicolumn{1}{r}{3} & \multicolumn{1}{r}{4} & \multicolumn{1}{r}{5} & \multicolumn{1}{r}{6} & \multicolumn{1}{r}{8} \\
\cline { 2 - 10 } & 1 & 2 & 0 & 2 & 3 & 4 & 0 & 3 & 0 \\
\cline { 2 - 10 } & 4 & 3 & 5 & 5 & 5 & 5 & 1 & 4 & 2 \\
\cline { 2 - 9 } & 12 & 17 & 19 & 25 & 25 & 26 & 34 & 38 & 46 \\
\cline { 2 - 9 } & & & & & & & & &
\end{tabular}
（b）边集数组存储

图 6－18 无向网图及其边集数组存储示意图
（2）连通分量的顶点所在的集合：由于涉及集合的查找和合并等操作，考虑采用并查集来实现。并查集是将集合中的元素组织成树的形式，合并两个集合，即将一个集合的根结点作为另一个集合根结点的孩子，图 6－19 给出了并查集的合并过程示例。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-206.jpg?height=353&width=1350&top_left_y=1142&top_left_x=126)

图 6－19 并查集的合并操作
为了便于在并查集中进行查找和合并操作，树采用双亲表示法存储。设数组 parent［n］，元素 parent［i］表示顶点 i 的双亲 $(0 \leqslant i \leqslant n-1)$ 。初始时，令 parent $[\mathrm{i}]=-1$ ，表示顶点 i没有双亲，即每个集合只有一个元素。对于边 $(u, v)$ ，设 vex1 和 vex2 分别表示两个顶点所在集合的根，如果 vex $1 \neq \mathrm{vex} 2$ ，则顶点 $u$ 和 $v$ 一定位于两个集合，令 parent $[\mathrm{vex} 2]=$ vex1，实现合并两个集合。表 6－2 给出了 Kruskal 算法对图 6－16（a）所示无向连通网构造最小生成树的过程中，数组 parent 及边集 TE 的变化情况。

表 6－2 Kruskal 算法构造最小生成树过程中 parent 数组的变化情况
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|}
\hline 顶点集 V数组 parent & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$ & $v_{5}$ & 被考查边 & 输出 $T E$ & 说 明 \\
\hline parent & －1 & －1 & －1 & －1 & －1 & －1 & & & 初始化 $\left\{v_{0}\right\}\left\{v_{1}\right\}\left\{v_{2}\right\}\left\{v_{3}\right\}\left\{v_{4}\right\}\left\{v_{5}\right\}$ \\
\hline parent & －1 & －1 & －1 & －1 & 1 & －1 & $\left(v_{1}, v_{4}\right) 12$ & $\left(v_{1}, v_{4}\right) 12$ & $$
\begin{aligned}
& \operatorname{vex} 1=1, \operatorname{vex} 2=4 \\
& \operatorname{parent}[4]=1 \\
& \left\{v_{0}\right\}\left\{v_{1}, v_{4}\right\}\left\{v_{2}\right\}\left\{v_{3}\right\}\left\{v_{5}\right\}
\end{aligned}
$$ \\
\hline
\end{tabular}

续表
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|}
\hline 顶点集 $V$数组 parent & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$ & $v_{5}$ & 被考查边 & 输出 $T E$ & 说 明 \\
\hline parent & －1 & －1 & －1 & 2 & 1 & －1 & $\left(v_{2}, v_{3}\right) 17$ & $\left(v_{2}, v_{5}\right) 17$ & vex1 $=2$, vex $2=3$ parent $[3]=2$ $\left\{v_{0}\right\}\left\{v_{1}, v_{4}\right\}\left\{v_{2}, v_{3}\right\}\left\{v_{5}\right\}$ \\
\hline parent & －1 & －1 & －1 & 2 & 1 & 0 & （ $v_{0}, v_{5}$ ） 19 & （ $v_{0}, v_{5}$ ） 19 & vex $1=0$, vex $2=5$ parent［5］$=0$ $\left\{v_{0}, v_{5}\right\}\left\{v_{1}, v_{4}\right\}\left\{v_{2}, v_{3}\right\}$ \\
\hline parent & 2 & －1 & －1 & 2 & 1 & 0 & （ $v_{2}, v_{5}$ ）25 & （ $v_{2}, v_{5}$ ）25 & vex1 $=2$ ，vex2 $=0$ parent $[0]=2$ $\left\{v_{0}, v_{5}, v_{2}, v_{3}\right\}\left\{v_{1}, v_{4}\right\}$ \\
\hline parent & 2 & －1 & －1 & 2 & 1 & 0 & $\left(v_{3}, v_{5}\right) 25$ & & vex $1=2$, vex $2=2$所在根结点相同 \\
\hline parent & 2 & －1 & 1 & 2 & 1 & 0 & （ $v_{4}, v_{5}$ ）26 & （ $v_{1}, v_{5}$ ）26 & vex $1=1$ ，vex $2=2$ parent［2］$=1$ $\left\{v_{0}, v_{5}, v_{2}, v_{3}, v_{1}, v_{4}\right\}$ \\
\hline
\end{tabular}

下面给出图的边集数组存储的类定义，其中成员变量实现图的边集数组存储结构，成员函数实现 Kruskal 算法。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-207.jpg?height=774&width=1393&top_left_y=1245&top_left_x=285)

下面给出 Kruskal 算法的成员函数定义，构造函数请读者自行设计。
\end{verbatim}

void Kruskal()\\
\{\\
int num = 0, i, vex1, vex2;\\[0pt]
int parent[vertexNum]; //双亲表示法存储并查集\\
for (i = 0; i < vertexNum; i++)

\begin{verbatim}

\end{verbatim}

\begin{verbatim}
    parent[i] = -1;$/ /$ 初始化 n 个连通分量
for (num = 0, i=0; num < vertexNum-1; i++)//依次考察最短边
    %
    vex1 = FindRoot(parent, edge[i].from);
    vex2 = FindRoot (parent, edge[i],to);
    if (vex1 != vex2) ( //位于不同的集合
        cout <<"("<<edge[i].from <<"," <<edge[i].to <<")" <<edge[i].weight;
        parent [vex2] = vex1; //合并集合
        num++;
    }
}
\end{verbatim}

)\\[0pt]
int FindRoot (int parent [], int v)\\
f\\
int t = v;\\[0pt]
while (parent [t] > -1) //求顶点 t的双亲一直到根\\[0pt]
t= parent[t];\\
return t;\\
\}

\begin{verbatim}

分析 Kruskal 算法，设连通网中有 $n$ 个顶点 $e$ 条边，则第一个进行初始化的循环语句需要执行 $n$ 次，第二个循环最多执行 $e$ 次，最少执行 $n-1$ 次，函数 FindRoot 的循环语句最多执行 $\log _{2} n$ 次，在执行 Kruskal 算法之前对边集数组排序需要 $O\left(e \log _{2} e\right)$ ，所以， Kruskal 算法的时间复杂度为 $O\left(e \log _{2} e\right)$ 。相对于 Prim 算法而言，Kruskal 算法适用于求稀疏网的最小生成树。

\section*{6.5 最短路径}

在非网图中，最短路径（shortest path）是指两顶点之间经历的边数最少的路径。路径上的第一个顶点称为源点（source），最后一个顶点称为终点（destination）。例如，对于图6－20（a）所示有向图，顶点 $v_{0}$ 到 $v_{4}$ 的最短路径是 $v_{0} v_{4}$ 。在网图中，最短路径是指两顶点之间经历的边上权值之和最少的路径。例如，对于图 6－20（b）所示有向网图，顶点 $v_{0}$ 到 $v_{4}$的最短路径是 $v_{0} v_{3} v_{2} v_{4}$ ，最短路径长度是 60 。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-208.jpg?height=394&width=906&top_left_y=1968&top_left_x=348)

图 6－20 网图和非网图中最短路径的含义

最短路径问题是图的一个比较典型的应用问题。例如，给定某公路网的 $n$ 个城市以及这些城市之间相通公路的距离，能否找到城市 A 到城市 B 之间一条距离最近的通路呢？如果将城市用顶点表示，城市间的公路用边表示，公路的长度作为边的权值，这个问题就归结为在网图中求顶点 $A$ 到顶点 $B$ 的最短路径。

\section*{6．5．1 Dijkstra 算法}

Dijkstra ${ }^{(1)}$ 算法用于求单源点最短路径问题，问题描述如下：给定有向网图 $G=(V, E)$ 和源点 $v \in V$ ，求从 $v$ 到 $G$ 中其余各顶点的最短路径。

Dijkstra 算法的基本思想是：将顶点集合 $V$ 分成两个集合，一类是生
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-209.jpg?height=310&width=243&top_left_y=452&top_left_x=1406)长点的集合 $S$ ，包括源点和已经确定最短路径的顶点；另一类是非生长点的集合 $V-S$ ，包括所有尚未确定最短路径的顶点，并使用一个待定路径表，存储当前从源点 $v$ 到每个非生长点 $v$ 的最短路径。初始时，$S$ 只包含源点 $v$ ，对 $v_{i} \in V-S$ ，待定路径表为从源点 $v$ 到 $v_{i}$的有向边。然后在待定路径表中找到当前最短路径 $v \cdots v_{k}$ ，将 $v_{k}$ 加人集合 $S$ 中，对 $v_{i} \in V$ $-S$ ，将路径 $v \cdots v_{k} v_{i}$ 与待定路径表中从源点 $v$ 到 $v_{i}$ 的最短路径相比较，取路径长度较小者为当前最短路径。重复上述过程，直到集合 $V$ 中全部顶点加人到集合 $S$ 中。Dijkstra 算法的基本思想如图 6－21 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-209.jpg?height=272&width=850&top_left_y=1190&top_left_x=490)

图 6－21 Dijkstra 算法的基本思想图解
Dijkstra 算法按路径长度递增的次序产生最短路径，图 6－22 给出了对图 6－20（b）所示有向网图求最短路径的过程，其中，加粗的顶点表示生长点，粗线表示已求得的最短路径。

下面讨论 Dijkstra 算法基于的存储结构。
（1）图的存储结构：因为在算法执行过程中，需要快速求得任意两个顶点之间边上的权值，所以，图采用邻接矩阵存储。
（2）辅助数组 $\operatorname{dist}[\mathrm{n}]$ ：元素 $\operatorname{dist}[\mathrm{i}]$ 表示当前所找到的从源点 $v$ 到终点 $v_{i}$ 的最短路径长度。初态为：若从 $v$ 到 $v_{i}$ 有弧，则 dist［ i ］为弧上的权值；否则置 dist $[\mathrm{i}]$ 为 $\infty$ 。若当前求得的终点为 $v_{k}$ ，则根据式（6－7）进行迭代：

$$
\begin{equation*}
\operatorname{dist}[i]=\min \{\operatorname{dist}[i], \operatorname{dist}[k]+\operatorname{edge}[k][i]\} \quad 0 \leqslant i \leqslant n-1 \tag{6-7}
\end{equation*}
$$

（3）辅助数组 path［n］：元素 path［i］是一个字符串，表示当前从源点 $v$ 到终点 $v_{i}$ 的最

\footnotetext{
（1）迪杰斯特拉（Edsgar Dijkstra，1930年出生）1972 年图灵奖获得者，因最早指出＂goto 是有害的＂以及首创结构化程序设计而闻名。1956年，他发现了在两个顶点之间找一条最短路径的迪杰斯特拉算法，该算法解决了机器人学中的一个十分关键的问题，即运动路径规划问题，至今仍被广泛使用。
}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-210.jpg?height=799&width=1293&top_left_y=233&top_left_x=149)

图 6－22 Dijkstra 算法的求解过程
短路径。初态为：若从 $v$ 到 $v_{i}$ 有弧，则 path $[i]$ 为 $v v v_{i}{ }^{\prime \prime}$ ，否则置 path［i］为空串。
（4）集合 S ：若某顶点 $v_{k}$ 的最短路径已经求出，则将 $\operatorname{dist}[\mathrm{k}]$ 置为 0 ，即数组 $\operatorname{dist}[\mathrm{n}]$ 中值为 0 对应的顶点即是集合 $S$ 中的顶点，因此，也可以不保存集合 $S$ 。

Dijkstra 算法用伪代码描述如下，对图6－20（b）所示有向网执行 Dijkstra 算法，求得从顶点 $v_{0}$ 到其余各顶点的最短路径，以及算法执行过程中数组 dist 和 path 的变化状况，如表6－3所示。

算法：Dijkstra 算法
输人：有向网图 $G=(V, E)$ ，源点 $V$
输出：从 v 到其他所有顶点的最短路径
1．初始化：$S=\{v\}$ ；dist $[j]=$ edge $[v][j](0 \leqslant j \leqslant n)$ ；
2．重复下述操作直到 $S$ 等于 $V$ ：
2.1 dist $[k]=\min \{$ dist $[i]\} \quad(i \in V-S)$ ；

2．2 S＝S＋\｛k\};
2.3 dist $[i]=\min ($ dist $[i]$ ，dist $[k]+$ edge［k］［i］\} $(i \in V-S)$ ；

表 6－3 Dijkstra 算法的执行过程中各参量的变化
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
\hline \multirow{3}{*}{$s$} & \multicolumn{8}{|c|}{从 $v_{0}$ 到各靠点的最短路经} \\
\hline & \multicolumn{2}{|c|}{$v_{1}$} & \multicolumn{2}{|c|}{$v_{2}$} & \multicolumn{2}{|c|}{$v_{3}$} & \multicolumn{2}{|c|}{$v_{4}$} \\
\hline & dist［1］ & path［1］ & dist［2］ & path［2］ & dist［3］ & path［3］ & dist［4］ & path［4］ \\
\hline \｛ $v_{0}$ \} & 10 & $" v_{0} v_{1} "$ & $\infty$ & ＂＂ & 30 & $" v_{0} v_{3} "$ & 100 & ＂$v_{0} v_{4}$＂ \\
\hline $\left\{v_{0} v_{1}\right\}$ & \multicolumn{2}{|l|}{输出 $10, ~ " v_{0} v_{1} "$} & 60 & ＂$v_{0} v_{1} v_{2}$＂ & 30 & ＂$v_{0} v_{3}$＂ & 100 & ＂$v_{0} v_{4}$＂ \\
\hline
\end{tabular}

续表
\begin{tabular}{|l|l|l|l|l|}
\hline \multirow{3}{*}{s} & \multicolumn{4}{|c|}{从 $v_{v}$ 到各终点的最短路径} \\
\hline & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$ \\
\hline & dist［1］ & dist［2］ & dist［3］ & dist［4］ \\
\hline $\left\{\begin{array}{lll}v_{0} & v_{1} & v_{3}\end{array}\right\}$ & \multirow{3}{*}{} & 50 & 输出 $30, ~ " v_{0} v_{3} "$ & 90 \\
\hline $\left\{\begin{array}{llll}v_{0} & v_{1} & v_{3} & v_{2}\end{array}\right\}$ & & 输出 $50, ~ " v_{0} v_{3} v_{2} "$ & \multirow{2}{*}{} & 60 \\
\hline $\left\{\begin{array}{lllll}v_{0} & v_{1} & v_{3} & v_{2} & v_{4}\end{array}\right\}$ & & & & 输出 $60, ~ " v_{0} v_{3} v_{2} v_{4} "$ \\
\hline
\end{tabular}

Dijkstra 算法采用邻接矩阵作为存储结构，可以将 Dijkstra 函数作为 MGraph 的公有成员函数，也可以将 Dijkstra 函数设为 Mgraph 的友元函数，函数定义如下。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-211.jpg?height=1230&width=1398&top_left_y=846&top_left_x=288)

Min 函数要在数组 dist 中查找最小值并返回其下标，请读者自行设计。
分析 Dijkstra 算法的时间性能，设图有 $n$ 个顶点，第一个循环执行 $n$ 次；第二个循环执行 $n-1$ 次，内嵌两个循环，第一个循环是在数组 dist 中求最小值，执行 $n-1$ 次，第二个循环是修改数组 dist 和 path，需要执行 $n$ 次，所以总的时间复杂度是 $O\left(n^{2}\right)$ 。

\section*{6．5．2 Floyd 算法}

Floyd ${ }^{(1)}$ 算法用于求每一对顶点之间的最短路径问题，问题描述如一下：给定带权有向图 $G=(V, E)$ ，对任意顶点 $v_{i}$ 和 $v_{j}(i \neq j)$ ，求顶点 $v_{i}$ 到顶点 $v_{j}$ 的最短路径。

Floyd 算法的基本思想是：假设从 $v_{i}$ 到 $v_{j}$ 的弧（若不存在从 $v_{i}$ 到 $v_{j}$ 的
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-212.jpg?height=315&width=256&top_left_y=240&top_left_x=1308)弧，则权值为 $\infty$ ）是最短路径，然后进行 $n$ 次试探。首先比较 $v_{i} v_{j}$ 和 $v_{i} v_{0} v_{j}$ 的路径长度，取长度较短者作为从 $v_{i}$ 到 $v_{j}$ 中间顶点的编号不大于 0 的最短路径。在路径上再增加一个顶点 $v_{1}$ ，将 $v_{i} \cdots v_{1} \cdots v_{j}$ 和已经得到的从 $v_{i}$ 到 $v_{j}$ 中间顶点的编号不大于 0 的最短路径相比较，取长度较短者作为中间顶点的编号不大于 1 的最短路径。以此类推，在一般情况下，若 $v_{i}$ $\cdots v_{k}$ 和 $v_{k} \cdots v_{j}$ 分别是从 $v_{i}$ 到 $v_{k}$ 和从 $v_{k}$ 到 $v_{j}$ 中间顶点的编号不大于 $k-1$ 的最短路径，则将 $v_{i} \cdots v_{k} \cdots v_{j}$ 和已经得到的从 $v_{i}$ 到 $v_{j}$ 中间顶点的编号不大于 $k-1$ 的最短路径相比较，取长度较短者为从 $v_{i}$ 到 $v_{j}$ 中间顶点的编号不大于 $k$ 的最短路径。经过 $n$ 次比较后，最后求得的必是从 $v_{i}$ 到 $v$ ，的最短路径，如图 6－23 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-212.jpg?height=274&width=954&top_left_y=1046&top_left_x=349)

图 6－23 Floyd 算法的基本思想图解（实线代表弧，虚线代表路径）
下面讨论 Floyd 算法基于的存储结构。
（1）图的存储结构：同 Dijkstra 算法类似，采用邻接矩阵作为图的存储结构。
（2）辅助数组 dist［n］［n］；存放在迭代过程中求得的最短路径长度。初始为图的邻接矩阵，在迭代过程中，根据如下递推关系式进行迭代：

$$
\left\{\begin{array}{l}
\operatorname{dist}_{-1}[\mathrm{i}][\mathrm{j}]=\operatorname{edge}[\mathrm{i}][\mathrm{j}]  \tag{6-8}\\
\operatorname{dist}_{\mathrm{k}}[\mathrm{i}][\mathrm{j}]=\min \left\{\operatorname{disk}_{\mathrm{k}-1}[\mathrm{i}][\mathrm{j}], \operatorname{disk}_{\mathrm{k}-1}[\mathrm{i}][\mathrm{k}]+\operatorname{disk}_{\mathrm{k}-1}[\mathrm{k}][\mathrm{j}]\right\} \quad 0 \leqslant \mathrm{k} \leqslant \mathrm{n}-1
\end{array}\right.
$$


其中， $\operatorname{dist}_{\mathrm{k}}[\mathrm{i}][\mathrm{j}]$ 是从顶点 $v_{i}$ 到 $v_{j}$ 的中间顶点的编号不大于 $k$ 的最短路径的长度。
（3）辅助数组 path $[\mathrm{n}][\mathrm{n}]$ ：在迭代中存放从 $v_{i}$ 到 $v_{j}$ 的最短路径，初始为 path $[\mathrm{i}][\mathrm{j}]=$ ＂ $\mathrm{v}_{\mathrm{i}} \mathrm{v}_{\mathrm{j}}$＂。

图 6－24 给出了一个有向网及其邻接矩阵。图 6－25 给出了用 Floyd 算法求该有向网中每对顶点之间的最短路径过程中，数组 dist 和数组 path 的变化情况。

Floyd 算法采用邻接矩阵作为存储结构，可以将 Floyd 函数作为 MGraph 的公有成员函数，也可以将 Floyd 函数设为 Mgraph 的友元函数，函数定义如下。

\footnotetext{
（1）弗洛伊德（Robert•Floyd）1936年生于纽约，1953年获得芝加哥大学的文学学士学位。弗洛伊德在计算机科学的诸多领域，诸如算法、程序设计语言的逻辑和语义、自动程序综合、自动程序验证、编译器的理论和实现等方面都作出创造性的贡献。在算法方面，弗洛伊德在1964年发明了著名的堆排序算法。此外还有直接以弗洛伊德命名的求最短路径的算法，这是弗洛伊德利用动态规划的原理设计的一个高效算法。
}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-213.jpg?height=203&width=694&top_left_y=230&top_left_x=558)

图 6－24 一个有向网图及其邻接矩阵

$$
\begin{array}{r}
\operatorname{dist}_{-1}\left(\begin{array}{ccc}
0 & 4 & 11 \\
6 & 0 & 2 \\
3 & \infty & 0
\end{array}\right) \\
\operatorname{path}_{-1}=\left(\begin{array}{ccc} 
& a b & a c \\
b a & & b c \\
c a & &
\end{array}\right)
\end{array}
$$

（a）初始化

$$
\begin{aligned}
& \operatorname{dist}_{0}=\left(\begin{array}{lll}
0 & 4 & 11 \\
6 & 0 & 2 \\
3 & 7 & 0
\end{array}\right) \\
& \operatorname{path}_{0}=\left(\begin{array}{lll} 
& a b & a c \\
b a & & b c \\
c a & c a b &
\end{array}\right)
\end{aligned}
$$

（b）加入顶点 a

$$
\begin{aligned}
& \text { dist }_{1}=\left(\begin{array}{lll}
0 & 4 & 6 \\
6 & 0 & 2 \\
3 & 7 & 0
\end{array}\right) \\
& \text { path }_{1}=\left(\begin{array}{ll} 
& a b \\
b a & \\
b c \\
c a & c a b
\end{array}\right)
\end{aligned}
$$

（c）加入顶点b

$$
\begin{aligned}
& \operatorname{dist}_{2}=\left(\begin{array}{lll}
0 & 4 & 6 \\
5 & 0 & 2 \\
3 & 7 & 0
\end{array}\right) \\
& \operatorname{path}_{2}=\left(\begin{array}{ll} 
& a b \\
b c a & b c \\
c a & c a b
\end{array}\right)
\end{aligned}
$$

（d）加人顶点 c

图 6－25 Floyd 算法执行中数组 dist 和 path 的变化
\end{verbatim}

void Floyd()\\
t\\[0pt]
int i, j, k, dist[MaxSize][MaxSize];\\[0pt]
string path[MaxSize] [MaxSize];\\
for (i = 0; i < vertexNum; i++) // 初始化矩阵 dist 和 path\\
for (j) = 0; j < vertexNum; j++)\\
\{\\[0pt]
dist[i][j] = edge[i][j];\\[0pt]
if (dist[i][j] != 100) //假设 100 为权的最大值\\[0pt]
path[i][j]= vertex[i] + vertex[j];\\[0pt]
else path[i][j] = "";\\
)\\
for (k = 0; k < vertexNum; k++) //进行 n 次选代\\
for (i = 0; i < vertexNum; i ++)\\
for (j = 0; j < vertexNum; j++)\\[0pt]
if (dist[i][k] + dist[k][j] < dist[i][j]) (\\[0pt]
dist[i][j] = dist[i][k] + dist[k][j];\\[0pt]
path[i][j] = path[i][k] + path[k][j];\\
\}\\
\}

\begin{verbatim}

\section*{6.6 有向无环图及其应用}

有向图是描述工程进行过程的有效工具。通常把教学计划、施工过程、生产流程、软件工程等都当成一个工程。除最简单的情况之外，几乎所有的工程都可以分为若干个称

作活动（activity）的子工程。某个活动都会持续一定的时间，某些活动之间通常存在一定的约束条件，例如，某些活动必须在另一些活动完成之后才能开始。本节讨论有向图的拓扑排序和关键路径。

\section*{6．6．1 AOV 网 与拓扑排序}

在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，称这样的有向图为顶点表示活动的网，简称 AOV 网（activity on vertex network）。

AOV 网中的弧表示活动之间存在的某种制约关系。在 AOV 网中
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-214.jpg?height=310&width=251&top_left_y=421&top_left_x=1313)不能出现回路，否则意味着某活动的开始要以自己的完成作为先决条件，显然，这是荒谬的。因此判断 AOV 网所代表的工程能否顺利进行，即是判断它是否存在回路。而测试 AOV 网是否存在回路的方法，就是对 AOV 网进行拓扑排序。

设 $G=(V, E)$ 是一个有向图，$V$ 中的顶点序列 $v_{0}, v_{1}, \cdots, v_{n-1}$ 称为一个拓扑序列 （topological order），当且仅当满足下列条件：若从顶点 $v_{i}$ 到 $v_{j}$ 有一条路径，则在顶点序列中顶点 $v_{i}$ 必在 $v_{j}$ 之前 ${ }^{(1)}$ 。对一个有向图构造拓扑序列的过程称为拓扑排序（topological sort）。图 6－26 给出了一个 AOV 网的拓扑序列。显然，工程中的各个活动必须按照拓扑序列中的顺序进行才是可行的，并且一个 AOV 网的拓扑序列可能不唯一。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-214.jpg?height=381&width=1115&top_left_y=1176&top_left_x=269)

图 6－26 AOV 网及其拓扑序列
根据拓扑序列的定义，对 AOV 网进行拓扑排序的基本思想是：
（1）从 AOV 网中选择一个没有前驱的顶点并输出；
（2）从 AOV 网中删去该顶点以及所有以该顶点为尾的弧；
（3）重复上述两步，直到全部顶点都被输出，或 AOV 网中不存在没有前驱的顶点。
显然，拓扑排序的结果有两种：AOV 网中全部顶点都被输出，这说明 AOV 网不存在回路；AOV 网中顶点未被全部输出，剩余的顶点均不存在没有前驱的顶点，这说明 AOV 网存在回路。

下面讨论拓扑排序算法基于的存储结构。
（1）图的存储结构：因为在拓扑排序的过程中，需要查找所有以某顶点为尾的弧，即需要找到该顶点的所有出边，所以，图应该采用邻接表存储。另外，在拓扑排序过程中，需要对某顶点的人度进行操作，例如，查找入度等于零的顶点，将某顶点的人度减 1 等，而在

\footnotetext{
（1）用集合的术语讲，拓扑序列即是图中的顶点序列满足偏序关系。若集合 $X$ 上的关系 $R$ 是自反的、反对称的和传递的，则称 $R$ 是集合 $X$ 上的偏序关系。
}

图的邻接表中对顶点人度的操作不方便，所以，在顶点表中增加一个人度域，以方便对人度的操作。图 6－27 给出了一个 AOV 网及其邻接表存储示意图。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-215.jpg?height=485&width=1176&top_left_y=334&top_left_x=325)

图 6－27 AOV 网及其邻接表存储示意图
（2）查找没有前驱的顶点：为了避免每次查找时都去遍历顶点表，设置一个栈，凡是 AOV 网中人度为 0 的顶点都将其压栈。

拓扑排序算法用伪代码描述如下，图 6－28 给出了对图 6－27 所示 AOV 网进行拓扑排序的过程示例。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-215.jpg?height=315&width=379&top_left_y=1153&top_left_x=226)
（a）将入度为 0 的顶点入栈
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-215.jpg?height=304&width=194&top_left_y=1633&top_left_x=232)
（d）弹出并输出顶点 $v_{1}$顶点 $v_{3}$ 人度为 0 人栈
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-215.jpg?height=309&width=376&top_left_y=1156&top_left_x=730)
（b）弹出并输出顶点 $v_{4}$顶点 $v_{2}$ 人度为 0 入栈
（v）
（v）
\begin{tabular}{|l|}
\hline \\
\hline \\
\hline \\
\hline$v_{5}$ \\
\hline$v_{0}$ \\
\hline
\end{tabular}
（e）弹出并输出顶点 $v_{3}$顶点 $v_{0}$ 和 $v_{5}$ 入度为 0 入栈
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-215.jpg?height=305&width=371&top_left_y=1158&top_left_x=1227)
（c）弹出并输出顶点 $v_{2}$
（v）
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-215.jpg?height=261&width=111&top_left_y=1652&top_left_x=1490)
（f）弹出并输出顶点 $v_{5}$ 和 $v_{0}$ ，栈空算法结束

图 6－28 拓扑排序过程示例

算法：TopSort
输人：有向图 $G=(V, E)$
输出：拓扑序列
1．栈 S 初始化；累加器 count 初始化；

2．扫描顶点表，将人度为 0 的顶点压栈；
3．当栈 $S$ 非空时循环
$3.1 \mathrm{j}=$ 栈顶元素出栈；输出顶点 j ；count ++ ；
3.2 对顶点 $j$ 的每一个邻接点 $k$ 执行下述操作：
3.2 .1 将顶点 $k$ 的人度减 1 ；
3.2 .2 如果顶点 $k$ 的人度为 0 ，则将顶点 $k$ 人栈；

4．if（count＜vertexNum）输出有回路信息；
拓扑排序算法需要修改图的邻接表存储，或者设计类 AovGraph 继承邻接表类 ALGraph，然后函数 TopSort 作为成员函数，下面给出拓扑排序算法的成员函数定义。
\end{verbatim}

void TopSort()\\
1\\
int $i, j, k$, count $=0 ; \quad$ //累加器count初始化\\[0pt]
int S [MaxSize], top = -1; //采用顺序栈并初始化\\
EdgeNode * p = nullptr;\\
for ( $i=0 ; i<$ vertexNum $i++$ ) //扫描顶点表\\[0pt]
if (adjlist [i]. in $==0$ ) $3[++[0 p]=1 ; 1 / 1$ 将人度为 0 的顶点压栈\\
while (top $!=-1$ ) //当栈中还有人度为 0 的顶点时\\
1\\
$j=S$ [top--1; //以栈中取出人度为 0 的顶点\\[0pt]
cout <<adjlist[j].vertex:\\
count++ ;\\
$\mathrm{p}=\operatorname{adjlist}[j]$.firstEdge; //工作指针 p 初始化\\
while ( $p!=$ null $p t r$ ) //描顶点表, 找出顶点 $j$ 的所有出边\\
l\\
$k=p->a d f v e x ;$\\[0pt]
adjlist[k].in--;\\[0pt]
if (adjlist [k]. in $==0$ ) S [ ++ top] $=k$ 将人度为 0 的顶点人栈\\
$\mathrm{p}=\mathrm{p}$->next;\\
1\\
\}\\
if (count < vertexNum) cout <<"有回路";\\
1

\begin{verbatim}

分析拓扑排序算法，对一个具有 $n$ 个顶点、 $e$ 条弧的 AOV 网，扫描顶点表，将人度为 0 的顶点人栈的时间复杂度为 $O(n)$ ；在拓扑排序的过程中，若有向图无回路，则每个顶点进一次栈，出一次栈，人度减 1 的操作在 while 语句中共执行 $e$ 次，所以，整个算法的时间复杂度为 $O(n+e)$ 。

\section*{6．6．2 AOE 网与类键路径}

在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间，称这样的有向图为边表示活动的
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-216.jpg?height=307&width=248&top_left_y=2106&top_left_x=1294)

网，简称 AOE 网（activity on edge network），没有人边的顶点称为源点（source），没有出边的顶点称为终点（destination）。AOE网具有以下两个性质：
（1）只有在进人某顶点的各活动都已经结束，该顶点所代表的事件才能发生；
（2）只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始。
图 6－29 给出了一个具有 5 个活动、 4 个事件的 AOE 网，顶点 $v_{0}, v_{1}, v_{2}, v_{3}$ 分别表示一个事件；弧 $\left\langle v_{0}, v_{1}\right\rangle,\left\langle v_{0}, v_{2}\right\rangle,\left\langle v_{1}, v_{2}\right\rangle,\left\langle v_{1}, v_{3}\right\rangle,\left\langle v_{2}, v_{3}\right\rangle$ 分别表示一个活动，用 $a_{0}, a_{1}, a_{2}, a_{3}, a_{4}$ 代表这些活动。其中，$v_{0}$ 为源点，是整个工程的开始点，其人度为 $0 ; v_{3}$ 为终点，是整个工程的结束点，其出度为 0 。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-217.jpg?height=274&width=391&top_left_y=679&top_left_x=309)
\begin{tabular}{|c|l|}
\hline 事件 & \multicolumn{1}{|c|}{ 事件含义 } \\
\hline$v_{0}$ & 源点，整个工程开始 \\
$v_{1}$ & 活动 $a_{0}$ 完成，活动 $a_{2}$ 和 $a_{4}$ 可以开始 \\
$v_{2}$ & 活动 $a_{1}$ 和 $a_{2}$ 完成，活动 $a_{3}$ 可以开始 \\
$v_{3}$ & 活动 $a_{3}$ 和 $a_{4}$ 完成，整个工程结束 \\
\hline
\end{tabular}

图 6－29 一个 AOE 网

在 AOE 网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间（即最短工期）应该为源点到终点的最大路径长度。具有最大路径长度的路径称为关键路径（critical path），关键路径上的活动称为关键活动（critical activity）。显然，要缩短整个工期，必须加快关键活动的进度。为了找出关键活动及关键路径，需要定义如下数组。
（1）事件的最早发生时间 $\mathrm{ve}[\mathrm{k}]$
根据 AOE 网的性质，只有进人 $v_{k}$ 的所有活动 $<v_{j}, v_{k}>$ 都结束，$v_{k}$ 代表的事件才能发生，而活动 $<v_{j}, v_{k}>$ 的最早结束时间为 $\mathrm{ve}[\mathrm{j}]+\operatorname{len}<v_{j}, v_{k}>$ 。所以计算 $v_{k}$ 的最早发生时间的方法如下：

$$
\left\{\begin{array}{l}
\mathrm{ve}[0]=0  \tag{6-9}\\
\mathrm{ve}[\mathrm{k}]=\max \left\{\mathrm{ve}[\mathrm{j}]+\operatorname{len}\left\langle v_{j}, v_{k}\right\rangle\right\}\left(\left\langle v_{j}, v_{k}\right\rangle \in \mathrm{p}[\mathrm{k}]\right)
\end{array}\right.
$$


其中， $\mathrm{p}[\mathrm{k}]$ 表示所有到达 $v_{k}$ 的有向边的集合；$l \mathrm{en}<v_{j}, v_{k}>$ 为有向边 $<v_{j}, v_{k}>$ 上的权值。
（2）事件的最迟发生时间 $\mathrm{vl}[\mathrm{k}]$
$\mathrm{vl}[\mathrm{k}]$ 是指在不推迟整个工期的前提下，事件 $v_{k}$ 允许的最迟发生时间。根据 AOE 网的性质，只有顶点 $v_{k}$ 代表的事件发生，从 $v_{k}$ 出发的活动 $<v_{k}, v_{j}>$ 才能开始，而活动 $<v_{k}$ ， $v_{j}>$ 的最晚开始时间为 $\mathrm{vl}[j]-\operatorname{len}\left\langle v_{k}, v_{j}\right\rangle$ 。所以计算 $v_{k}$ 的最迟发生时间的方法如下：

$$
\left\{\begin{array}{l}
\mathrm{vl}[\mathrm{n}-1]=\mathrm{ve}[\mathrm{n}-1]  \tag{6-10}\\
\mathrm{vl}[\mathrm{k}]=\min \left\{\mathrm{vl}[\mathrm{j}]-\operatorname{len}<v_{k}, v_{j}>\right\}\left(<v_{k}, v_{j}>\in \mathrm{s}[\mathrm{k}]\right)
\end{array}\right.
$$


其中， $\mathrm{s}[\mathrm{k}]$ 为所有从 $v_{k}$ 发出的有向边的集合；len $<v_{k}, v_{j}>$ 为有向边 $<v_{k}, v_{j}>$ 上的权值。
（3）活动 $a_{i}$ 的最早开始时间 ee［i］
若活动 $a_{i}$ 由有向边 $<v_{k}, v_{j}>$ 表示，根据 AOE 网的性质，只有事件 $v_{k}$ 发生了，活动 $a_{i}$才能开始。也就是说，活动 $a_{i}$ 的最早开始时间等于事件 $v_{k}$ 的最早发生时间。因此，有：

$$
\begin{equation*}
\mathrm{ee}[\mathrm{i}]=\mathrm{ve}[\mathrm{k}] \tag{6-11}
\end{equation*}
$$

（4）活动 $a_{i}$ 的最晚开始时间 el［i］
$\mathrm{el}[i]$ 是指在不推迟整个工期的前提下，活动 $a_{i}$ 必须开始的最晚时间。若活动 $a_{i}$由有向边 $<v_{k}, v_{j}>$ 表示，则 $a_{i}$ 的最晚开始时间要保证事件 $v_{j}$ 的最迟发生时间不拖后。因此，有：

$$
\begin{equation*}
\mathrm{el}[\mathrm{i}]=\mathrm{vl}[\mathrm{j}]-\mathrm{len}\left\langle v_{k}, v_{j}\right\rangle \tag{6-12}
\end{equation*}
$$


最后，根据每个活动 $a_{i}$ 的最早开始时间 ee［ i ］和最晚开始时间 el［ i ］判定该活动是否为关键活动，那些 $e l[i]=e e[i]$ 的活动就是关键活动，那些 $e l[i]>e e[i]$ 的活动则不是关键活动，el［i］一 ee［i］的值为活动的时间余量。关键活动确定之后，关键活动所在的路径就是关键路径。

设 AOE 网具有 $n$ 个顶点 $e$ 条弧，求关键路径的算法用伪代码描述如下，对图6－29所示的 AOE 网求关键活动和关键路径的过程如图 6－30 所示。
\end{verbatim}

算法:关键路径算法\\
输人: 有向网图 G= (V,E)\\
输出:关键路径\\[0pt]
1. 令 ve [0] = 0,按拓扑序列求其余各顶点的最早发生时间 ve [i];\\
2. 如果得到的拓扑序列中顶点个数小于 AOE网中的顶点数,则说明网中存在回路,不能\\
求关键路径,算法终止;否则执行步骤 3;\\[0pt]
3. 令 v1 [n-1]=ve [n-1],按逆拓扑有序求其余各顶点的最迟发生时间 v1 [i];\\
4. 循环变量 i 从 0\~{}e-1 执行下述操作\\[0pt]
4.1 求每条边的最早开始时间 ee[i]和最迟开始时间 el[i];\\[0pt]
4.2 若某条边 a i 满足条件 ee [i] = el [i],则 a 为关键活动;

\begin{verbatim}
\begin{tabular}{|l|l|l|}
\hline 按照式（6－9）求事件的最早发生时间 ve［k］ & \multicolumn{2}{|l|}{按照式（6－10）求事件的最迟发生时间 vl［k］} \\
\hline ve［0］＝0 & $\mathrm{vl}[0]=\min \{\mathrm{vl}[1]-4, \mathrm{vl}[2]-3\}=0$ & 计 \\
\hline ve［1］＝ve［0］＋4＝4 & $\mathrm{vl}[1]=\min \{\mathrm{vl}[2]-2, \mathrm{vl}[3]-6\}=4$ & 算 \\
\hline $\mathrm{ve}[2]=\max \{\mathrm{ve}[0]+3, \mathrm{ve}[1]+2\}=6$ & $\mathrm{vl}[2]=\mathrm{vl}[3]-4=6$ & 次 \\
\hline $\mathrm{ve}[3]=-\max \{\mathrm{ve}[1]+6, \mathrm{ve}[2]+4\}=10$ & $\mathrm{vl}[3]=\mathrm{ve}[3]=10$ & 序 \\
\hline
\end{tabular}
（a）求事件的最早发生时间和最迟发生时间
\begin{tabular}{|l|l|l|}
\hline 按照式（6－11）求活动的最早发生时间 e［k］ & 按照式（6－12）求活动的最迟发生时间 1［k］ & el［i］－ee［i］ \\
\hline ee［0］＝ve［0］＝0 & $\operatorname{el}[0]=v 1[1]-4=0$ & 0 \\
\hline ee［1］＝ve［0］＝0 & el［1］＝vl［2］－3＝1 & 1 \\
\hline ee［2］＝ve［1］＝4 & el［2］＝vl［2］－2＝4 & 0 \\
\hline ee［3］＝ve［2］＝6 & el［3］＝vl［3］－4＝6 & 0 \\
\hline ee［4］＝ve［1］＝4 & el［4］－vl［3］－6＝4 & 0 \\
\hline
\end{tabular}
（b）求活动的最早发生时间和最迟发生时间
图 6－30 求关键路径示例
ee［i］和 el［i］相等的活动是关键活动，活动 $a_{0} 、 a_{2} 、 a_{3} 、 a_{4}$ 组成两条关键路径，如图 6－31所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-219.jpg?height=286&width=901&top_left_y=219&top_left_x=471)

图6－31 两条关键路径

\section*{6.7 扩展与提高}

\section*{6．7．1 图的其他存储方法}

\section*{1．十字链表}

在有向图中，为了便于确定顶点的人度，可以建立有向图的逆邻接表，对每个顶点 $v_{i}$将其所有逆邻接点链接起来，形成人边表。图 6－32 给出了一个有向图的邻接表和逆邻接表存储示意图。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-219.jpg?height=357&width=1513&top_left_y=1127&top_left_x=164)

图 6－32 有向图的邻接表和逆邻接表存储示意图
十字链表（orthogonal list）是有向图的一种存储方法，实际上是邻接表与逆邻接表的结合。在十字链表中，每条边对应的边表结点分别链接到出边表和人边表中，其顶点表和边表的结点结构如图 6－33 所示。
\begin{tabular}{|c|c|c|}
\hline vertex & firstin & firstout \\
\hline
\end{tabular}
（a）顶点表结点
（b）边表结点
\begin{tabular}{|l|l|l|l|}
\hline tailvex & headvex & headlink & taillink \\
\hline
\end{tabular}

图 6－33 十字链表顶点表，边表的结点结构
其中，vertex：数据域，存放顶点的数据信息。
firstin：人边表头指针，指向以该顶点为终点的弧构成的链表中的第一个结点。
firstout：出边表头指针，指向以该顶点为起点的弧构成的链表中的第一个结点。
tailvex：弧的起点（弧尾）在顶点表中的下标。
headvex：弧的终点（弧头）在顶点表中的下标。
headlink：人边表指针域，指向终点相同的下一条边。
taillink：出边表指针域，指向起点相同的下一条边。

图 6－34 给出了一个有向图及其十字链表的存储示意图。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-220.jpg?height=452&width=1497&top_left_y=289&top_left_x=42)

图 6－34 有向图及其十字链表存储示意图

\section*{2．邻接多重表}

用邻接表存储无向图，每条边的两个顶点分别在该边所依附的两个顶点的边表中，这种重复存储给图的某些操作带来不便。例如，对已访问过的边做标记，或者要删除图中某一条边等，都需要找到表示同一条边的两个边表结点。因此，进行这类操作的无向图应该采用邻接多重表作存储结构。

邻接多重表（adjacency multi－list）主要用于存储无向图，其存储结构和邻接表类似，每条边用一个边表结点表示，其顶点表和边表的结点结构如图 6－35 所示。
\begin{tabular}{|l|l|}
\hline vertex & first \\
\hline
\end{tabular}
（a）顶点表结点
\begin{tabular}{|c|c|c|c|}
\hline ivex & inext & jvex & jnext \\
\hline
\end{tabular}
（b）边表结点

图 6－35 邻接多重表的结点结构
其中，vertex：数据域，存储顶点的数据信息。
first：边表头指针，指向依附于该顶点的第一条边的边表结点。
ivex、jvex：某条边依附的两个顶点在顶点表中的下标。
inext：指针域，指向依附于顶点 ivex 的下一条边。
jnext：指针域，指向依附于顶点 jvex 的下一条边。
图 6－36 给出了一个无向图的邻接多重表存储示意图。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-220.jpg?height=465&width=1338&top_left_y=1879&top_left_x=124)

图 6－36 无向图的邻接多重表存储示意图

\section*{6．7．2 图的连通性}

\section*{1．无向图的连通分量和生成树}

对于连通图，从图中任一顶点出发，进行深度优先遍历或广度优先遍历，便可访问到图中所有顶点；对于非连通图，需要从多个顶点出发进行遍历，每次从一个新的起点出发进行遍历得到的顶点序列恰好是一个连通分量的顶点集。例如，对图 6－37（a）所示无向图进行深度优先遍历，需分别从顶点 $v_{0}$ 和 $v_{4}$ 出发调用两次 DFTravers（或 BFTravers），得到顶点序列分别为 $v_{0} v_{1} v_{2} v_{3}$ 和 $v_{4} v_{5} v_{6}$ ，这两个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图的两个连通分量，如图 6－37（b）所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-221.jpg?height=340&width=1414&top_left_y=763&top_left_x=252)

图 6－37 非连通图的连通分量及生成森林
因此，要想判定一个无向图是否为连通图，或有几个连通分量，可以设置一个计数器 count，初始时取值为 0 ，每调用一次遍历算法，就将 count 增 1。当整个图遍历结束时，依据 count 的值，就可确定无向图的连通性了。

设 $E(G)$ 是连通图 $G$ 中所有边的集合，$T(G)$ 是从图中任一顶点出发遍历图经过的边的集合，显然，$T(G)$ 和图中所有顶点一起构成连通图 $G$ 的一棵生成树，并且称由深度优先遍历得到的为深度优先生成树，称由广度优先遍历得到的为广度优先生成树。例如，对于图 6－38（a）所示连通图，图 6－38（b）和（c）分别为连通图的深度优先生成树和广度优先生成树。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-221.jpg?height=341&width=1134&top_left_y=1594&top_left_x=392)

图 6－38 连通图的生成树
对于非连通图，每个连通分量的顶点集，和遍历时经过的边一起构成若干棵生成树，这些连通分量的生成树组成非连通图的生成森林。例如，对于图 6－37（a）所示非连通图，图 6－37（c）为非连通图的深度优先生成森林。

\section*{2．有向图的强连通分量}

如果有向图是强连通的，从任一顶点出发必然能够遍历图的所有顶点。如果有向图

非强连通，可以用深度优先遍历来求有向图的强连通分量，具体求解步骤如下。
（1）在有向图中，从某个顶点出发进行深度优先遍历，并按其所有邻接点的都访问完 （即出栈）的顺序将顶点排列起来构成序列 S。
（2）在序列 $S$ 中，从最后访问的顶点出发，沿着以该顶点为头的弧做逆向的深度优先遍历，若此次遍历不能访问到有向图中所有顶点，则从余下的顶点中最后访问的顶点出发，继续做逆向的深度优先遍历，依次类推，直至有向图中所有顶点都被访问到。
（3）每一次逆向深度优先遍历访问到的顶点集便是该图的一个强连通分量的顶点集。
对图 6－39（a）所示有向图，从顶点 $v_{0}$ 出发做深度优先遍历，得到遍历序列 $v_{0} v_{1} v_{2} v_{4} v_{3}$ ，出栈的顶点序列为 $v_{4} v_{2} v_{1} v_{3} v_{0}$ ，进行两次逆向的深度优先遍历，一次是从顶点 $v_{0}$ 出发得到顶点集 $\left\{v_{0}, v_{2}, v_{3}, v_{1}\right\}$ ，一次是从 $v_{4}$ 出发得到顶点集 $\left\{v_{4}\right\}$ ，这就是该有向图的两个强连通分量的顶点集。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-222.jpg?height=347&width=1209&top_left_y=872&top_left_x=173)

图 6－39 非强连通图的强连通分量
对于有向图，即使进行一次遍历能够访问图中的所有顶点，所有顶点和遍历所经过的边也不能构成生成树，如图6－39（c）所示。生成树是无回路的连通图，而有向图若连通则必存在回路。因此，一般不讨论有向图的生成树问题。

\section*{6.8 应 用 实 例}

\section*{6．8．1 七巧板涂色问题}

本章的引言部分给出了七巧板涂色问题，下面考虑算法设计与程序实现。
【算法】为了识别不同区域的相邻关系，可以将七巧板的每个区域看成一个顶点，如果两个区域相邻，则这两个顶点之间有边相连，则将七巧板抽象为图模型，用邻接矩阵存储这个图，如图 6－40所示。

依次对每个顶点涂色，如果当前顶点 $v_{i}$ 涂色后不发生冲突，则对下一个顶点进行涂色，如果对顶
$\operatorname{arc}[7][7]=\left(\begin{array}{lllllll}0 & 1 & 0 & 0 & 1 & 1 & 0 \\ 1 & 0 & 1 & 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 1 & 0 & 0 & 0 \\ 0 & 1 & 1 & 0 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 & 0 & 1 & 1 \\ 1 & 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 & 1 & 0 & 0\end{array}\right)$

图 6－40 七巧板对应的邻接矩阵点 $v_{i}$ 涂所有颜色都与前面已涂色顶点发生冲突，则进行回溯，返回上一个顶点试探下一种颜色。已经证明：对任意平面图至少存在一种 4色涂色方案，所以问题一定有解。设数组 color［n］表示涂色情况，例如，color［i］$=1$ 表示顶点 i 涂第 1 种颜色，七巧板涂色问题的算法用伪代码描述如下：

算法：七巧板涂色 Color
输人：图的邻接矩阵存储
输出：涂色方案 color［n］
1．将数组 color［n］初始化为 0 （即未涂色）；
2．下标 $i$ 从 $0 \sim n-1$ 重复执行下述操作：
2.1 color［i］＋＋；
2.2 如果 color［ $i$ ］＞4，则取消对顶点 $i$ 的涂色；$i=i-1$ ，转步骤 2 回溯；
2.3 如果 color［i］和前 $i-1$ 个顶点的涂色发生冲突，则转步骤 2.1 ；
$2.4 i=i+1$ ，转步骤 2 为下一个顶点涂色；

【程序】将函数 Color 定义为类 Puzzle 的成员函数，类 Puzzle 的成员变量 board［MaxSize］表示七巧板的区域信息，mat［MaxSize］［MaxSize］表示区域之间的邻接关系，color［MaxSize］表示涂色情况，构造函数建立七巧板问题的图模型，程序如下：
\end{verbatim}

\#include <iostream>\\
using namespace std;\\
const int MaxSize = 7;\\
class Puzzle\\
f\\
public:

\begin{verbatim}

\end{verbatim}

\begin{verbatim}
Puzzle(char b[MaxSize], int m[MaxSize][MaxSize], int n);
-Puzzle();
void Color(): // 进行途色
void Print(); //输出涂色情况
\end{verbatim}

private:\\[0pt]
char board[MaxSize]; // 存储区域信息\\[0pt]
int mat [MaxSize] [MaxSize]; // 存储邻接关系\\[0pt]
int color[MaxSize]; //存储涂色情况\\
int vertexNum: //顶点个数\\
\};\\[0pt]
Puzzle :: Puzzle(char b[MaxSize], int m[MaxSize][MaxSize], int n)\\
f\\
for (int i = 0; i< n; i++) // 初始化区域及涂色\\
i\\[0pt]
board[i] = b[i];\\[0pt]
color[i] = 0;\\
)\\
for(int i=0; i<n; i++) // 初始化邻接关系\\
for (int j = 0; j< n; j++)\\[0pt]
mat[i][j] = m[i][j];\\
vertexNum = n;\\
\}\\
Puzzle :: \~{}Puzzle()

\begin{verbatim}

\end{verbatim}

\{\\
\}\\
void Puzzle :: Color()\\
\{\\
int i, j;\\
for (i = 0; i<vertexNum;) //为顶点i涂色,循环变量i要视情况而改变\\
\{\\[0pt]
color[i]++; //为顶点i涂下一种缡色\\[0pt]
if (color[i] > 4) \{ //如果顶点 i 已经试探过所有颜色\\[0pt]
color[i] = 0; //取消顶点 i 的涂色\\
i=i-1;\\
continue; //回溯到前一个顶点\\
\}\\
for (j= 0; j<i; j++)\\
l\\[0pt]
if ((mat[i][j]\hl{1) \&\& (color[i]} color[j])) break; //涂色冲突\\
\}\\
if (j== i) i = i + 1; //顶点 i 的涂色不冲突,为下一个顶点涂色\\
\}\\
\}\\
void Puzzle :: Print()\\
for (int i = 0; i < vertexNum; i++) //输出所有区域的馀色情况\\[0pt]
cout<<board[i]<<"涂颜色:"<<color[i]<<endl;\\
\}\\
int main()\\
\{\\[0pt]
char board [MaxSize] = \{'A','B','C','D','E','F','G'); //定义七巧板\\[0pt]
int edge[MaxSize] [MaxSize] = (\{0,1,0,0,1,1,0\}, \{1,0,1,1,0,0,0\},\{0,1,0,1,0,0,0\},\\
\{0,1,1,0,1,0,1),\{1,0,0,1,0,1,1\},\{1,0,0,0,1,0,0\},\{0,0,0,1,1,0,\\
0\});\\
Puzzle P\{board,edge,7\};\\
P.Color(); //涂色\\
P.Print(); //输出涂色方案\\
return 0;\\
\}

\begin{verbatim}

\section*{6．8．2 医院选址问题}

【问题】某乡有 5 个村庄，村庄之间的道路情况如图 6－41 所示，现要在其中一个村庄建立医院，要求该医院距其他各村庄的最长往返路程最短，即各村庄总的往返路程越短越好，问医院应选址在何处？

【想法】该问题即是确定图的中心点，该中心点与其他各顶点之间的往返路径长度之和为最小。可以为该有向图建立邻接矩阵，如图 6－42 所示。用 Floyd 算法求出任意两

顶点的最短路径长度，结果如图 6－43 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-225.jpg?height=279&width=546&top_left_y=294&top_left_x=163)

图 6－41 医院选址问题

$$
\left[\begin{array}{ccccc}
0 & 13 & \infty & 4 & \infty \\
13 & 0 & 15 & \infty & 5 \\
\infty & \infty & 0 & 12 & \infty \\
4 & \infty & 12 & 0 & \infty \\
\infty & \infty & 6 & 3 & 0
\end{array}\right]
$$


图 6－42 有向网的邻接矩阵

$$
\left(\begin{array}{ccccc}
0 & 13 & 16 & 4 & 18 \\
12 & 0 & 11 & 8 & 5 \\
16 & 29 & 0 & 12 & 34 \\
4 & 17 & 12 & 0 & 22 \\
7 & 20 & 6 & 3 & 0
\end{array}\right)
$$


图 6－43 任意两顶点之间最短路径长度

题目要求医院距其他各结点的最长往返路程最短，可以依次计算每个顶点与其他各顶点的往返代价之和，则往返代价之和最小的顶点即是图的中心点。

【算法】Floyd 算法请参见6．5．2节。求各顶点与其他各顶点的往返代价之和的算法较简单，请读者自行设计。

【程序】假设图中的权值均小于 100 ，设符号常量 MaxValue，其值为 100 表示 $\infty$ 。类 Hospital 的成员变量 vertex［N］存储顶点信息，成员变量 edge［N］［N］存储有向网图对应的邻接矩阵，构造函数初始化医院选址问题的图模型，成员函数 Center 选取图的中心点。程序如下：
\end{verbatim}

\section*{include <iostream>}
using namespace std;\\
const int MaxValue = 100;\\
//定义 const 常量 100\\
const int N = 5;\\
//假设图中有 5 个顶点\\
class Hospital\\
\{\\
public:\\[0pt]
Hospital (char v[N], int e[N][N], int n); //构造函数\\
\~{}Hospital(); // 析构函数\\[0pt]
void Eloyd(int dist[N][N]); //求任意两个顶点之间的最短路径\\
int Center();\\
private:\\[0pt]
char vertex [N] ;\\[0pt]
int ecge[N] [N] ;\\
int vertexNum;\\
\};\\[0pt]
Hospital :: Hospital (char v[N], int e[N][N], int n)\\
l\\
for (int i = 0; i <n; i++) // 初始化顶点信息\\[0pt]
vertex[i] = v[i];\\
for(int i = 0; i < n; i++) // 初始化邻接矩阵\\
for (int j = 0; j<n; j++)\\[0pt]
edge[i][j] = e[i][j];\\
vertexNum = n;

\begin{verbatim}

\end{verbatim}

)\\
Hospital :: \~{}Hospital()\\
\{\\
\}\\[0pt]
void Hospital :: Eloyd (int dist [N] [N])\\
\{\\
int i, j, k;\\
for (i = 0; i < vertexNum; i++) // 初始化结果矩阵 dist\\
for (j= 0; j < vertexNum; j++)\\[0pt]
dist[i][j] = edge[i][j];\\
for (k = 0; k < vertexNum; k++) //进行N 次迭代\\
for (i = 0; i < vertexNum; i + +) //顶点 i 和 j 之间是否经过顶点 k\\
for ( j = 0; j < vertexNum; j++)\\[0pt]
if (dist[il[k] + dist[k][j]<dist[i][j])\\[0pt]
dist[i][j] = dist[i][k] + dist[k][j];\\
)\\
int Hospital :: Center()\\
I\\
int wayCost, minCost = MaxValue;\\[0pt]
int i, k, index, dist[N][N]; //矩哖 dist存储顶点之间的最知路经长度\\
Floyd(dist);\\
for (k = 0; k < vertexNum; k++) //依次求每个顶点的往返代价\\
\{\\
wayCost = 0; // 往返代价初始化为 0\\
for (i = 0; i < vertexNum; i++) //顶点 i到其他顶点的路径长度之和\\[0pt]
wayCost = wayCost + dist[i][k];\\
for (i = 0; i < vertexNum; i++) //其他顶点到顶点 i 的路径长度之和\\[0pt]
wayCost = wayCost + dist[k][i];\\
if (wayCost < minCost) \{\\
minCost = wayCost;\\
index = k; //顶点 k 为当前的中心点\\
\}\\
\}\\
return index; //返回中心点的下标\\
\}\\
int main()\\
\{\\[0pt]
char vertex[N] = \{'A','B','C','D','E'\};\\[0pt]
int edge[N][N] = \{\{0,13,MaxValue,4,MaxValue\},\\
\{13, 0, 15, MaxValue, 5\},\\
\{MaxValue,MaxValue,0,12,MaxValue\},\\
\{4,MaxValue, 12, 0, MaxValue\},\\
\{MaxValue,MaxValue, 6, 3, 0\});

\begin{verbatim}

\end{verbatim}

int minPoint;\\
Hospital H\{vertex, edge, 5\};\\
//定义对象其\\
minPoint = H.Center();\\
//调用函数 Center 求中心点\\[0pt]
cout <<"应该设在点:" <<vertex[minPoint] <<endl;\\
return 0;\\
f

\begin{verbatim}

\section*{思想火花——直觉可能是错误的}

对一个复杂的问题先试着猜测一个解，这是人的天性。一些猜测看起来很直观，但有时候你必须努力摆脱直觉，即使是一些看起来简单明了的事情也需要作一番认真的考察。下面就是一个违背直觉的例子。

在古希腊时代，宙斯叫来一个铁匠铸造一个环绕地球的铁环，要求铁环的直径正好与地球的直径相匹配。但可怜的铁厈出了点差错，他造出的铁环比原定的周长长出 1 米。宙斯让铁环环绕着地球，让它和地球的一个点相接触，如图 6－44 所示。现在的问题是：铁环在地球另一端的狭缝突出多少？什么样的动物可以挤在地球和铁环之间？一只蚂蚁，一只老鼠还是一只猫？

与直觉相反的答案是狭缝几乎达 32 厘米！即使一个小孩也能够蜷缩在铁环下。这是因为地球和铁环之间的周长之差是 100 厘米，即 $2 \pi r_{1}-2 \pi r_{2}=100$ ，所以它们之间的直径之差 $\left(2 r_{1}-2 r_{2}\right)$ 为 $100 / \pi \approx 31.83$ 厘米。

卡西尼悖论是另一个违背直觉的例子。有一个 $8 \times 8$ 的棋盘，按照图 6－45（a）所示，将棋盘切成两个梯形和两个三角形，然后再按照图 6－45（b）把他们拼接起来，图（a）的面积是 $8 \times 8=64$ ，而图（b）的面积是 $13 \times 5=65$ ！造成这个错觉的原因是图（b）的对角线不是直线，狭长的缝隙累积起来正好是一个小正方形的面积。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-227.jpg?height=300&width=335&top_left_y=1650&top_left_x=230)

图 6－44 地球与铁环
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-227.jpg?height=310&width=320&top_left_y=1594&top_left_x=620)
（a） $8 \times 8=64$

\section*{习 题 6}

\section*{1．选择题}
（1）在一个具有 $n$ 个顶点的有向完全图中包含有（ ）条边。
A．$n(n-1) / 2$
B．$n(n-1)$
C．$n(n+1) / 2$
D．$n^{2}$
（2）$n$ 个顶点的强连通图至少有（）条边，其形状是（ ）。
A．$n$
B．$n+1$
C．$n-1$
D．$n \times(n-1)$
E．无回路
F．有回路
G．环状
H．树状
（3）含 $n$ 个顶点的连通图中的任意一条简单路径，其长度不可能超过（）。
A． 1
B．$n / 2$
C．$n-1$
D．$n$
（4）无向图 G 有 16 条边，度为 4 的顶点有 3 个，度为 3 的顶点有 4 个，其余顶点的度均小于 3 ，则图 G 至少有（ ）个顶点。
A． 10
B． 11
C． 12
D． 13
（5）对于一个具有 $n$ 个顶点的无向图，若采用邻接矩阵存储，则该矩阵的大小是（）。
A．$n$
B．$(n-1)^{2}$
C．$n-1$
D．$n^{2}$
（6）图的生成树（ ），n个顶点的生成树有（ ）条边。
A．唯一
B．不唯一
C．唯一性不能确定
D．$n$
E．$n+1$
F．$n-1$
（7）对于无向图 $G=(V, E)$ 和 $G^{\prime}=\left(V^{\prime}, E^{\prime}\right)$ ，如果 $G^{\prime}$ 是 $G$ 的生成树，则下面说法中错误的是（ ）。
A．$G^{\prime}$ 为 $G$ 的子图
B．$G^{\prime}$ 为 $G$ 的连通分量
C．$G^{\prime}$ 为 $G$ 的极小连通子图且 $V=V^{\prime}$
D．$G^{\prime}$ 是 $G$ 的一个无环子图
（8）$G$ 是一个非连通无向图，共有 28 条边，则该图至少有（ ）个顶点。
A． 6
B． 7
C． 8
D． 9
（9）假设一个有向图具有 $n$ 个顶点 $e$ 条边，该有向图采用邻接矩阵存储，则删除与顶点 $i$ 相关联的所有边的时间复杂度是（）。
A．$O(n)$
B．$O(e)$
C．$O(n+e)$
D．$O(n * e)$
（10）用深度优先遍历方法遍历一个有向无环图，并在深度优先遍历算法中按退栈次序打印出相应的顶点，则输出的顶序列是（）。
A．逆拓扑有序
B．拓扑有序
C．无序
D．顶点编号次序
（11）对如图 6－46 所示的有向图从顶点 a 出发进行深度优先遍历，不可能得到的遍历序列是（）。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-228.jpg?height=327&width=526&top_left_y=1805&top_left_x=563)

图 6－46 一个有向图
A．adbefc
B．adcefb
C．adcbfe
D．adefbc
（12）最小生成树指的是（ ）。
A．由连通网所得到的边数最少的生成树

B．由连通网所得到的顶点数相对较少的生成树
C．连通网中所有生成树中权值之和为最小的生成树
D．连通网的极小连通子图
（13）对如图 6－47 所示的无向连通网图从顶点 d 开始用 Prim 算法构造最小生成树，在构造过程中加人最小生成树的前 4 条边依次是（）。

A．$(\mathrm{d}, \mathrm{f}) 4,(\mathrm{f}, \mathrm{e}) 2,(\mathrm{f}, \mathrm{b}) 3,(\mathrm{~b}, \mathrm{a}) 5$
B．$(f, e) 2,(f, b) 3,(a, c) 3,(f, d) 4$
C．$(\mathrm{d}, \mathrm{f}) 4,(\mathrm{f}, \mathrm{e}) 2,(\mathrm{a}, \mathrm{c}) 3,(\mathrm{~b}, \mathrm{a}) 5$
D．$(\mathrm{d}, \mathrm{f}) 4,(\mathrm{~d}, \mathrm{~b}) 5,(\mathrm{f}, \mathrm{e}) 2,(\mathrm{~b}, \mathrm{a}) 5$
（14）设有如图 6－48 所示的 AOE 网，则事件 $v_{4}$ 的最早开始时间是（ ），最迟开始时间是（ ），该 AOE 网的关键路径有（ ）条。
A． 11
B． 12
C． 13
D． 14
E． 1
F． 2
G． 3
H． 4
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-229.jpg?height=289&width=504&top_left_y=1018&top_left_x=304)

图 6－47 一个无向连通网
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-229.jpg?height=299&width=626&top_left_y=1008&top_left_x=939)

图 6－48 一个 AOE 网
（15）下面关于工程计划的 AOE 网的叙述中，不正确的是（）。
A．关键活动不按期完成就会影响整个工程的完成时间
B．任何一个关键活动提前完成，那么整个工程将会提前完成
C．所有的关键活动都提前完成，那么整个工程将会提前完成
D．某些关键活动若提前完成，那么整个工程将会提前完成

\section*{2．解答下列问题}
（1）$n$ 个顶点的无向图，采用邻接表存储，回答下列问题：
（1）图中有多少条边？
（2）任意两个顶点 $i$ 和 $j$ 是否有边相连？
（3）任意一个顶点的度是多少？
（2）$n$ 个顶点的无向图，采用邻接矩阵存储，回答下列问题：
（1）图中有多少条边？
（2）任意两个顶点 $i$ 和 $j$ 是否有边相连？
（3）任意一个顶点的度是多少？
（3）设无向网图 $G$ 含有 $n$ 个顶点 $e$ 条边，每个顶点的信息（假设只存储编号）占用 2个字节，每条边的权值信息占用 4 个字节，每个指针占用 4 个字节，计算采用邻接矩阵和邻接表分别占用多少存储空间？
（4）证明：生成树中最长路径的起点和终点的度均为 1 。
（5）已知一个连通图如图 6－49 所示，试给出图的邻接矩阵和邻接表存储示意图，若从顶点 $v_{1}$ 出发对该图进行遍历，分别给出一个按深度优先遍历和广度优先遍历的顶点序列。
（6）图 6－50 所示是一个无向网图，请分别按 Prim 算法和 Kruskal 算法求最小生成树。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-230.jpg?height=223&width=381&top_left_y=676&top_left_x=345)

图 6－49 一个连通图
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-230.jpg?height=302&width=361&top_left_y=599&top_left_x=931)

图 6－50 一个无向网图
（7）如图 6－51 所示的有向网图，利用 Dijkstra 算法求从顶点 $v_{1}$ 到其他各顶点的最短路径。
（8）证明：只要适当地排列顶点的次序，就能使有向无环图的邻接矩阵中主对角线以下的元素全部为 0 。
（9）对于如图 6－52 所示的有向网图，求出各活动的最早开始时间和最晚开始时间，并写出关键活动和关键路径。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-230.jpg?height=300&width=615&top_left_y=1367&top_left_x=187)

图6－51 有向网图
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-230.jpg?height=298&width=599&top_left_y=1373&top_left_x=858)

图 6－52 一个有向网图

\section*{3．算法设计}
（1）设计算法，将一个无向图的邻接矩阵转换为邻接表。
（2）设计算法，将一个无向图的邻接表转换成邻接矩阵。
（3）设有向图 $G$ 采用邻接表存储，设计算法求图 $G$ 中每个顶点的人度。
（4）设有向图 $G$ 采用邻接矩阵存储，计算图中出度为零的顶点个数。
（5）设计算法求无向图的深度优先生成树。
（6）以邻接表作存储结构，设计按深度优先遍历图的非递归算法。
（7）假设以邻接矩阵作为图的存储结构，编写算法判别给定的有向图中是否存在回路。
（8）分别基于深度优先搜索和广度优先搜索编写算法，判断以邻接表存储的有向图中是否存在由顶点 $v_{i}$ 到顶点 $v_{j}$ 的路径 $(i \neq j)$ 。

\section*{实 验 题 6}

【实验 1】请上机实现 6．3．1 节图的邻接矩阵存储和 6．3．2 节图的邻接表存储的使用范例，并增加求顶点的度、求某顶点的所有邻接点、增加一个顶点、删除一条边等成员函数。

【实验 2】请上机实现 6．6．1 节拓扑排序算法，并用不同的图实例进行测试。
【实验 3】哈密顿回路。爱尔兰数学家哈密顿（William Hamilton，1805－1865）提出了哈密顿回路问题：给定一个无向连通图，从某顶点出发，访问该图的所有顶点并且只访问一次，并回到出发顶点。设计求解哈密顿回路的算法。

\section*{75}

\section*{查找技术}
\begin{tabular}{|l|l|l|l|l|l|}
\hline 本章概述 & \multicolumn{5}{|c|}{在日常生活中，人们几乎每天都要进行查找工作，例如，在字典中查找某个字的读音和含义，在通讯录中查找某人的电话号码，等等。在数据处理领域，查找是使用最频繁的一种基本操作，例如编译器对源程序中变量名的管理、数据库系统的信息维护等都涉及查找操作。查找以集合为数据模型，以查找为核心操作，同时也可能包括插人和删除等其他操作。本章以静态査找和动态查找为主线，讨论基本的查找技术，包括线性表的查找技术、树表的查找技术以及散列表的查找技术，其中二叉排序树本质上是二叉树的应用，散列技术本质上是数组和单链表的应用。} \\
\hline 教学重点 & \multicolumn{5}{|c|}{折半查找算法及性能分析；二叉排序树的构造及查找；平衡二又树的调整；散列表的构造和查找；B 树的定义} \\
\hline 教学难点 & \multicolumn{5}{|l|}{二叉排序树的删除操作；平衡二叉树的调整；B 树的插人和删除操作} \\
\hline \multirow{18}{*}{数学内容和教学目标} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教学要求} \\
\hline & & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline & 查找的基本概念 & & $\checkmark$ & & \\
\hline & 查找算法的性能 & & $\checkmark$ & & \\
\hline & 顺序查找算法 & & & $\checkmark$ & \\
\hline & 折半查找 & & & & $\checkmark$ \\
\hline & 折半查找判定树 & & $\checkmark$ & & \\
\hline & 二叉排序树的插人 & & & & $\checkmark$ \\
\hline & 二叉排序树的删除 & & & $\checkmark$ & \\
\hline & 二叉排序树的查找及性能分析 & & & $\checkmark$ & \\
\hline & 平衡二叉树的调整 & & & $\checkmark$ & \\
\hline & B 树的定义 & & & $\checkmark$ & \\
\hline & B 树的查找 & & & $\checkmark$ & \\
\hline & B 树的插人和删除 & & $\checkmark$ & & \\
\hline & 常见的散列函数 & & $\checkmark$ & & \\
\hline & 散列表的构造和查找 & & & & $\checkmark$ \\
\hline & 散列查找的性能分析 & & $\checkmark$ & & \\
\hline & 各种查找技术的比较 & & & $\checkmark$ & \\
\hline
\end{tabular}

\section*{7.1 概 述}

\section*{7．1．1 查找的基本概念}

在查找问题中，通常将数据元素称为记录 ${ }^{(1)}$（record）。
（1）关键码
可以标识一个记录的某个数据项称为关键码（key），关键码的值称为键值（keyword）。若关键码可以唯一标识一个记录，则称此关键码为主关键码（primary key）；反之，称此关键码为次关键码（second key）。为了突出查找技术这个主题，本章假定记录只有一个整型关键码。
（2）查找
广义地讲，查找（search）是在具有相同类型的记录构成的集合中找出满足给定条件的记录。给定的查找条件可能是多种多样的，为了便于讨论，把查找条件限制为＂匹配＂，即查找关键码等于给定值的记录。若在查找集合中找到了与给定值相等的记录，则称查找成功；否则称查找不成功（或查找失败）。一般情况下，查找成功时，要返回一个成功标志，例如返回该记录的位置；查找不成功时，要返回一个不成功标志，或将被查找的记录插入到查找集合中。
（3）静态查找、动态查找
不涉及插人和删除操作的查找称为静态查找（static search），静态查找在查找不成功时，只返回一个不成功标志，查找的结果不改变查找集合；涉及插人和删除操作的查找称为动态查找（dynamic search），动态查找在查找不成功时，需要将被查找的记录插人到查找集合中，查找的结果可能会改变查找集合。

静态查找适用下述场合：查找集合一经生成，便只对其进行查找，而不进行插人和删除操作，或经过一段时间的查找之后，集中地进行插人和删除等修改操作。动态查找适用下述场合：查找与插人和删除操作在同一个阶段进行，例如，在某些问题中，当查找成功时，要删除查找到的记录，当查找不成功时，要插人被查找的记录。
（4）查找结构
一般而言，各种数据结构都会涉及查找操作，例如前面介绍的线性表、树与图等，这些数据结构中的查找操作并没有被作为主要操作考虑。在某些应用中，查找操作是最主要的操作，为了提高查找效率，需要专门为查找操作设计数据结构，这种面向查找操作的数据结构称为查找结构（search structure）。本章讨论的查找结构有：
（1）线性表：适用于静态查找，主要采用顺序查找技术、折半查找技术。
（2）树表：适用于动态查找，主要采用二叉排序树、平衡二叉树、B 树等查找技术。
（3）散列表：静态查找和动态查找均适用，主要采用散列查找技术。

\footnotetext{
（1）在计算机发展的早期，由于内存的限制，查找操作常常需要借助外存才能实现，因此数据元素沿用文件的叫法，称为记录。
}

\section*{7．1．2 查找算法的性能}

查找算法的基本操作通常是将记录和给定值进行比较，所以，通常以记录的平均比较次数来度量查找算法的平均时间性能，称为平均查找长度（average search length）。对于查找成功的情况，其计算公式为：
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-234.jpg?height=310&width=238&top_left_y=248&top_left_x=1304)

$$
\begin{equation*}
\mathrm{ASL}=\sum_{i=1}^{n} p_{i} c_{i} \tag{7-1}
\end{equation*}
$$


其中，$n$ 为问题规模，查找集合中的记录个数；$p_{i}$ 为查找第 $i$ 个记录的概率；$c_{i}$ 为查找第 $i$ 个记录所需的比较次数。显然，$c_{i}$ 与算法密切相关，决定于算法；$p_{i}$ 与算法无关，决定于具体应用，如果 $p_{i}$ 是已知的，则 ASL 只是问题规模 $n$ 的函数。

对于查找不成功的情况，平均查找长度即为查找失败时的比较次数。查找算法的平均查找长度应该综合考虑查找成功与查找失败两种情况下的查找长度。但在实际应用中，查找成功的可能性比查找不成功的可能性大得多，特别是在查找集合的记录个数较多时，查找不成功的概率可以忽略不计。

\section*{7.2 线性表的查找技术}

在线性表中进行查找通常属于静态查找，这种查找算法简单，主要适用于小型查找集合。线性表一般有两种存储结构：顺序存储结构和链接存储结构，此时，可以采用顺序查找技术。对顺序存储结构，若记录有序，可采用更高效的查找技术——折半查找技术。

\section*{7．2．1 线性表查找结构的类定义}

下面给出线性表查找结构的类定义以及构造函数，其中成员变量实现线性表的顺序存储。简单起见，不失一般性，假定待查找集合的记录为 int 型，成员函数实现线性表的查找技术。在接下来的章节中具体讨论线性表查找技术的实现。
\end{verbatim}

const int MaxSize = 100;\\
class LineSearch\\
\{\\
public:\\[0pt]
LineSearch (int a [ ], int n); //构造函数\\
\~{} LineSearch() () //析构函数为空\\
int SeqSearch (int k) ; //顺序查找\\
int BinSearch1(int k); //折半非递归查找\\
int BinSearch2(int low, int high, int k); //折半递归查找\\
private:\\[0pt]
int data[MaxSize]; //查找集合为整型\\
int length; //查找集合的元素个数\\
\};

\begin{verbatim}

\end{verbatim}

LineSearch :: LineSearch(int a [ ], int n)\\
l\\
for (int i = 0; i < n; 1++)\\[0pt]
data[i+1]=a[i]; //查找集合从下标1开始存放\\
length = n;\\
\}

\begin{verbatim}

\section*{7．2．2 顺序查找}

顺序查找（sequential search）又称线性查找，其基本思想为：从线性表的一端向另一端逐个将记录与给定值进行比较，若相等，则查找成功，给出该记录在表中的位置；若整个表检测完仍未找到与给定值相等的记录，则查找失败，给出失败信息。

在单链表中进行顺序查找的算法请参见 2，4．2节，在顺序表中进行顺序查找的算法在2．3．2节中已讨论过，这里介绍一种改进的算法：设置哨兵 ${ }^{(1)}$ 。哨兵就是待查值，存放在查找方向的尽头处，在查找过程中每次比较后，不用判断查找位置是否越界，从而提高查找速度，如图 7－1 所示。实践证明，这个改进在表长大于 1000 时，进行一次顺序查找的平均时间几乎减少一半。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-235.jpg?height=180&width=776&top_left_y=1213&top_left_x=555)

图 7－1 顺序查找示意图
将哨兵设在数组的低端，待查找元素值为 $k$ ，返回值有两种情况：（1）查找成功，$i$ 的值为待查记录在数组中的下标（即待查记录的序号）；（2）查找不成功，$i$ 的值为 0 ，相当于查找失败的标志。顺序查找的成员函数定义如下。
\end{verbatim}

int LineSearch::SeqSearch(int k)\\
I\\
int i = length; // 以数组高端开始比较\\[0pt]
data[0] = k; //设置哨兵\\[0pt]
while (data[i] != k) //不用判断下标 i 是否越界\\
i--;\\
return i;\\
)

\begin{verbatim}

查找成功时，设每个记录的查找概率相等，即 $p_{i}=1 / n(1 \leqslant i \leqslant n)$ ，查找第 $i$ 个记录需进行 $n-i+1$ 次比较，顺序查找的平均查找长度为：

\footnotetext{
（1）实际上，一切为简化边界条件而引入的附加结点（或记录）均可称为哨兵，例如单链表的头结点、中缀表达式求值用＇\＃＇作为表达式的定界符、迷宫增加的边界墙等。读者应该深刻理解并掌握这种技巧。
}

$$
\mathrm{ASL}=\frac{1}{n} \sum_{i=1}^{n}(n-i+1)=\frac{n+1}{2}=O(n)
$$


查找不成功时，记录的比较次数是 $n+1$ 次，则查找失败的平均查找长度为 $O(n)$ 。

\section*{7．2．3 折半查找}

\section*{1．折半查找的执行过程}

折半查找（binary search）${ }^{(1)}$ 的基本思想是：假设有序表按关键码升序排列，取中间记录作为比较对象，若给定值与中间记录相等，则查找成功；若给定值小于中间记录，则在有序表的左半区继续查找；若给定值大于中间记录，则在有序表的右半区继续查找。不断重复上述过程，直到查找成功，或查找区域无记录，查找失败，如图 7－2 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-236.jpg?height=220&width=919&top_left_y=897&top_left_x=349)

图 7－2 折半查找的基本思想
【例 7－1】 在有序表 $\{7,14,18,21,23,29,31,35,38\}$ 中查找 18 和 15 。设有序表存储在一维数组元素 $r[1] \sim r[n]$ 中，则记录的序号和存储下标一致，查找成功时返回序号，查找失败时返回标志 0 。查找 18 的过程如图 7－3 所示，查找 15 的过程如图 7－4 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-236.jpg?height=618&width=1077&top_left_y=1376&top_left_x=272)

图 7－3 折半查找成功情况下的查找过程

\section*{2．折半查找的非递归算法}

设待查值为 $k$ ，折半查找非递归算法的成员函数定义如下：

\footnotetext{
（1）第一个折半查找算法早在1946年就有了，但是第一个正确的、无 bug 的折半查找程序却直到1962年才出现！调整查找区间时，若 mid $=$ high，则有一个记录会找不到；对称地，若 mid $=$ low，也有一个记录会找不到。
}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-237.jpg?height=669&width=1070&top_left_y=214&top_left_x=393)

图 7－4 折半查找不成功情况下的查找过程
\end{verbatim}

int LineSearch::BinSearchl(int k)\\
\{\\[0pt]
int mid, low = 1, high = length; // 初始查找区间是 [1, n]\\
while (low <= high) //当区间存在时\\
\{\\
mid = (low + high) / 2;\\[0pt]
if (k < data[mid]) high = mid -1;\\[0pt]
else if (k > data[mid]) low = mid + 1;\\
else return mid; //查找成功,返回元素序号\\
\}\\
return 0; //查找失败,返回 0\\
)

\begin{verbatim}

\section*{3．折半查找的递归算法}

设查找区间为［low，high］，待查值为 $k$ ，折半查找递归算法的成员函数定义如下：
\end{verbatim}

int LineSearch::BinSearch2(int low, int high, int k)\\
\}\\
if (low > high) return 0; //递归的边界条件\\
else \{\\
int mid = (low + high) / 2;\\[0pt]
if (k < data[mid]) return BinSearch2(low, mid-1, k);\\[0pt]
else if (k > data[mid]) return BinSearch2 (mid+1, high, k);\\
else return mid; //查找成功,返回序号\\
\}\\
\}

\begin{verbatim}

\section*{4．折半查找的性能分析}

从折半查找的过程看，以有序表的中间记录作为比较对象，并以中间记录将有序表分割为两个有序子表，对子表继续这种操作。对表中每个记录的查找过程，可以用折半查找判定树（bisearch decision tree，简称判定树）来描述。设查找区间是［low，high］，判定树的构造方法为：
（1）当 low＞high 时，判定树为空；
（2）当 low $\leqslant h i g h$ 时，判定树的根结点是序号为 mid $=($ low $+h i g h) / 2$ 的记录，根结点的左子树是与有序表 $\mathrm{r}[$ low $] \sim \mathrm{r}[\mathrm{mid}-1]$ 相对应的判定树，根结点的右子树是与有序表 $r[\mathrm{mid}+1] \sim \mathrm{r}[\mathrm{high}]$ 相对应的判定树。

图 7－5 给出了具有 11 个结点的判定树，将判定树中所有结点的空指针域指向一个方形结点，并且称这些方形结点为外部结点，与之相对，称那些圆形结点为内部结点。显然，内部结点对应查找成功的情况，外部结点对应查找不成功的情况。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-238.jpg?height=455&width=1049&top_left_y=1004&top_left_x=312)

图 7－5 具有 11 个结点的判定树
可以看到，在有序表中查找任一记录的过程，即是判定树中从根结点到该记录结点的路径，和给定值的比较次数等于该记录结点在树中的层数。已经证明判定树的深度为 $\left\lfloor\log _{2} n\right\rfloor+1$ ，因此，查找成功时，比较次数至多为 $\left\lfloor\log _{2} n\right\rfloor+1$ 。查找不成功的过程是从根结点到外部结点的路径，和给定值进行的比较次数等于该路径上内部结点的个数。因此，查找不成功时和给定值进行比较的次数最多也不超过树的深度。

接下来讨论折半查找的平均查找长度。为便于讨论，假设判定树是深度为 $k$ 的满二叉树 $\left(n=2^{k}-1\right)$ 。若有序表中每个记录的查找概率相等，即 $p_{i}=1 / n(1 \leqslant i \leqslant n)$ ，而判定树的第 $i$ 层上有 $2^{i-1}$ 个结点，因此折半查找的平均查找长度为：

$$
\begin{aligned}
\mathrm{ASL} & =\sum_{i=1}^{n} p_{i} c_{i}=\frac{1}{n} \sum_{j=1}^{k} j \times 2^{j-1} \\
& =\frac{1}{n}\left(1 \times 2^{0}+2 \times 2^{1}+\cdots+k \times 2^{k-1}\right) \\
& \approx \log _{2}(n+1)-1
\end{aligned}
$$


所以，折半查找的平均时间复杂度为 $O\left(\log _{2} n\right)$ 。

\section*{7.3 树表的查找技术}

在一个大型的查找集合上进行动态查找，如何存储才能使得记录的插人、删除和查找操作都能够很快地完成呢？假设用顺序存储，如果不要求记录存储的有序性，那么插人操作很简单，只需将其放在表的末端，但是在一个无序表中进行顺序查找的平均查找时间为 $O(n)$ 。提高查找效率的方法是把记录进行排序，在有序表中进行折半查找只需要 $O\left(\log _{2} n\right)$时间，但是插人则需要 $O(n)$ 时间，因为在有序表中找到新记录的存储位置后，需要移动记录以便将新记录插入。将查找集合组织成树结构（称为＂树表＂）能够很好地实现动态查找，二叉排序树是常用的一种树表。

\section*{7．3．1 二叉排序树}

二叉排序树（binary sort tree）又称二叉查找树，或者是一棵空的二叉树，或者是具有下列性质的二叉树：
（1）若左子树不空，则左子树上所有结点的值均小于根结点的值；
（2）若右子树不空，则右子树上所有结点的值均大于根结点的值；
（3）左右子树也都是二叉排序树。
图7－6给出了查找集合 $\{63,55,90,42,58,70,10,45$ ， $67,83\}$ 对应的二叉排序树。可以看出，二叉排序树是记录之间满足一定次序关系的二叉树，中序遍历二叉排序树可以得到一个有序序列，这也是二叉排序树的名称之由来。

二叉排序树通常采用二叉链表进行存储，其结点结构可复用二叉链表的结点结构，请参见第5．5．2节。假定查找集合的记录为 int 型。下面给出二叉排序树的类定义，并讨论基本操
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-239.jpg?height=695&width=414&top_left_y=810&top_left_x=1287)

图 7－6 二叉排序树示例作的算法。
\end{verbatim}

class BiSortTree\\
\{\\
public:\\[0pt]
BiSortTree(int a[], int n); //建立集合 a[n]的二叉排序树

\begin{verbatim}
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-239.jpg?height=65&width=1298&top_left_y=1856&top_left_x=390)
\end{verbatim}

\begin{verbatim}
BiNode<int> * InsertBST(int x) {return InsertBST (root, x);}
    //掅人记录 x
void DeleteBST (BiNode<int> * p, BiNode<int> * f); //删除 f 的左孩子 p
BiNode<int> * SearchBST (int k) {return SearchBST (root, k);} //查找值为 k 的结点
\end{verbatim}

private:\\
BiNode<int> * InsextBST (BiNode<int> * bt, int x);\\
BiNode<int> * SearchBST (BiNode<int> * bt, int k);\\
void Release(BiNode<int> *bt); //析构函数调用,同二叉链表类\\
BiNode<int> * root; // 二叉排序树的根指针\\
\};

\begin{verbatim}

\section*{1．二叉排序树的查找}

由二叉排序树的定义，在二叉排序树中查找给定值 $k$ 的过程是：若 root 是空树，则查找失败；否则执行以下操作：
（1）若 $k$ 等于 root $->$ data，则查找成功；
（2）若 $k$ 小于 root $->$ data，则在 root 的左子树上查找；
（3）若 $k$ 大于 root $->$ data，则在 root 的右子树上查找。
在图 7－6 所示二叉排序树上查找 58 。首先将 58 与根结点比较，因为 $58<63$ ，则在 63的左子树上查找。 63 的左子树不空，则将 58 与其根结点 55 比较，因为 $58>55$ ，则在 55的右子树上查找。 55 的右子树不空，且 58 与其根结点相等，则查找成功。在图 7－6 所示二叉排序树上查找 95 ，在 95 同 $63 、 90$ 比较后，因为 $90<95$ ，则在以 90 的右子树上查找，但该子树为空，故查找失败。下面给出私有成员函数 SearchBST 的函数定义。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-240.jpg?height=383&width=1400&top_left_y=933&top_left_x=116)

\section*{2．二叉排序树的插入}

根据二叉排序树的定义，向二叉排序树中插人一个结点首先需要查找该结点的位置，然后再执行插人操作。例如，在图 7－7（a）所示二叉排序树上插入值为 98 的结点，插人后的二叉排序树如图 7－7（b）所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-240.jpg?height=328&width=802&top_left_y=1626&top_left_x=377)

图 7－7 二叉排序树的插人示例
由上述插人过程可以看出，新结点作为叶子插人到二叉排序树中，无论是插在左子树还是右子树，都是按同样方法处理 ${ }^{(1)}$ ，所以插人过程是递归的。下面给出私有成员函数 InsertBST 的函数定义。

\footnotetext{
（1）这里假设二叉排序树不存在值相同的结点。假如某个结点的值与被插人结点的值相同，可以有两种选择：如果该应用不允许结点有相同的值，则把这个插人作为错误处理；如果允许有相同的值，通常将其插在右子树中。
}
\end{verbatim}

BiNode<int> * BiSortTree::InsertBST (BiNode<int> * bt, int x)\\
\{\\
if (bt == nullptr) \{ //找到括人位置\\
BiNode<int> * s = new BiNode<int>; s->data = x;\\
s->lchild = s->rchild = nullptr;\\
bt = s;\\
return bt;\\
)\\
else if (bt->data > x) bt ->lchild = InsertBST(bt->lchild, x);\\
else bt->rchild = InsertBST(bt->rchild, x);

\begin{verbatim}
}
\end{verbatim}

\section*{3．构造函数——构造一棵二叉排序树}
构造二叉排序树的过程是从空的二叉排序树开始，依次插人每一个结点。图 7－8 给出了对于集合 $\{63,90,70,55,67,42,98\}$ 建立二叉排序树的过程。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-241}

图 7－8 二叉排序树的构造过程\\
构造一棵二叉排序树通过不断调用二叉排序树的插人算法而进行。设查找集合存放在数组 $\mathrm{a}[\mathrm{n}]$ 中。下面给出构造函数的函数定义。

\begin{verbatim}
BiSortTree::BiSortTree(int a[], int n)
l
    root = nullptr;
    for (int i = 0; i < n; it+)
        root = InsertBST(root,a[i]);
}
\end{verbatim}

\section*{4．二叉排序树的删除}
二叉排序树的删除操作比插人操作要复杂一些。首先，从二叉排序树中删除一个结点之后，仍然要保持二叉排序树的特性；其次，由于被插入的结点都是作为叶子结点链接到二叉排序树上，因而不会破坏结点之间的链接关系，而删除结点则不同，被删除的可能是叶子结点，也可能是分支结点，当删除分支结点时就破坏了二叉排序树中原有结点之间

的链接关系，需要重新修改指针，使得删除结点后仍为一棵二叉排序树。\\
不失一般性，设待删除结点为 $p$ ，其双亲结点为 $f$ ，且 $p$ 是 $f$ 的左孩子，$p_{L}$ 表示 $p$ 的左子树，$p_{R}$ 表示 $p$ 的右子树，则被删除结点有以下三种情况。\\
（1）结点 $p$ 为叶子，$p$ 既没有左子树 $p_{L}$ 也没有右子树 $p_{R}$\\
由于删除叶子结点不影响二叉排序树的特性，所以，只需将结点 $p$ 的双亲结点 $f$ 的相应指针域改为空指针，即 $f->$ lchild $=$ NULL，如图 7－9 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-242}

图 7－9 在二叉排序树中删除叶子结点\\
（2）结点 p 只有左子树 $\mathrm{p}_{\mathrm{L}}$ 或只有右子树 $\mathrm{p}_{\mathrm{R}}$\\
由于 $p_{L}$ 和 $p_{R}$ 的值均小于结点 $f$ 的值，所以，只需将 $p_{L}$ 或 $p_{R}$ 替换为 $f$ 的左子树，既 $f->$ lchild $=p->$ lchild 或 $f->$ lchild $=p->$ rchild，仍保持二叉排序树的特性，如图 7－10所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-242(1)}

图 7－10 在二叉排序树中删除只有一个子树的结点\\
（3）结点 $p$ 既有左子树 $p_{L}$ 又有右子树 $p_{R}$\\
显然，不能简单地删除结点 $p$ ，可以从 $p$ 的某个子树中找出一个结点 $s$ ，其值能够代替结点 $p$ 的值，这样，就可以用结点 $s$ 的值去替换结点 $p$ 的值，再删除结点 $s$ 。那么，什么值能够代替那个被删除结点的值呢？

由于必须在使二叉排序树的结构不发生较大变化的同时保持二叉排序树的特性，因而不是任意一个值都可以替换结点 p 的值，这个值应该是大于结点 p 的最小者（或者小于结点 $p$ 的最大者），即结点 $p$ 的右子树中值最小的结点，具体过程是：（1）将 $s$ 初始化为 $p->r$ rchild；（2）将 $s$ 沿左分支下移，直到最左下结点；（3）将 $s$ 的父结点 par 指向 $s$ 的指针改为指向 $s$ 的右孩子（par $->$ lchild $=s->r$ child）；（4）删除结点 $s$（ $s$ 肯定没有左子树）。例如，从图7－11（a）所示二叉排序树中删除值 47 的结点，把结点 47 的右子树中值最小的结点 50 代替被删结点的值 47 ，然后把结点 50 删除。注意边界情况，如图7－11（b）所示，结点 $p$ 的右孩子即是 $p_{R}$ 中最小值结点，此时需要将 $s$ 的父结点 par 指向 $s$ 的指针改为指向 s 的右孩子（par $->\mathrm{rchild}=\mathrm{s}->\mathrm{rchild}$ ），再删除结点 s 。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-243(1)}

图 7－11 在二叉排序树中删除具有两个子树的分支结点\\
综上，下面给出在二叉排序树中删除结点 $p$ 的成员函数定义。

\begin{verbatim}
void BiSortTree::DeleteBST (BiNode<int> * p, BiNode<int> * f)
{
    if((p->lchild == nullptr) && (p->>rchild == nullptr)) {
        f->lchild = nullptr; delete p; return; //p 为叶子
}
    if (p->rchild = = nullptx) { //p 只有左子树
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-243}
\end{center}

\begin{verbatim}
    f->lchild = p->lchild; delete p; return;
    }
    if (p->lchild = = nullptr) { //p 只有右子树
        f->lchild = p->rchild; delete p; return;
    }
    BiNode * par = p, * s = p->rchild;/ /p 的左右子树均不空
    while (s->lchild != nullptr) //查找最左下结点
    1
        par = s;
        s= s->lchild;
    }
    p->data = s->data;
\end{verbatim}

\begin{verbatim}
if (par==p) par ->rchild=s->rchild; //特殊情况
else par -> lchild=s->rchild;
delete s;
}
\end{verbatim}

\section*{5．二叉排序树的性能分析}
在二叉排序树中执行插人和删除操作，首先都要执行查找操作。对于插人操作，在找到插人位置后，只需修改相应指针；对于删除操作，在找到被删结点后，当被删结点既有左子树又有右子树时，在找到替代结点后，只需修改相应指针。因而二叉排序树的插人、删除和查找操作具有相同的时间性能。

在二叉排序树上查找某个结点的过程，恰好是从根结点到该结点的路径，和给定值的比较次数等于给定值结点在二叉排序树中的层数，比较次数最少为 1 次（即整个二叉排序树的根结点就是待查结点），最多不超过树的深度。在二叉排序树的构造过程中，插人结点的次序不同，二叉排序树的形态就不同。所以，对应同一个查找集合，可以有不同形态的二叉排序树，而不同形态的二叉排序树可能具有不同的深度，这直接影响着二叉排序树的操作效率。具有 $n$ 个结点的二叉排序树，其最大深度为 $n$ ，最小深度为 $\left\lfloor\log _{2} n\right\rfloor+1$ ，如图7－12 所示。因此，二叉排序树的查找性能在 $O\left(\log _{2} n\right)$ 和 $O(n)$ 之间。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-244(1)}

图 7－12 同一个查找集合不同插人次序对应不同形态的二叉排序树

\section*{7．3．2 平衡ニ叉树}
二叉排序树的查找效率取决于二叉排序树的形态，而二叉排序树的形态与插人结点的次序有关，但是结点的插人次序是不确定的，这就要求找到一种动态平衡的方法，对于任意给定的记录序列都能构造一棵形态均匀的、平衡的二叉排序树。首先给出几个基本概念。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-244}

平衡二叉树（balance binary tree）${ }^{(1)}$ 或者是一棵空的二叉排序树，或者是具有下列性质的二叉排序树：\\
（1）根结点的左子树和右子树的深度最多相差 1；

\footnotetext{（1）平衡二叉树由俄罗斯数学家 Adelson－Velskii 和 Landis 在1962年提出，因此也称为 AVL 树。
}
（2）根结点的左子树和右子树都是平衡二叉树。\\
结点的平衡因子（balance factor）是该结点的左子树的深度与右子树的深度之差。显然，在平衡二叉树中，结点的平衡因子只可能是－1、0和1。图7－13给出了两棵平衡二叉树，每个结点里所注数字是该结点的平衡因子。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-245}

图 7－13 平衡二叉树示例

最小不平衡子树（minimal unbalance subtree）是指在平衡二叉树的构造过程中，以距离插人结点最近的、且平衡因子的绝对值大于 1 的结点为根的子树，这个根结点称为最小不平衡点（minimal unbalance node），也称关键不平衡点。在插入某结点导致平衡二叉树失衡时，只需调整最小不平衡子树，并且最小不平衡子树的深度在调整前后保持不变。

构造平衡二叉树需要根据新插入结点和最小不平衡点之间的关系，对最小不平衡子树进行相应调整。设结点 A 为最小不平衡点，对该子树进行平衡调整有以下 4 种情况。\\
（1）LL 型\\
图 7－14（a）为插人前的平衡二叉树，结点 x 插在结点 B 的左子树 $\mathrm{B}_{\mathrm{L}}$ 上，导致结点 A的平衡因子由 1 变为 2 ，以结点 A 为根的子树失去了平衡，如图 7－14（b）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-245(1)}

图 7－14 LL 型调整（调整前后最小不平衡子树的深度不变）

新插人的结点是插在结点 A 的左孩子的左子树上，属于 LL 型，需要调整一次。好比条扁担出现了一头重一头轻的现象，将支撑点（即根结点）由 A 改为 B ，则扁担又恢复了平衡，这可以形象地称为扁担原理，相应地，需要进行顺时针旋转。旋转后，结点 A 和 $B_{R}$ 发生冲突，解决办法是＂旋转优先＂，结点 $A$ 成为结点 $B$ 的右孩子，结点 $B$ 的右子树 $B_{R}$成为结点 A 的左子树，如图 7－14（c）所示。\\
（2）RR 型\\
图7－15（a）为插人前的平衡二叉树，将结点 $x$ 插人在结点 $B$ 的右子树 $B_{R}$ 上，导致结点 A 的平衡因子由 -1 变为 -2 ，以结点 A 为根的子树失去了平衡，如图7－15（b）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-246}

图 7－15 RR 型调整（调整前后最小不平衡子树的深度不变）\\
新插人的结点是插在结点 A 的右孩子的右子树上，属于 RR 型，需要调整一次。根据扁担原理将支撑点由 $A$ 改为 $B$ ，相应地，需要进行逆时针旋转。旋转后，结点 $A$ 和结点 $B$ 的左子树 $B_{L}$ 发生冲突，根据旋转优先原则，结点 $A$ 成为结点 $B$ 的左孩子，结点 $B$ 的左子树 $B_{L}$ 成为结点 $A$ 的右子树，如图7－15（c）所示。

\section*{（3）LR 型调整}
结点 x 插在根结点 A 的左孩子的右子树上，使结点 A 的平衡因子由 1 变为 2 ，以结点 A 为根的子树失去了平衡，如图 7－16（a）所示。这属于 LR 型，需调整两次。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-246(1)}

图 7－16 LR 型调整（调整前后最小不平衡子树的深度不变）\\
第一次调整：根结点 A 不动，先调整结点 A 的左子树。将支撑点由结点 B 调整到结点 C 处，相应地，需进行逆时针旋转。在旋转过程中，结点 B 和结点 C 的左子树 $\mathrm{C}_{\mathrm{L}}$ 发生了冲突，按照旋转优先原则，结点 $B$ 作为结点 $C$ 的左孩子，$C_{L}$ 作为结点 $B$ 的右子树，其他结点之间的关系没有发生冲突，如图7－16（b）所示。

第二次调整：调整最小不平衡子树。将支撑点由结点 A 调整到结点 C ，相应地，需进行顺时针旋转。结点 A 作为结点 C 的右孩子，结点 C 的右子树 $\mathrm{C}_{\mathrm{R}}$ 作为结点 A 的左子树，如图 7－16（c）所示。\\
（4）RL 型调整\\
结点 x 插在根结点 A 的右孩子的左子树上，使结点 A 的平衡因子由 -1 变为 -2 ，以结点 A 为根的子树失去了平衡，如图 7－17（a）所示。这属于 RL 型，也需调整两次。

第一次调整：根结点 A 不动，先调整根结点 A 的右子树。将支撑点由结点 B 调整到结点 C 处，相应地，需进行顺时针旋转。在旋转过程中，结点 B 和结点 C 的右子树 $\mathrm{C}_{\mathrm{R}}$ 发

生了冲突，按照旋转优先的原则，结点 $B$ 作为结点 $C$ 的右孩子，$C_{R}$ 作为结点 $B$ 的左子树，其他结点之间的关系没有发生冲突，如图7－17（b）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-247(1)}

图 7－17 RL 型调整（调整前后最小不平衡子树的深度不变）\\
第二次调整：调整整个最小不平衡子树。将支撑点由结点 A 调整到结点 C ，相应地，需进行逆时针旋转。结点 A 作为结点 C 的左孩子，结点 C 的左子树 $\mathrm{C}_{\mathrm{L}}$ 作为结点 A 的右子树，如图 7－17（c）所示。

平衡二叉树的构造过程是：每插人一个结点，首先从插人结点开始沿通向根结点的路径计算各结点的平衡因子，如果某结点平衡因子的绝对值超过 1 ，则说明插入操作破坏了二叉排序树的平衡性，需要进行平衡调整；否则继续执行插人操作。如果二叉排序树不平衡，则找出最小不平衡子树的根结点，根据新插人结点与最小不平衡子树根结点之间的关系判断调整类型，进行相应的调整，使之成为新的平衡子树。下面看一个具体的例子。

【例 7－2】为集合 $\{20,35,40,15,30,25\}$ 构造一棵平衡二叉树。\\
解：在一棵空的二叉排序树上插人 20 和 35，产生如图7－18（a）所示的二叉排序树，此时显然平衡。当把 40 插人时出现了不平衡现象，如图7－18（b）所示。最小不平衡子树的根结点是 20 ，结点 40 是插在结点 20 的右孩子的右子树上，属于 $R R$ 型，需要调整一次，根据扁担原理，将支撑点由 20 调整为 35 ，成为新的平衡二叉树，如图7－18（c）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-247}

图 7－18 RR 型调整的例子\\
再插人 15 和 30 ，二叉排序树还是平衡的，如图 7－19（a）所示。当插入 25 时失去了平衡，如图7－19（b）所示。最小不平衡子树的根结点是 35 ，结点 25 插在结点 35 的左孩子的右子树上，属于 LR 型，需要调整两次。第一次调整，先调整结点 35 的左子树（即扁担中较重的一头）。根据扁担原理，将支撑点由 20 调整为 30 ，显然应进行逆时针旋转。在这

次调整中有一个冲突： 25 是 30 的左孩子，旋转后 20 也应作 30 的左孩子，解决的办法是旋转优先，即 30 的左孩子应是旋转下来的 20 ，而 25 应作 20 的右孩子，如图7－19（c）所示。第二次调整，调整最小不平衡子树，将支撑点由 35 调整为 30 ，显然应进行顺时针旋转，如图 7－19（d）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-248(1)}

图 7－19 LR 型调整的例子\\
设 $N_{h}$ 表示深度为 $h$ 的平衡二叉树中的最少结点个数，则有如下递推关系成立：$N_{0}=$ $0, N_{1}=1, N_{h}=N_{h-1}+N_{h-2}+1^{(1)}$ 。在平衡二叉树上进行查找的比较次数最多不超过树的深度，具有 $n$ 个结点的平衡二叉树的深度是 $1.44 \log _{2}(n+2)-1.328$ ，在平衡二叉树上进行查找的时间复杂度为 $O\left(\log _{2} n\right)$ 。

\section*{7．3．3 B 树}
B 树（B－tree）${ }^{(2)}$ 是一种平衡的多路查找树，通常用在文件系统中。

\section*{1．B 树的定义}
\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-248}
\end{center}

一棵 $m$ 阶的 B 树或者为空树，或者为满足下列特性的 $m$ 叉树：\\
（1）每个结点至多有 $m$ 棵子树。\\
（2）根结点至少有两棵子树。\\
（3）除根结点外，其他结点至少有 $\lceil m / 2\rceil$ 棵子树。\\
（4）所有结点包含以下数据：$\left(n, A_{0}, K_{1}, A_{1}, K_{2}, \cdots, K_{n}, A_{n}\right)$ 。\\
其中，$n(\lceil m / 2\rceil-1 \leqslant n \leqslant m-1)$ 为关键码的个数，$K_{i}(1 \leqslant i \leqslant n)$ 为关键码，且 $K_{i}<K_{i+1}$ $(1 \leqslant i \leqslant n-1), A_{i}(0 \leqslant i \leqslant n)$ 为指向子树根结点的指针，且指针 $A_{i}$ 所指子树中所有结点的关键码均小于 $K_{i+1}$ 大于 $K_{i}$ 。\\
（5）所有叶子结点都出现在同一层，所以 B 树是树高平衡的。\\
将 B 树叶子结点的所有空指针指向一个方形的外部结点，表示查找失败的结点 ${ }^{(3)}$ 。

\footnotetext{（1）注意到，$N_{b}$ 的递归定义与斐波那契数列 $F_{0}=0, F_{1}=1, F_{n}=F_{n-1}+F_{n-2}$ 类似。事实上，可以证明，对于 $h \geqslant 1$ ，有 $N_{h}=F_{h+2}-1$ 成立。\\
（2）B树由 R．Bayer 和 E．M．McCreight 于1970年根据直接存储设备的读写操作以＂页＂为单位的特征而提出的，通常用作外存的存储结构。B 即 balanced，平衡的意思。\\
（3）很多教材将 B 树的外部结点称为叶子结点，将外部结点的双亲称为终端结点，这与树的基本术语发生矛盾。笔者查阅了相关资料和原始论文，纠正了这个错误。
}通常这些方形的外部结点可以不画出来。图 7－20 所示为一棵 4 阶 B 树。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-249}

图7－20 一个 4 阶 B 树

\section*{2．查找}
B 树的查找类似于二叉排序树的查找，不同的是 B 树的每个结点是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，按照指针到相应的子树中查找，到达空指针（即外部结点）时，查找失败。例如，在图 7－20 所示 B 树中查找 53 ，首先从 root 指向的根结点 $a$ 开始，根结点 $a$ 中只有一个关键码，且 53 大于 35 ，因此，按根结点 $a$ 的指针域 $A_{1}$ 到结点 $c$ 去查找，结点 $c$ 有两个关键码，而 53 大于 43 小于 78 ，应按结点 $c$ 指针域 $A_{1}$ 到结点 $g$ 去查找，在结点 $g$ 中找到 53 ，查找成功。

在 B 树上的查找过程是一个顺指针查找结点和在结点中查找关键码交叉进行的过程。由于 B 树通常存储在磁盘上，则前一个查找操作是在磁盘上进行，而后一个查找操作是在内存中进行，即在磁盘上找到某结点后，先将结点的信息读人内存，然后再查找等于 $k$ 的关键码。显然，在磁盘上进行一次查找比在内存中进行一次查找耗费的时间多得多，因此，在磁盘上进行查找的次数，即待查关键码所在结点在 B 树的层数，是决定 B 树查找效率的首要因素。

设深度为 $k$ 的 $m$ 阶 B 树含有 $n$ 个关键码，最坏情况下的深度是多少呢？由 B 树的定义，第一层至少有 1 个结点；第二层至少有 2 个结点；由于除根结点外的每个非终端结点至少有 $\left\lceil\frac{m}{2}\right\rceil$ 棵子树，则第三层至少有 $2\left\lceil\frac{m}{2}\right\rceil$ 个结点；以此类推，第 $k+1$ 层至少有 $2\left(\left[\frac{m}{2}\right]\right)^{k-1}$ 个结点，而 $k+1$ 层的结点为外部结点。若 $m$ 阶 B 树有 $n$ 个关键码，则外部结点即查找不成功的结点为 $n+1$ ，由此有：

$$
n+1 \geqslant 2 \times\left(\left\lceil\frac{m}{2}\right\rceil\right)^{k-1}
$$

即：

$$
k \leqslant \log _{[m / 2]}\left(\frac{n+1}{2}\right)+1
$$

含有 $n$ 个关键码的 $m$ 阶 B 树的最大深度是 $\log _{\lceil m / 2\rceil}\left(\frac{n+1}{2}\right)+1$ ，也就是说，在含有 $n$个关键码的 B 树上进行查找，从根结点到关键码所在结点的路径上涉及的结点数不超过 $\log _{[m / 2]}\left(\frac{n+1}{2}\right)+1$ 。

\section*{3．插入}
假定在 $m$ 阶 B 树插人关键码 key，设 $n=m-1$ ，即 $n$ 为结点中关键码个数的最大值， $B$ 树的插人过程如下：\\
（1）定位：确定关键码 key 应该插人哪个叶子结点。定位的结果是返回了key 所在叶子结点的指针 $p$ ，若 $p$ 中的关键码个数小于 $n$ ，则直接插人关键码 key；否则，结点 $p$ 的关键码个数溢出，执行＂分裂——提升＂过程。\\
（2）分裂——提升：将结点 $p$＂分裂＂成两个结点，分别是 $p 1$ 和 $p 2$ ，把中间的关键码 $k$ ＂提升＂到父结点，并且 $k$ 的左指针指向 $p 1$ ，右指针指向 $p 2$ 。如果父结点的关键码个数也溢出，则继续执行＂分裂——提升＂过程。显然，这种分裂可能一直上传，如果根结点也分裂了，则树的高度增加了一层。现在可以解释为什么 B 树的根结点最少有两棵子树，如果在 B 树中插人一个元素时导致根结点发生溢出，则 B 树产生一个新的根结点并且树高增加了一层，新根只有一个关键码和两棵子树。

【例 7－3】对于图 7－21（a）所示 3 阶 B 树，写出插人关键码 62、65、30 和 86 的过程。\\
解：插人 62 后结点中的关键码个数没有溢出，可以直接插人，如图（b）所示。插人 65后结点中的关键码个数超过两个，需要分裂，并将结点的中间关键码 65 提升到双亲结点，如图（c）和（d）所示。插入 30 后结点中的关键码个数发生溢出，需要分裂，并将结点的中间关键码 28 提升到双亲结点，双亲结点再次发生溢出，将中间关键码 28 提升到根结点，如图（e）和（f）所示。插人 86 后结点中的关键码个数发生溢出，将中间关键码 90 提升到双亲结点，再次发生溢出，将中间关键码 80 提升到根结点，导致根结点发生溢出，分裂根结点并使树高增加 1 层，如图（g）和（h）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-250}

图 7－21 B树的插人操作示例\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-251}

图 7－21（续）

\section*{4．删除}
假设在 $m$ 阶 B 树中删除关键码 key。首先要找到 key 的位置，即＂定位＂，返回 key 所在结点的指针 $q$ ，假定 key 是结点 $q$ 中第 $i$ 个关键码 $K_{i}$ ，若结点 $q$ 不是叶子结点，则用 $A_{i}$所指子树的最小值 $x$ 来＂替换＂$K_{i}$ 。由于 $x$ 所在结点一定是叶子结点，这样，删除问题就归结为在叶子结点删除关键码。

如果叶子结点关键码的个数大于 $\left\lceil\frac{m}{2}\right\rceil-1$ ，则可直接删除该关键码；否则不符合 $m$ 阶 B 树的要求，具体分两种情况：\\
（1）兄弟够借。查看相邻的兄弟结点，如果兄弟结点有足够多的关键码（多于 $\left\lceil\frac{m}{2}\right\rceil$ ，就从兄弟结点借来一个关键码，为了保持 B 树的特性，将借来的关键码＂上移＂到被删结点的双亲结点中，同时将双亲结点中相应关键码＂下移＂到被删结点中。\\
（2）兄弟不够借。如果没有一个兄弟结点可以把记录借给被删结点，那么被删结点就必须把它的关键码让给一个兄弟结点，即执行＂合并＂操作，并且从树中把这个空结点删除。兄弟结点当然有空间，因为兄弟结点至多半满，合并后被删结点的双亲少了一个结点，所以要把双亲结点中的一个关键码＂下移＂到合并结点中。如果被删结点的双亲结点中的关键码的个数没有下溢，则合并过程结束；否则，双亲结点也要进行借关键码或合并结点。显然，合并过程可能会上传到根结点，如果根结点的两个孩子结点合并到一起，则 B 树就会减少一层。

【例 7－4】对于如图 7－22（a）所示 3 阶 B 树，写出删除关键码 $90 、 50 、 40$ 和 70 的过程。\\
解：删除 90 后结点中的关键码个数没有发生下溢，可以直接删除，如图（b）所示。删除 50 后结点中的关键码个数发生下溢，向左兄弟借关键码 28 ，并将 28 上移到双亲结点中，将 40 下移到被删结点中，如图7－22（c）所示。删除 40 后结点中的关键码个数发生下

溢，但是兄弟结点没有多余的关键码借给这个被删结点，将被删结点与左兄弟合并，并将 28 下移到被删结点中，如图7－22（d）所示。删除70后结点中的关键码个数发生下溢，但是兄弟结点没有多余的关键码借给这个被删结点，将被删结点与右兄弟合并，并将 90下移到被删结点中，导致再次发生下溢，合并过程上传到根结点并使树高减少 1 层，如图7－22（e）和图7－22（f）所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-252(1)}

图 7－22 B树的删除操作示例

\section*{7.4 散列表的查找技术}
\section*{7．4．1 散列查找的基本思想}
所谓查找，实际上就是要确定待查记录在查找结构中的存储位置。前面讨论的所有查找技术，由于记录的存储位置和关键码之间不存在确定的对应关系，查找只能通过一系列的给定值与关键码的比较。这类查找技术都是建立在比较的基础之上，查找的效率依赖于查找过程中进行\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-252}的给定值与关键码的比较次数，这不仅和查找集合的存储结构有关，还与查找集合的大小以及待查记录在集合中的位置有关。

理想情况是不经过任何比较，直接便能得到待查记录的存储位置，那就必须在记录的存储位置和它的关键码之间建立一个确定的对应关系 $H$ ，使得每个关键码 key 和唯一的

存储位置 $H(k e y)$ 相对应 ${ }^{(1)}$ 。存储记录时，根据这个对应关系找到关键码的映射地址，并按此地址存储该记录 ${ }^{(2)}$ ；查找记录时，根据这个对应关系找到待查关键码的映射地址，并按此地址访问该记录，这种查找技术称为散列技术 ${ }^{(3)}$ 。采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表（hash table），将关键码映射为散列表中适当存储位置的函数称为散列函数（hash function），所得的存储位置称为散列地址 （hash address）。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-253}

图 7－23 散列查找的基本思想\\
在散列技术中，由于记录的定位主要基于散列函数的计算，不需要进行关键码的多次比较，所以，一般情况下，散列技术的查找速度要比基于比较的查找技术的查找速度快。但是，散列技术一般不适用于多个记录有相同关键码的情况，也不适用于范围查找。散列技术最适合回答的问题是：如果有的话，哪个记录的关键码等于待查值。

散列技术通过散列函数建立了从关键码集合到散列表地址集合的一个映射。设查找集合有 $n$ 个记录，散列表有 $m$ 个地址单元，即散列函数的定义域是 $n$ 个记录的关键码，值域是 $m$ 个地址单元，而且关键码可能来自很大范围，这就产生了如何设计散列函数的问题。

在理想情况下，对任意给定的查找集合 $T$ ，如果选定了某个理想的散列函数 $H$ 及相应的散列表 $L$ ，则对 $T$ 中记录 $r_{i}$ 的关键码 $k_{i}, H\left(k_{i}\right)$ 就是记录 $r_{i}$ 在散列表 $L$ 中的存储位置 ${ }^{(4)}$ 。但是在实际应用中，往往会出现这样的情况：对于两个不同的关键码 $k_{1} \neq k_{2}$ ，有 $H\left(k_{1}\right)=H\left(k_{2}\right)$ ，即两个不同的记录需要存放在同一个存储位置中，这种现象称为冲突 （collision），也称碰撞，$k_{1}$ 和 $k_{2}$ 相对于 $H$ 称作同义词（synonym）。如果记录按散列函数计算的地址加人散列表时产生了冲突，就必须另外再找一个地方来存放它，这就产生了如何处理冲突的问题。因此，采用散列技术需要考虑的两个主要问题是：\\
（1）散列函数的设计。如何设计一个简单、均匀、存储利用率高的散列函数。\\
（2）冲突的处理。如何采取合适的处理冲突方法来解决冲突。

\footnotetext{（1）从是否基于比较的角度，可以将查找分为两类：比较型查找和计算型查找。\\
（2）散列不是一种完整的存储结构，因为它只是通过记录的关键码定位该记录，没有完整地表示记录之间的逻辑关系，所以，散列主要是面向查找的存储结构。\\
（3）散列的英文是 hash，有些教材也将散列称为 hash、哈希（音译）或杂凑，散列体现了其技术特征。\\
（4）理想情况下的散列称为完美散列。完美散列的查找效率是最好的，因为它总会在散列函数计算出的位置上找到待查记录，即只需一次访问。设计一个完美的散列函数是不容易的，但是在需要保证查找性能时也是值得的。
}\section*{7．4．2 散列函数的设计}
设计散列函数一般遵循以下基本原则：（1）计算简单。散列函数不应该有很大的计算量，否则会降低查找效率；（2）函数值（即散列地址）分布均匀 ${ }^{(1)}$ ，希望散列函数能够把记录以相同的概率＂散列＂到散列表的所有地址空间中，这样才能保证存储空间的有效利用，并减少冲突。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-254}

以上两个方面在实际应用中往往是矛盾的。为了保证散列地址的均匀性比较好，散列函数的计算就必然要复杂；反之，如果散列函数的计算比较简单，则均匀性就可能比较差。一般来说，散列函数依赖于关键码的分布情况，而在许多应用中，事先并不知道关键码的分布情况，或者关键码高度集中（即分布得很差）。因此，在设计散列函数时，要根据具体情况，选择一个比较合理的方案。下面介绍三种常见的散列函数。

\section*{1．直接定址法}
直接定址法的散列函数是关键码的线性函数，即：


\begin{equation*}
H(k e y)=\mathrm{a} \times k e y+\mathrm{b} \quad(\mathrm{a} 、 \mathrm{~b} \text { 为常数 }) \tag{7-2}
\end{equation*}


例如，关键码集合为 $\{10,30,50,70,80,90\}$ ，选取的散列函数为 $H(k e y)=k e y / 10$ ，则散列表如图 7－24 所示。

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\hline
 & 10 &  & 30 &  & 50 &  & 70 & 80 & 90 \\
\hline
\end{tabular}
\end{center}

图 7－24 用直接定址法构造的散列表\\
直接定址法的特点是不会产生冲突，但实际应用中能使用这种散列函数的情况很少。它适用于事先知道关键码的分布，关键码集合不是很大且连续性较好的情况。

\section*{2．除留余数法}
除留余数法的基本思想是：选择某个适当的正整数 $p$ ，以关键码除以 $p$ 的余数作为散列地址，即：


\begin{equation*}
H(k e y)=k e y \quad \bmod \quad p \tag{7-3}
\end{equation*}


可以看出，这个方法的关键在于选取合适的 $p$ ，否则容易产生同义词。例如，若 $p$ 含有质因子，例如 $p=m \times n$ ，则所有含有 $m$ 或 $n$ 因子的关键码的散列地址均为 $m$ 或 $n$ 的倍数，如图 7－25 所示。显然，这增加了冲突的机会。一般情况下，若散列表表长为 $m$ ，通常选 $p$ 为小于或等于表长（最好接近 $m$ ）的最小素数或不包含小于 20 质因子的合数。

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
关键码 & 0 & 7 & 14 & 21 & 28 & 35 & 42 & 49 & 56 \\
\hline
散列地址 & 0 & 7 & 14 & 0 & 7 & 14 & 0 & 7 & 14 \\
\hline
\end{tabular}
\end{center}

图 7－25 $p=21$ 的散列地址示例

\footnotetext{（1）散列函数有一个启发式规则：越是随机、越是没有规律，就越是好的散列函数。
}除留余数法是一种最简单、最常用的构造散列函数的方法，并且这种方法不要求事先知道关键码的分布。

\section*{3．平方取中法}
平方取中法是对关键码平方后，按散列表大小，取中间的若干位作为散列地址（简称平方后截取），其原理是一个数平方后，中间的几位分布较均匀，从而冲突发生的概率较小。例如，对于关键码 1234 ，假设散列地址是 2 位，由于 $(1234)^{2}=1522756$ ，选取中间的 2位作为散列地址，可以选 22 也可以选 27 。

平方取中法通常用在事先不知道关键码的分布且关键码的位数不是很大的情况，例如，有些编译器对标识符的管理采用的就是这种方法。

\section*{7．4．3 处理冲突的方法}
通常情况下，由于关键码的复杂性和随机性，很难找到理想的散列函数。如果某记录按散列函数计算出的散列地址加人散列表时产生了冲突，就必须另外再找一个地方来存放它，因此，需要有合适的处理冲突方法。采用不同的处理冲突方法可以得到不同的散列表。下面介绍两种常用的处理冲突方法。

\section*{1．开放定址法}
用开放定址法（open addressing）处理冲突得到的散列表叫作闭散列表。

开放定址法处理冲突的方法是，如果由关键码得到的散列地址产生了冲突，根据式（7－4）寻找下一个空的散列地址：


\begin{equation*}
\left(H(k e y)+d_{i}\right) \% m \tag{7-4}
\end{equation*}


其中，若 $d_{i}=1,2, \cdots, m-1$ ，称为线性探测法；若 $d_{i}=1^{2},-1^{2}, 2^{2},-2^{2}, \cdots, q^{2},-q^{2}$且 $q \leqslant \sqrt{m}$ ，称为二次探测法。

只要散列表足够大，采用开放定址法就一定能够找到空的散列地址。下面给出闭散列表的类定义，其中成员变量实现闭散列表的存储，成员函数实现插人、删除、查找等动态查找的基本操作。

\begin{verbatim}
const int MaxSize = 100;
class HashTable1
{
public:
    HashTablel(); //构造函数,初姶化空散列表
    ~HashTable1() { } //析构函数为空
    int Insert (int k); // 插入
    int Delete(int k); ///每除
    int Search (int k); //查找
private:
    int H(int k); //散列函数
    int ht [MaxSize]; //闭散列表
\end{verbatim}

\begin{verbatim}
};
HashTable1 :: HashTable1()
{
    for (int i = 0; 1 < MaxSize; i++)
        ht[i] = 0; /10 表示该散列单元为空
}
\end{verbatim}

【例 7－5】设关键码集合 $\{47,7,29,11,16,92,22,8,3\}$ ，散列表表长为 11 ，散列函数为 $H(k e y)=k e y \bmod 11$ ，用线性探测法处理冲突，得到的闭散列表如图 7－26 所示，具体过程如下：\\
$H(47)=3, H(7)=7$ ，没有冲突，直接存人；\\
$H(29)=7$ ，散列地址发生冲突，需寻找下一个空的散列地址，$(H(29)+1) \bmod 11=$ 8 ，散列地址 8 为空，将 29 存人；\\
$H(11)=0, H(16)=5, H(92)=4$ ，没有冲突，直接存人；\\
$H(22)=0$ ，散列地址发生冲突，$(H(22)+1) \bmod 11=1$ ，将 22 存人；\\
$H(8)=8$ ，散列地址发生冲突，$(H(8)+1) \bmod 11=9$ ，将 8 存人；\\
$H(3)=3$ ，散列地址发生冲突，$(H(3)+1) \bmod 11=4$ ，仍然冲突；$(H(3)+2) \bmod$ $11=5$ ，仍然冲突；$(H(3)+3) \bmod 11=6$ ，将 3 存人。

查找成功的平均查找长度是：$(5 \times 1+3 \times 2+1 \times 4) / 9=15 / 9$ 。\\
散列地址：\\
散列表

比较次数： \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
11 & 22 &  & 47 & 92 & 16 & 3 & 7 & 29 & 8 &  \\
\hline
1 & 2 &  & 1 & 1 & 1 & 4 & 1 & 2 & 2 &  \\
\hline
\end{tabular}

图 7－26 线性探测法构造的闭散列表\\
用线性探测法处理冲突的方法很简单，但同时也引出新的问题。例如，当插人记录 3时， 3 和 $92 、 3$ 和 16 本来都不是同义词，但 3 和 92 的同义词、 3 和 16 的同义词都将争夺同一个后继地址，这种在处理冲突的过程中出现的非同义词之间对同一个散列地址争夺的现象称为堆积（mass）。显然，堆积降低了查找效率。

采用二次探测法处理冲突可以减少堆积的发生。例 7－8 的查找集合用二次探测法处理冲突，为关键码寻找空的散列地址只有关键码 3 与线性探测法不同，$H(3)=3$ ，散列地址发生冲突，$\left(H(3)+1^{2}\right) \bmod 11=4$ ，仍然冲突；$\left(H(3)-1^{2}\right) \bmod 11=2$ ，找到空的散列地址，将 3 存人。构造的闭散列表如图7－27所示。

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
\hline
散列地址： & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
散列表 & 11 & 22 & 3 & 47 & 92 & 16 &  & 7 & 29 & 8 &  \\
\hline
比较次数： & 1 & 2 & 3 & 1 & 1 & 1 &  & 1 & 2 & 2 &  \\
\hline
\end{tabular}
\end{center}

图 7－27 二次探测法构造的闭散列表\\
在线性探测法构造的闭散列表进行查找，假设闭散列表不会发生上溢，查找算法用伪代码描述如下：

算法：Search\\
输人：闭散列表 $h t[]$ ，待查值 $k$\\
输出：如果查找成功，则返回记录的存储位置，否则返回查找失败的标志 -1\\
1．计算散列地址 $j$ ；\\
2．探测下标 $i$ 初始化：$i=j$ ；\\
3．执行下述操作，直到 ht［i］为空：\\
3.1 若ht［i］等于 $k$ ，则查找成功，返回记录在散列表中的下标；\\
3.2 否则，$i$ 指向下一单元；

4．查找失败，返回失败标志 -1 ；

下面给出闭散列表查找算法的成员函数定义。

\begin{verbatim}
int HashTable1::Search(int k)
{
    int i, j = H(k); //计算散列地址
    i= j; //设惪比较的起始位置
    while (ht [i] != 0)
    f
        if (ht [i] == k) return i; //查找成功
        else i=(i+1)% MaxSize; //向后探测一个位置
    }
    return-1; //查找失败
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-257}
\end{center}

在闭散列表插人一个记录，首先执行查找操作，如果查找成功，由于散列表不存在相同关键码的记录，这个插人被当作一个错误；如果查找失败，则同时确定了该记录在散列表中的存储位置，将该记录存人即可。请读者自行设计闭散列表的插人操作的成员函数。

从闭散列表删除一个记录，有两点需要考虑：（1）删除一个记录一定不能影响以后的查找；（2）删除记录后的存储单元应该能够为将来的插入使用。例如，在图7－26所示线性探测法处理冲突得到的闭散列表中，关键码 11 和 22 的散列地址相同，当删除 11 并把被删除单元清空时，同时也截断了与关键码 11 冲突的探测序列，再查找 22 就找不到了，所以删除不能简单地把被删除单元清空。解决方法是采用濑情删除（lazy deletion），在被删除记录的位置上放一个特殊标记，标志一个记录曾经占用这个单元，但是现在已经不再占用了。如果沿着一个搜索序列查找时遇到一个标记，则查找过程应该继续进行下去。当在插人时遇到一个标记，那个单元就可以用于存储新记录。然而，为了避免插入相同的关键码，查找过程仍然要沿着探测序列查找下去。

\section*{2．拉链法（链地址法）}
用拉链法（chaining）处理冲突构造的散列表叫作开散列表。\\
拉链法的基本思想是：将所有散列地址相同的记录，即所有关键码为同义词的记录存储在一个单链表中——称为同义词子表（synonym table），在散列表中存储的是所有同义词子表的头指针。设 $n$ 个记录存储在长度为 $m$ 的

开散列表中，则同义词子表的平均长度为 $n / m$ 。\\
同义词子表的结点结构可以复用单链表的结点结构，请参见2．4．1节。下面给出开散列表的类定义、构造函数和析构函数定义，其中成员变量实现开散列表的存储结构，成员函数实现插人、删除、查找等动态查找的基本操作。

\begin{verbatim}
const int MaxSize $=100$;
class HashTable2
i
public:
    HashTable2(); //构造函数, 初始化开散列表
    ~HashTable2(); //析构函数, 释放同义词子表结点
    int Insert (int k) ; //插入
    int Delete (int k) ; //删除
    Node<int>* Search (int k) ; //查找
private:
    int H (int k) ; //散列函数
    Node<int> * ht [MaxSize] ; //开散列表
);
HashTable2 : : HashTable2()
I
    for (int i = 0; i < MaxSize; i++)
    \{
        ht [i] = nullptr;
    \}
)
HashTable2 :: ~HashTable2()
\{
    Node<int> * $\mathrm{p}=$ nullptr, ${ }^{*} \mathrm{q}=$ nullptr;
    for (int $i=0$; $i<$ MaxSize; $i++$ )
    1
        $\mathrm{p}=\mathrm{q}=\mathrm{ht}[\mathrm{i}]$;
        while ( $p!=$ nullptr)
        l
            p = p->next;
            delete $q$;
            q = p;
        1
    )
\}
【例 7－6】 设关键码集合 $\{47,7,29,11$ ， $16,92,22,8,3\}$ ，散列表表长为 11 ，散列函数为 $H(k e y)=k e y \bmod 11$ ，用拉链法处理冲突，构造的开散列表如图 7－28 所示。
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-258}
\end{center}

图 7－28 拉链法处理冲突构造的开散列表

查找关键码 $22 、 3 、 92 、 16 、 29$ 和 8 均只需比较 1 次，查找关键码 $11 、 47$ 和 7 需要比较 2次，则平均查找长度 $A S L=(6 \times 1+3 \times 2) / 9=12 / 9$ 。

在用拉链法构造的开散列表中进行查找，需要在同义词子表中进行顺序查找，如果查找成功，返回记录的存储地址，否则返回空指针。下面给出在开散列表进行查找的成员函数定义。

\begin{verbatim}
Node<int> * Hash Table2: :Search (int k)
\end{verbatim}

1\\
int j $=H(k)$;\\
1／计算散列地址\\
Node<int> * $p=h t[j] ; \quad$ //工作指针 $p$ 初始化\\
while (p != nullptr)\\
1\\
if ( $p->$ data $==k$ ) return $p$;\\
else $p=p->$ next;\\
1\\
return nullptr; //查找失败\\
)

在开散列表插人一个记录，需要先执行查找操作。如果查找成功，由于散列表不能存储具有相同关键码的记录，这个值被当作错误；如果查找失败，用头插法在相应同义词子表中插人记录。在开散列表中删除一个记录，只需在相应单链表中查找并删除这个结点。请读者仿照开散列表的查找算法自行设计插人和删除操作的成员函数定义。

\section*{7．4．4 散列查找的性能分析}
在散列技术中，处理冲突的方法不同，得到的散列表不同，散列表的查找性能也不同。有些关键码可以在散列函数计算出的散列地址上直接找到，有些关键码在散列函数计算出的散列地址上产生了冲突，需要按处理冲突的方法进行查找。产生冲突后的查找仍然是给定值与关键码进行\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-259}比较的过程，所以，对散列表查找效率的量度依然采用平均查找长度。

在查找过程中，关键码的比较次数取决于产生冲突的概率。产生的冲突越多，查找效率就越低。影响冲突产生的概率有以下三个因素。\\
（1）散列函数是否均匀。散列函数是否均匀直接影响冲突产生的概率。一般情况下，所选的散列函数应该是尽量均匀的，因此，可以不考虑散列函数对平均查找长度的影响。\\
（2）处理冲突的方法。就线性探测法（例7－8）和拉链法（例7－9）处理冲突来看，相同的关键码集合、相同的散列函数，但处理冲突的方法不同，则它们的平均查找长度不同。容易看出，由于线性探测法处理冲突可能会产生堆积，从而增加了平均查找长度；而拉链法处理冲突不会产生堆积，因为不同散列地址的记录存储在不同的同义词子表中。\\
（3）散列表的装填因子（load factor）。设填入散列表中的记录个数为 $n$ ，散列表的长度为 $m$ ，则装填因子 $\alpha=n / m$ 。装填因子 $\alpha$ 标志着散列表装满的程度。由于表长是定值，$\alpha$与填人表中的记录个数成正比，所以，填人表中的记录越多，$\alpha$ 就越大，产生冲突的可能性

就越大。实际上，散列表的平均查找长度是装填因子 $\alpha$ 的函数 ${ }^{(1)}$ ，只是不同处理冲突的方法有不同的函数。表 7－1 给出了几种不同处理冲突方法的平均查找长度。

表 7－1 几种不同处理冲突方法的平均查找长度

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
平均查找长度处理冲突的方法 & 查找成功时 & 查找不成功时 \\
\hline
线性探测法 & $\frac{1}{2}\left(1+\frac{1}{1-\alpha}\right)$ & $\frac{1}{2}\left(1+\frac{1}{(1-\alpha)^{2}}\right)$ \\
\hline
二次探测法 & $-\frac{1}{\alpha} \ln (1+\alpha)$ & $\frac{1}{1-\alpha}$ \\
\hline
拉链法 & $1+\frac{\alpha}{2}$ & $\alpha+\mathrm{e}^{-\alpha}$ \\
\hline
\end{tabular}
\end{center}

从以上分析可见，散列表的平均查找长度是装填因子 $\alpha$ 的函数，而不是查找集合中记录个数 $n$ 的函数。不管 $n$ 有多大，总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围内，因此，散列查找的时间复杂度为 $O(1)$ 。

\section*{7．4．5 开散列表与闭散列表的比较}
散列技术的原始动机是无须经过关键码与待查值的比较而完成查找，但实际应用中关键码集合常常存在同义词，因此，这个动机并未完全实现。开散列表是用链接方法存储同义词，不产生堆积现象，且使得动态查找的查找、插人和删除等基本操作易于实现，其平均查找长度较短，但由于附加指针域而增加了存储开销。闭散列表无须附加指针，因而存储效率较高。但由此带来的问题是容易产生堆积现象使得查找效率降低，而且由于空闲位置是查找不成功的条件，实现删除操作时不能简单地将待删记录所在单元置空，否则将截断该记录后继散列地址序列的查找路径。因此，算法较复杂一些。

由于开散列表中各同义词子表的表长是动态变化的，无须事先确定表的容量（开散列表由此得名）；而闭散列表必须事先估计容量并分配固定大小的存储空间。因此，开散列表更适合于事先难以估计容量的场合。

\section*{7.5 各种查找方法的比较}
顺序查找和其他查找技术相比，缺点是平均查找长度较大，特别是当查找集合很大时，查找效率较低。然而，顺序查找的优点也很突出：算法简单而且使用面广，它对表中记录的存储没有任何要求，顺序存储和链接存储均可应用；对表中记录的有序性也没有要求，无论记录是否有序均可应用。

相对于顺序查找来说，折半查找的查找性能较好，但是它要求线性表的记录必须有序，并且必须采用顺序存储。顺序查找和折半查找一般只能应用于静态查找。

\footnotetext{（1）为获得空间效率，建议保持 $\alpha>0.5$ ，即散列表至少是半满的，一般上限设为 0.9 。
}下面比较二叉排序树的查找与线性表的查找。折半查找中关键码与给定值的比较次数不超过折半查找判定树的深度，长度为 $n$ 的判定树是唯一的，且深度为 $\left\lfloor\log _{2} n\right\rfloor+1$ 。在二叉排序树中进行查找，关键码与给定值的比较次数也不超过树的深度，但是二叉排序树不唯一，其形态取决于各个记录被插人二叉排序树的先后顺序。如果二叉排序树是平衡的，其查找效率为 $O\left(\log _{2} n\right)$ ，近似于折半查找。如果二叉排序树完全不平衡（最坏情况下为一棵斜树），则其深度可达到 $n$ ，查找效率为 $O(n)$ ，退化为顺序查找。

与上述查找技术不同，散列查找是一种基于计算的查找方法，虽然实际应用中关键码集合常常存在同义词，但在选定合适的散列函数后，仅需进行少量的关键码比较，因此，散列技术的查找性能较高。在很多情况下，散列表的空间都比查找集合大，此时虽然浪费了一定的空间，但换来的是查找效率。

\section*{7.6 扩展与提高}
\section*{7．6．1 顺序查找的改进——分块查找}
分块查找（blocking search）又称索引顺序查找，其查找性能介于折半查找和顺序查找之间。分块查找的使用前提是将线性表进行分块，并使其分块有序。所谓分块有序 （block order）是指将线性表划分为若干块，每一块内不要求有序（即块内无序），但要求第二块中所有记录的关键码均大于第一块中所有记录的关键码，第三块中所有记录的关键码均大于第二块中所有记录的关键码，以此类推（即块间有序）。分块查找还需要建立一个索引表，每块对应一个索引项，各索引项按关键码有序排序，索引项一般包括每块的最大关键码以及指向块首的指针，如图 7－29 所示。

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
块内最大关键码 & 块长 & 块首指针 \\
\hline
\end{tabular}
\end{center}

图 7－29 索引项的结构

分块查找需要分两步进行：第一步在索引表中确定待查关键码所在的块；第二步在相应块中查找待查关键码。由于索引表是按关键码有序排列，可使用顺序查找，也可使用折半查找；在块内进行查找时，由于块内是无序的，只能使用顺序查找。图 7－30 为分块查找示例。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-261}

图 7－30 分块查找示例\\
设将 $n$ 个记录的线性表分为 $m$ 个块，且每个块均有 $t$ 个记录，则 $n=m \times t_{0}$ 。设 $L_{b}$ 为查找索引表确定关键码所在块的平均查找长度，$L_{w}$ 为在块内查找关键码的平均查找长度，

则分块查找的平均查找长度为：


\begin{equation*}
A S L=L_{b}+L_{w} \tag{7-5}
\end{equation*}


若采用顺序查找对索引表进行查找，则分块查找的平均查找长度为：


\begin{equation*}
A S L=L_{b}+L_{w}=\frac{(m+1)}{2}+\frac{(t+1)}{2}=\frac{1}{2}\left(\frac{n}{t}+t\right)+1 \tag{7-6}
\end{equation*}


可见，分块查找的平均查找长度不仅和线性表中记录的个数 $n$ 有关，而且和每一块中的记录个数 $t$ 有关，对于式（7－6），当 $t$ 取 $\sqrt{n}$ 时，ASL 取最小值 $\sqrt{n}+1$ 。

\section*{7．6．2 折半查找的改进——插值查找}
在日常生活中常常遇到这种情况：如果要在字典中查找＂王＂字，很自然地会翻到字典的后面开始查找，很少有人从字典的中间开始查找。为了在开始查找时就根据给定的待查值直接逼近要查找的位置，可以采用插值查找。插值查找（interpolation search）在待查找区间［low，high］中，设待查值为 $k$－通过下式求分割点：


\begin{equation*}
\operatorname{mid}=1 \mathrm{ow}+\frac{k-r[\text { low }]}{r[\text { high }]-r[\text { low }]}(\text { high }- \text { low }) \tag{7-7}
\end{equation*}


其中，low 和 high 分别为查找区间两个端点的下标。将待查值 $k$ 与分割点记录的关键码 $\mathrm{r}[\mathrm{mid}]$ 进行比较，有以下三种情况：\\
（1）$k<r[\mathrm{mid}]$ ，则 $\mathrm{high}=\mathrm{mid}-1$ ，在左半区继续查找；\\
（2）$k>r[\mathrm{mid}]$ ，则 low $=\mathrm{mid}+1$ ，在右半区继续查找；\\
（3）$k=r[\mathrm{mid}]$ ，则查找成功。\\
当查找区间不存在或 mid 的值不再变化时，查找失败。\\
【例 7－7】设待查找序列 $\{10,12,15,20,22,25,28,30,34,36,38,40\}$ 存储在数组 $r[n]$ 中，采用插值查找 $k=20 、 k=36$ 和 $k=32$ ，具体查找过程如下：\\
（1）查找 $k=20$ ，利用插值公式计算分割点 mid $=0+\frac{20-10}{40-10}(11-0)=3.7$ ，取 mid $=$ $\lfloor 3.7\rfloor=3$ ，由于 $r[3]=20$ ，则比较一次查找成功。\\
（2）查找 $k=36$ ，利用插值公式计算分割点 mid $=0+\frac{36-10}{40-10}(11-0)=9.5$ ，取 mid $=$ $\lfloor 9.5\rfloor=9$ ，由于 $r[9]=36$ ，则比较一次查找成功。\\
（3）查找 $k=32$ ，利用插值公式计算分割点 $\operatorname{mid}=0+\frac{32-10}{40-10}(11-1)=8.1$ ，取 $\operatorname{mid}=$ $\lfloor 8.1\rfloor=8$ ，由于 $r[8]=34>32$ ，令 $\mathrm{high}=\mathrm{mid}-1=7$ ，再利用插值公式计算分割点 $\mathrm{mid}=$ $0+\frac{32-10}{30-10}(7-1)=7.7$ ，取 $\operatorname{mid}=\lfloor 7.7\rfloor=7$ ，由于 $r[7]=30<32$ ，令 low $=\operatorname{mid}+1=8$ ，由于 low＞high，则经过两次比较查找失败。

插值查找的时间性能在关键码分布比较均匀（例如线性均匀增长）的情况下，优于折半查找。一般地，设待查序列有 $n$ 个记录，插值查找的关键码比较次数要小于 $\log _{2} \log _{2} n+1$次，这个函数的增长速度很慢，对于所有可能的实际输人，关键码比较的次数很小，但最坏情况下，插值查找将达到 $O(n)$ 。对于较小的查找表，折半查找比较好，对于很大的查找

表，插值查找会更好些。

\section*{7．6．3 B 树的改进—— $\mathrm{B}^{+}$树}
在基于磁盘的大型系统中，广泛使用的是 B 树的一个变体，称为 $\mathbf{B}^{+}$树（ $\mathrm{B}^{+}$tree）。\\
一棵 $m$ 阶的 $\mathrm{B}^{+}$树在结构上与 $m$ 阶的 B 树相同，结点内的关键码仍然有序排列，并且对同一结点内的任意两个关键码 $K_{i}$ 和 $K_{j}$ ，若 $K_{i}<K_{j}$ ，则 $K_{i}$ 小于 $K_{j}$ 对应子树中的所有关键码，但在关键码的内部安排上有所不同。具体如下：\\
（1）具有 $m$ 棵子树的结点含有 $m$ 个关键码，即每一个关键码对应一棵子树；\\
（2）关键码 $K_{i}$ 是它所对应子树的根结点中的最大（或最小）关键码；\\
（3）所有叶子结点包含了全部关键码信息，以及指向对应记录的指针；\\
（4）所有叶子结点按关键码的大小顺次链在一起，形成单链表，并设置头指针。\\
$\mathrm{B}^{+}$树只在叶子结点存储记录，分支结点存储关键码，但是这些关键码只是用于引导查找的，这意味着分支结点在结构上与叶子结点有显著的区别。分支结点存储关键码用于引导查找，每个关键码与一个指向孩子结点的指针相关联；叶子结点存储关键码和指向对应记录的指针。

例如，图 7－31 所示为一棵 3 阶的 $\mathrm{B}^{+}$树，通常在 $\mathrm{B}^{+}$树上有两个头指针，一个指向根结点，另一个指向关键码最小的叶子结点。因此，可以对 $\mathrm{B}^{+}$树进行两种查找操作：一种是从最小关键码开始进行顺序查找，另一种是从根结点开始进行 $\mathrm{B}^{+}$树查找。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-263}

图 7－31 一棵 3 阶 $\mathrm{B}^{+}$树\\
由于 $\mathrm{B}^{+}$树的分支结点只是用来引导索引的，并不提供对实际记录的访问，所以在 $\mathrm{B}^{+}$树中从根结点出发进行查找，即使在一个分支结点找到了待查关键码，也必须到达包含该关键码的叶子结点。\\
$\mathrm{B}^{+}$树的插人仅在叶子结点上进行，当结点中的关键码个数大于 $m$ 时要分裂成两个结点，并且它们的双亲结点中应同时包含这两个结点中的最大关键码。 $\mathrm{B}^{+}$树的删除也仅在叶子结点上进行，若因删除而使结点中关键码的个数少于 $\left\lceil\frac{m}{2}\right\rceil$ ，向兄弟结点借关键码以及与兄弟结点的合并过程和 $B$ 树类似。\\
$\mathrm{B}^{+}$树特别适合范围查找。一旦找到了范围中的第一个记录，通过顺序处理结点中的其余记录，就可以找到范围中的全部记录。

\section*{思想火花——把注意力集中于主要因素，不要纠缠于噪声}
假定在城市 A 和城市 B 之间修一条路，但两城市之间被一条河隔开，如图7－32所示，希望这两个城市之间的道路总长度最小，当然，桥必须与两河岸垂直。把桥修在哪儿可以使道路的总长度最小呢？\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-264}

图 7－32 问题描述及解答示意图\\
有很多求解这个问题的方法都涉及大量计算，如果将注意力集中在数据模型的重要部分而忽略一些噪声（干扰达到目标的因素），事情就变得简单多了。假设根本就没有河，河被简化为一条直线，将城市 B 垂直上移原来河宽的距离，现在问题变得极易求解：A 和 $B^{\prime}$ 间的直线段就给出了问题的答案！这个解实际上隐含着原始问题的解。

假设 $A$ 和 $B^{\prime}$ 之间的连线与河岸的交点为 $P$ ，这是桥的起始端，桥的另一端为 $Q$ ，则总距离 $A P+P Q+Q B$ 为满足条件的最短路径。因为：

$$
A P^{\prime}+P^{\prime} Q^{\prime}+Q^{\prime} B=A P^{\prime}+P^{\prime} Q^{\prime}+P^{\prime} B^{\prime}>A B^{\prime}+P^{\prime} Q^{\prime}=A P+P Q+P B^{\prime}=A P+P Q+Q B
$$

面临问题时，首先要问的是：目标是什么？如果目标不明确，那么达到目标的希望就非常秒茫，即使达到了目标，甚至可能还不知道已经完成。因此，无论何时求解问题，都要盯住目标，否则，很容易在求解过程中将注意力分散或转移到其他相对次要的方面。

\section*{习 题 7}
\section*{1．选择题}
（1）静态查找与动态查找的根本区别在于（ ）。\\
A．它们的逻辑结构不一样\\
B．施加在其上的操作不同\\
C．所包含的数据元素的类型不一样\\
D．存储实现不一样\\
（2）长度为 12 的有序表采用顺序存储结构，采用折半查找技术，在等概率情况下，查找成功时的平均查找长度是（ ），查找失败时的平均查找长度是（ ）。\\
A． $37 / 12$\\
B． $62 / 13$\\
C． $39 / 12$\\
D． $49 / 13$\\
（3）分块查找的平均查找长度和（ ）有关。\\
A．线性表的记录个数\\
B．每一块中的记录个数\\
C．线性表是否有序\\
D．A 和 B\\
（4）用 $n$ 个键值构造一棵二叉排序树，其最低高度为（ 一 ）。\\
A．$n / 2$\\
B．$n$\\
C．$\left\lfloor\log _{2} n\right\rfloor$\\
D．$\left\lfloor\log _{2} n+1\right\rfloor$\\
（5）二叉排序树中，最小值结点的（ ）。\\
A．左指针一定为空\\
B．右指针一定为空\\
C．左、右指针均为空\\
D．左、右指针均不为空\\
（6）在二叉排序树上查找关键码为 28 的结点（假设存在），则依次比较的关键码有可能是（ ）。\\
A． $30,36,28$\\
B． $38,48,28$\\
C． $48,18,38,28$\\
D． $60,30,50,40,38,36$\\
（7）在平衡二叉树中插人一个结点后造成了不平衡，设最低的不平衡结点为 A ，并已知 A 的左孩子的平衡因子为 0 ，右孩子的平衡因子为 1 ，则应作（ ）型调整以使其平衡。\\
A．LL\\
B．$L R$\\
C．RL\\
D．$R R$\\
（8）按 $\{12,24,36,90,52,30\}$ 的顺序构成的平衡二叉树，其根结点是（）。\\
A． 24\\
B． 36\\
C． 52\\
D． 30\\
（9）下面关于 $m$ 阶 B 树说法正确的是（）。\\
（1）每个结点至少有两棵非空子树\\
（2）树中每个结点至多有 $m-1$ 个关键码\\
（3）所有叶子在同一层上\\
（4）当插人一个数据引起 B 树结点分裂后，树长高一层\\
A．（1）（2）（3）\\
B．（2）（3）\\
C．（2）（3）（4）\\
D．（3）\\
（10）在一棵 $m$ 阶 B 树中执行插人操作，若一个结点中的关键码个数等于（ ），则必须分裂为两个结点。\\
A．$m$\\
B．$m-1$\\
C．$m+1$\\
D．$m / 2$\\
（11）在一棵 $m$ 阶 B 树删除一个关键码时引起结点合并，则该结点原有（）个关键码。\\
A． 1\\
B．$\left\lceil\frac{m}{2}\right\rceil$\\
C．$\left[\frac{m}{2}\right]-1$\\
D．$\left[\frac{m}{2}\right]+1$\\
（12）散列技术中的冲突指的是（）。\\
A．两个元素具有相同的序号\\
B．两个元素的键值不同，而其他属性相同\\
C．数据元素过多\\
D．不同键值的元素对应于相同的存储地址\\
（13）设散列表表长 $m=14$ ，散列函数 $H(k)=k \bmod 11$ 。表中已有 $15 、 38 、 61 、 84$ 四个元素，如果用线性探测法处理冲突，则元素 49 的存储地址是（ ）。\\
A． 8\\
B． 3\\
C． 5\\
D． 9\\
（14）在采用线性探测法处理冲突所构成的闭散列表上进行查找，可能要探测多个位置，在查找成功的情况下，所探测的这些位置的键值（）。\\
A．一定都是同义词\\
B．一定都不是同义词\\
C．不一定都是同义词\\
D．都相同\\
（15）采用开放定址法解决冲突的散列查找中，发生聚集的原因主要是（）。\\
A．数据元素过多\\
B．装填因子过大\\
C．散列函数选择不当\\
D．解决冲突的算法不好

\section*{2．解答下列问题}
（1）分别画出在线性表 $(a, b, c, d, e, f, g)$ 中进行折半查找关键码 $e$ 和 $g$ 的过程。\\
（2）画出长度为 10 的折半查找判定树，并求等概率时查找成功和不成功的平均查找长度。\\
（3）将数列 $(24,15,38,27,76,130,121)$ 的各元素依次插入一棵初始为空的二叉排序树中，请画出最后的结果并求等概率情况下查找成功的平均查找长度。\\
（4）一棵二叉排序树的结构如图7－33所示，结点的值为 $1 \sim 8$ ，请标出各结点的值。\\
（5）已知一棵二叉排序树如图 7－34 所示，分别画出删除元素 90 和 47 后的二叉排序树。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-266(1)}\\
（6）已知散列函数 $H(k)=k \bmod 12$ ，关键码集合 $\{25,37,52,43,84,99,120,15$ ， $26,11,70,82\}$ ，分别采用线性探测法和拉链法处理冲突，试构造散列表，并计算查找成功的平均查找长度。\\
（7）给定关键码集合 $\{26,25,20,34,28,24,45,64,42\}$ ，设定装填因子为 0.6 ，请给出除留余数法的散列函数，画出采用线性探测法处理冲突构造的散列表。\\
（8）对图7－35所示 3 阶 B 树，分别给出插人关键码为 $2,12,16,17$ 和 18 之后的结果。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-266}

图 7－35 3阶B树\\
（9）对图7－35所示 3 阶 B 树，分别给出删除关键码为 4，8，9 之后的结果。

\section*{3．算法设计}
（1）设计顺序查找算法，将哨兵设在下标高端。\\
（2）编写算法求给定结点在二叉排序树中所在的层数。\\
（3）编写算法，在二叉排序树上找出任意两个不同结点的最近公共祖先。\\
（4）设计算法判定一棵二叉树是否为二叉排序树。\\
（5）设二叉树结点结构为（lchild，data，rchild，bf），其中 bf 是该结点的平衡因子，编写算法确定二叉树中各结点的平衡因子。\\
（6）在用线性探测解决冲突的散列表中，设计算法实现闭散列表的懒惰删除操作。

\section*{实 验 题 7}
【实验 1】二叉排序树的实现。请将 7．3．1 节二叉排序树上机实现，并用不同的查找集合实例进行测试。

【实验 2】找词游戏。在美国流行一种找词游戏，要求游戏者从一张填满字符的正方形表中，找出所有的英文单词，这些单词可以横着读、坚着读或者斜着读。例如，图 7－36 所示正方形表中，可以找出单词 this、two、fat 和 that 等。请完成这个找词游戏并上机实现。

【实验 3】MD5 加密算法。20 世纪90 年代，Ronald L．Rivest发明了文档信息摘要加密 MD5 算法（message－digest algorithm 5），

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
t & h & i & s \\
\hline
w & h & t & s \\
\hline
o & a & a & g \\
\hline
f & g & d & t \\
\hline
\end{tabular}
\end{center}

图 7－36 正方形表广泛应用在加密和解密领域。例如 UNIX 系统中用户的密码就是用 MD5 算法加密后存储在文件系统中。请查阅有关 MD5 的相关文献和算法并上机实现。

\section*{8．${ }_{\text {李 }}$}
\section*{排 序 技 术}
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
本章概述 & \multicolumn{5}{|c|}{\begin{tabular}{l}
排序是数据处理领域经常使用的一种操作，其主要目的是便于查找。在日常生活中，通过排序提高查找性能的例子屢见不鲜，例如，电话号码簿、书的目录、字典等。排序性能与数据集合的各种特性相关，例如随机排列、基本有序、数据规模特别大等，为此人们研究了各种排序技术。从算法设计角度看，排序算法体现了算法设计的某些重要方法和技巧；从算法分析角度看，对排序算法时间性能的分析应用了某些重要的算法分析技术；有关程序设计的岗位招聘也大量出现有关排序的内容，因此，认真学习和掌握排序算法是非常重要的。 \\
本章介绍插人排序、交换排序、选择排序、归并排序等四类基于比较的内排序技术，每类排序技术分别介绍一个最简单的排序算法和一个改进的排序算法，请读者仔细体会并掌握排序算法的设计过程以及改进算法的基本方法。 \\
\end{tabular}} \\
\hline
教学重点 & \multicolumn{5}{|c|}{各种排序算法的基本思想；各种排序算法的执行过程；各种排序算法及时间复杂度分析；各种排序算法之间的比较} \\
\hline
教学难点 & \multicolumn{5}{|l|}{快速排序、堆排序、归并排序等算法及时间复杂度分析} \\
\hline
\multirow{2}{*}{} & \multirow{2}{*}{知 识 点} & \multicolumn{4}{|c|}{教 学 要 求} \\
\hline
 &  & 了解 & 理解 & 掌握 & 熟练掌握 \\
\hline
\multirow{2}{*}{} & 排序的基本概念 &  & $\checkmark$ &  &  \\
\hline
 & 排序算法的性能 & －901\textbackslash ％ &  & $\checkmark$ &  \\
\hline
\multirow{2}{*}{} & 直接插人排序 &  &  &  & $\checkmark$ \\
\hline
 & 希尔排序 &  & $\checkmark$ &  &  \\
\hline
\multirow[t]{9}{*}{\begin{tabular}{l}
教学内容 \\
和 \\
教学目标 \\
\end{tabular}} & 起泡排序 &  &  &  & $\checkmark$ \\
\hline
 & 快速排序 &  &  & $\checkmark$ &  \\
\hline
 & 快速排序的一次划分算法 &  &  &  & $\checkmark$ \\
\hline
 & 简单选择排序 &  &  &  & $\checkmark$ \\
\hline
 & 堆排序 &  &  & $\checkmark$ &  \\
\hline
 & 箵选法调整堆算法 &  & $\checkmark$ &  &  \\
\hline
 & 二路归并排序的非递归实现 &  &  & $\checkmark$ &  \\
\hline
 & 二路归并排序的递归实现 &  &  & $\checkmark$ &  \\
\hline
 & 各种排序方法的比较 &  &  &  & $\checkmark$ \\
\hline
\end{tabular}
\end{center}

\section*{8.1 概 述}
\section*{8．1．1 排序的基本概念}
在排序问题中，通常将数据元素称为记录 ${ }^{(1)}$（record）。\\
（1）排序\\
给定一个记录序列（ $r_{1}, r_{2}, \cdots, r_{n}$ ），其相应的关键码分别为（ $k_{1}, k_{2}$ ， $\left.\cdots, k_{n}\right)$ ，排序（sort）是将这些记录排列成顺序为（ $r_{s 1}, r_{s 2}, \cdots, r_{s n}$ ）的序\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-269}列，使得相应的关键码满足 $k_{s 1} \leqslant k_{s 2} \leqslant \cdots \leqslant k_{s n}$（升序或非降序）或 $k_{s 1} \geqslant k_{s 2}$ $\geqslant \cdots \geqslant k_{s n}$（降序或非升序）。简言之，排序是将一个记录的任意序列重新排列成一个按关键码 ${ }^{(2)}$ 有序的序列。\\
（2）排序算法的分类\\
根据在排序过程中待排序的所有记录是否全部被放置在内存中，可将排序方法分为内排序和外排序。内排序是指在排序的整个过程中，待排序的所有记录全部被放置在内存中；外排序是指由于待排序的记录个数太多，不能同时放置在内存，需要将一部分记录放置在内存，另一部分记录放置在外存，整个排序过程需要在内外存之间多次交换数据才能得到排序的结果。

根据排序方法是否建立在关键码比较的基础上，可以将排序方法分为基于比较的排序和不基于比较的排序。基于比较的排序方法主要通过关键码之间的比较和记录的移动这两种基本操作来实现，大致可分为插人排序、交换排序、选择排序、归并排序四类；不基于比较的排序方法是根据待排序数据的特点所采取的其他方法，通常没有大量的关键码之间的比较和记录的移动操作。\\
（3）排序算法的稳定性\\
假定在待排序的记录序列中，存在多个具有相同关键码的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，$k_{i}=k_{i}$ 且 $r_{i}$ 在 $r_{j}$ 之前，在排序后的序列中，$r_{i}$ 仍在 $r_{j}$ 之前，则称这种排序算法稳定（stable）；否则称为不稳定（unstable）。

稳定性描述了具有相同关键码记录的排序效果。对于不稳定的排序算法，举出一个实例即可说明其不稳定性；对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要强调的是，排序算法的稳定性由具体算法决定，稳定的算法在某种条件下可能变为不稳定的算法。\\
（4）正序、逆序\\
若待排序记录序列已排好序，称此记录序列为正序（exact order）；若待排序记录的排列顺序与排好序的顺序正好相反，称此记录序列为逆序（inverse order）或反序（anti－order）。

\footnotetext{（1）在计算机发展的早期，由于内存的限制，排序操作常常需要借助外存才能实现，因此，数据元素沿用文件的叫法，称为记录。\\
（2）此处关键码是排序的依据，也称排序码。排序码不一定是关键码，选取哪一个数据项作为排序码应根据具体情况而定。如果排序码不是关键码，就可能有多个记录具有相同的排序码，因此，排序结果可能不唯一。简单起见，很多教材将关键码作为排序码。
}
（5）趙\\
在排序过程中，将待排序的记录序列扫描一遍称为一趟（pass）。在排序操作中，深刻理解趟的含义能够更好地掌握排序方法的思想和过程。

\section*{8．1．2 排序算法的性能}
排序是数据处理领域经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的重要标准。对于基于比较的内排序，算法的执行时间主要消耗在以下两种基本操作：（1）比较，关键码之间的比较；（2）移动，记录从一个位置移动到另一个位置。因此，高效率的排序算法应该具有尽可能少的关键码比较次数和尽可能少的记录移动次数。由于排序算法的时间性能常常与数据集合的初始排列密切相关，例如随机排列、基本有序、正序逆序等，因此需要分析最好情况、最坏情况和平均情况的时间复杂度。

评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是指除了存放待排序记录占用的存储空间之外，算法在执行过程中所需要的其他存储空间。另外，算法本身的复杂程度也是一个要考虑的因素。

\section*{8．1．3 排序类的定义}
从操作角度看，排序是对线性结构的一种操作，待排序记录可以用顺序存储结构或链接存储结构存储。不失一般性，为突出排序方法的主题，本章讨论的排序算法均采用顺序存储结构，并假定关键码为整型，且记录只有关键码一个数据项，即采用一维整型数组实现。另外，假定排序是将待排序的记录序列排列为升序序列。

本章介绍基于比较的内排序技术，包括直接插人排序、希尔排序、起泡排序、快速排序、简单选择排序、堆排序、二路归并排序等，下面给出排序类的定义以及构造函数、析构函数和输出序列的函数定义，在接下来的章节中具体讨论每种排序技术的实现。

\begin{verbatim}
class Sort
I
public:
    Sort (int r [], int n); //构造函数, 生成待排序序列
    ~Sort () ; 1/析构函数
    void InsertSort () ; //直接描人排序
    void Shel1Sort () ; 1/希尔排序
    vaid BubbleSort () ; //起泡排序
    void QuickSort (int first, int last) ; //快速排序
    void SelectSort () ; //简单选择排序
    void HeapSort(): //堆排序
    void MergeSort1 (int first, int last); //二路归并递归排序
    void MergeSort2():
    void Print (): //输出序列
private:
    int Partition (int first, int last); //快速排序, 一次划分
\end{verbatim}

\begin{center}
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-270}
\end{center}

\begin{verbatim}
    void Sift (int k, int last); //堆排序,堆调整
    void Merge(int first1, int last1, int last2); //1月并排序,合并相邻有序序列
    void MergePass (int h); //归并排序,一䞥归并
    int * data; //待排序序列
    int length;
};
Sort :: Sort(int r[], int n)
f
    data = new int [n];
    for (int i = 0; i < n; i++)
        data[i] = r[i];
    length = n;
}
Sort : : ~ Sort ()
{
    delete[ ] data;
)
void Sort :: Print()
{
    for (int i = 0; i < length; i++)
        cout <<data[i] <<"\t";
    cout <<endl;
}
\end{verbatim}

\section*{8.2 插入 排 序}
插人排序的主要思想是：每趟排序将一个待排序的记录按其关键码的大小插人到已经排好序的有序序列中，直到全部记录排好序。

\section*{8．2．1 直接插入排序}
直接插入排序（straight insertion sort）是插入排序中最简单的排序方法，类似于玩纸牌时整理手中纸牌的过程，其基本思想是：依次将待排序序列中的每一个记录插人到已排好序的序列中，直到全部记录都排好\\
\includegraphics[max width=\textwidth]{2025_06_06_704745ea57b15b2333e5g-271(1)}序，如图 8－1 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-271}

图 8－1 直接插人排序的基本思想\\
由直接插人排序的基本思想，提出直接插入排序需解决的关键问题：\\
（1）如何构造初始的有序序列？\\
（2）如何查找待插人记录的插人位置？\\
【例 8－1】对于记录序列 $\{12,30,25,9,18\}$ ，直接插人排序的执行过程如图 8－2 所示，具体的排序过程如下：\\
（1）将整个待排序的记录序列划分成有序区和无序区，初始时有序区为待排序记录序列的第一个记录，无序区包括所有剩余待排序的记录；\\
（2）将无序区的第一个记录插人到有序区的合适位置中，从而使无序区减少一个记录，有序区增加一个记录；\\
（3）重复执行步骤（2），直到无序区没有记录为止。

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
待排序记录序列 & 12 & 30 & 25 & 9 & 18 \\
\hline
初始有序区 & 12 & 30 & 25 & 9 & 18 \\
\hline
第1趟排序结果 & 12 & 30 & 25 & 9 & 18 \\
\hline
第2趟排序结果 & 12 & 25 & 30 & 9 & 18 \\
\hline
第3趟排序结果 & 9 & 12 & 25 & 30 & 18 \\
\hline
第4趙排序结果 & 9 & 12 & 18 & 25 & 30 \\
\hline
\end{tabular}
\end{center}

图 8－2 直接插人排序过程示例\\
从以上排序过程，可得到解决上述关键问题的方法。\\
问题（1）的解决：将第一个记录 data［0］看成是初始有序区，然后从第二个记录起依次插人到有序区中，直至将最后一个记录插人完毕。

问题（2）的解决：一般情况下，在有序区 data $[0] \sim \operatorname{data}[\mathrm{i}-1]$ 中插人记录 data $[\mathrm{i}]$ 时，首先要查找 data［i］的正确插入位置。最简单地，可以采用顺序查找。设下标 $j$ 从 $i-1$ 起往前查找插人位置，同时后移记录，为了向后移动记录时避免覆盖待插人记录 $\mathrm{data}[\mathrm{i}]$ ，将 data［i］用变量 temp 暂存，则循环条件应该是 temp $<$ data $[\mathrm{j}]$ 。退出循环，说明找到了插人位置，因为 data［j］刚刚比较完毕，所以，$j+1$ 为正确的插人位置，将变量 temp 暂存的记录存储到 data $[\mathrm{j}+1]$ 中。

下面给出直接插人排序的成员函数定义。

\begin{verbatim}
void Sort :: InsertSort()
f
    int i, j, temp;
    for (i = 1; i < length; if + ) //排序进行 length - 1 趟
    {
        temp = data [i]; //暂存待插记录
        for (j=i-1;j>=0&&temp<data[j]; j--) //寻找插入位置
            data [j+1] = data [j];
        data [j+1]= temp;
    )
)
\end{verbatim}

直接插人排序算法由两层嵌套的循环组成，外层循环要执行 $n-1$ 次，内层循环的执行次数取决于在第 $i$ 个记录前有多少个记录大于第 $i$ 个记录。最好情况下，待排序序列为正序，每趟只需与有序序列的最后一个记录比较一次，移动两次记录，则比较次数为 $n$ -1 ，记录的移动次数为 $2(n-1)$ ，因此，时间复杂度为 $O(n)$ ；最坏情况下，待排序序列为逆序，第 $i$ 个记录必须与前面 $i-1$ 个记录进行比较，并且每比较一次就要执行一次记录的移动，则比较次数为 $\sum_{i=2}^{n}(i-1)=\frac{n(n-1)}{2}$ ，记录的移动次数为 $\sum_{i=2}^{n}(i+1)=$ $\frac{(n+4)(n-1)}{2}$ ，因此，时间复杂度为 $O\left(n^{2}\right)$ ；平均情况下，待排序序列中各种可能排列的概率相同，在插人第 $i$ 个记录时平均需要比较有序区中全部记录的一半，所以比较次数为 $\sum_{i=2}^{n} \frac{i-1}{2}=\frac{n(n-1)}{4}$ ，移动次数为 $\sum_{i=2}^{n} \frac{i+1}{2}=\frac{(n+4)(n-1)}{4}$ ，时间复杂度为 $O\left(n^{2}\right)$ 。

直接插人排序只需要一个记录的辅助空间，用来作为待插人记录的暂存单元。直接插人排序是一种稳定的排序方法。

\section*{8．2．2 希尔排序}
希尔排序 ${ }^{(1)}$（Shell sort）是对直接插人排序的一种改进，改进的着眼点是：（1）若待排序记录基本有序 ${ }^{(2)}$ ，直接插人排序的效率很高；（2）由于直接插人排序算法简单，则在待排序记录个数较少时效率也很高。

希尔排序的基本思想是：先将整个待排序记录序列分割成若干个子序列，在子序列内分别进行直接插人排序，待整个序列基本有序时，再对全体记录进行一次直接插人排序。在希尔排序中，需解决的关键问题是：\\
（1）如何分割待排序记录，才能保证整个序列逐步向基本有序发展？\\
（2）子序列内如何进行直接插入排序？\\
【例 8－2】对于记录序列 $\{59,20,17,36,98,14,23,83,13,28\}$ ，希尔排序的执行过程如图 8－3 所示，具体的排序过程是：假设待排序的记录为 $n$ 个，先取整数 $d<n$ ，例如，取 $d=n / 2$ ，将所有相距为 $d$ 的记录构成一组，从而将整个待排序记录序列分割成 $d$ 个子序列，对每个子序列分别进行直接插人排序；然后再缩小间隔 $d$ ，例如，取 $d=d / 2$ ，重复上述分割；再对每个子序列分别进行直接插人排序，直到 $d=1$ ，即将所有记录放在一组进行直接插人排序。

从以上排序过程，可得到解决上述关键问题的方法：\\
问题（1）的解决：子序列的构成不能是简单地＂逐段分割＂，而是将相距某个增量的记录组成一个子序列，才能有效地保证在子序列内分别进行直接插人排序后得到的结果是基本有序而不是局部有序。接下来的问题是增量应如何取？到目前为止尚未有人求得一

\footnotetext{（1）希尔（Donald Shell，1924 年出生）美国计算机科学家，1959 年获辛辛那提大学数学博士学位，同年发明了希尔排序，是平均时间性能好于 $O\left(n^{2}\right)$ 的第一批算法之一。\\
（2）基本有序和局部有序（即部分有序）不同。基本有序是指已接近正序，例如 $\{1,2,8,4,5,6,7,3,9\}$ ；局部有序只是某些部分有序，例如 $\{6,7,8,9,1,2,3,4,5\}$ ，局部有序不能提高直接插人排序算法的时间性能。
}\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}
\hline
待排序记录序列 & 59 & 20 & 17 & 36 & 98 & 14 & 23 & 83 & 13 & 28 \\
\hline
$\mathrm{d}=5$ 分割子序列 & 59 & 20 & 17 & 36 & 98 & 14 & 23 & 83 & 13 & 28 \\
\hline
第一趟排序结果 & 14 & 20 & 17 & 13 & 28 & 59 & 23 & 83 & 36 & 98 \\
\hline
$\mathrm{d}=2$ 分割子序列 & 14 & 20 & 17 & 13 & 28 & 59 & 23 & 83 & 36 & 98 \\
\hline
第二䖯排序结果 & 14 & 13 & 17 & 20 & 23 & 59 & 28 & 83 & 36 & 98 \\
\hline
第三趟排序结果（ $\mathrm{d}=1$ ） & 13 & 14 & 17 & 20 & 23 & 28 & 36 & 59 & 83 & 98 \\
\hline
\end{tabular}
\end{center}

图 8－3 希尔排序过程示例\\
个最好的增量序列。希尔最早提出的方法是 $d_{1}=n / 2, d_{i+1}=d_{i} / 2$ ，且增量序列互质，显然最后一个增量必须等于 1 。开始时增量的取值较大，每个子序列中的记录个数较少，这提供了记录跳跃移动的可能，排序效率较高；后来增量逐步缩小，每个子序列中的记录个数增加，但已基本有序，效率也较高。

问题（2）的解决：在每个子序列中，待插人记录和同一子序列中的前一个记录比较，在插人记录 data［i］时，自 data $[\mathrm{i}-\mathrm{d}]$ 起以幅度 $d$ 往前跳跃式查找待插人位置，在查找过程中，记录后移也是跳跃 $d$ 个位置，为了后移动记录时避免覆盖待插入记录 data［i］，将 data［i］用变量 temp 暂存，当搜索位置 $\mathrm{j}<0$ 或者 $t e m p \geqslant d a t a[\mathrm{j}]$ ，表示插人位置已找到，退出循环。因为 $\operatorname{data}[j]$ 刚刚比较完毕，所以，$j+d$ 为正确的插人位置，将待插人记录插人。

在整个序列中，记录 $\operatorname{data}[0] \sim \operatorname{data}[\mathrm{d}-1]$ 分别是 $d$ 个子序列的第一个记录，所以从记录 data［d］开始进行插人。下面给出希尔排序的成员函数定义。

\begin{verbatim}
void Sort :: ShellSort()
i
    int d, i, j, temp;
    for (d = length/2; d >= 1; d = d/2) //增量为 d 进行直接插人排序
    l
        for (i = d; i<length; i++) 7/进行一趟希尔排序
        {
            temp = data[i]; //暂存待插人记录
            for (j=i-d; j>=0 && temp< data [j];j=j-d)
                data[j+d] = data[j]; //记录后移 d 个位置
            data [j+d] = temp;
        }
    }
}
\end{verbatim}

希尔排序的时间性能在 $O\left(n \log _{2} n\right)$ 和 $O\left(n^{2}\right)$ 之间，如果选定合适的增量序列，希尔排序的时间性能可以达到 $O\left(n^{1.3}\right)$ 。希尔排序只需要一个记录的辅助空间，用于暂存当前待

插入的记录。由于在希尔排序过程中记录是跳跃移动的，因此，希尔排序是不稳定的。

\section*{8.3 交 换 排 序}
交换排序的主要思想是：在待排序序列中选取两个记录，如果这两个记录反序，则交换它们的位置。对于记录 $r_{i}$ 和 $r_{j}$ ，若满足 $i<j$ 且 $r_{i}>r_{j}$ ，则称 $\left(r_{i}, r_{j}\right)$ 是反序对。交换可以消除反序对，当所有反序对都被消除后，排序也就完成了。

\section*{8．3．1 起泡排序}
起泡排序（bubble sort）是交换排序中最简单的排序方法，其基本思想是：两两比较相邻记录，如果反序则交换，直到没有反序的记录为止，如图8－4所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-275}

图 8－4 起泡排序的基本思想\\
【例 8－3】对于记录序列 $\{50,13,55,97,27,38,49,65\}$ ，起泡排序的执行过程如图 8－5 所示，具体的排序过程如下：\\
（1）将整个待排序的记录序列划分成有序区和无序区，初始时有序区为空，无序区包括所有待排序的记录。\\
（2）对无序区从前向后依次将相邻记录进行比较，若反序则交换，从而使得值较小的记录向前移，值较大的记录向后移（像水中的气泡，体积大的先浮上来，起泡排序因此得名）。\\
（3）重复执行步骤（2），直到无序区没有反序的记录。

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
\hline
待排序记录序列 & 50 & 13 & 55 & 97 & 27 & 38 & 49 & 65 \\
\hline
第1趟排序结果 & 13 & 50 & 55 & 27 & 38 & 49 & 65 & 97 \\
\hline
第2趟排序结果 & 13 & 50 & 27 & 38 & 49 & 55 & 65 & 97 \\
\hline
第3趟排序结果 & 13 & 27 & 38 & 49 & 50 & 55 & 65 & 97 \\
\hline
第4越排序结果 & 13 & 27 & 38 & 49 & 50 & 55 & 65 & 97 \\
\hline
\end{tabular}
\end{center}

图 8－5 起泡排序过程示例\\
由以上排序过程，提出并解决如下关键问题。\\
（1）在一趟起泡排序中，若有多个记录位于最终位置，应如何记载？\\
如果在某趟起泡排序后有多个记录位于最终位置（例如在图8－5中第2趟排序结果），那么在下一趟起泡排序中这些记录应该避免重复比较，为此，设变量 exchange 记载

每次记录交换的位置，则一趟排序后，exchange 记载的一定是这趟排序最后一次交换记录的位置，从此位置之后的所有记录均已经有序。\\
（2）如何确定一趟起泡排序的范围，使得已经位于最终位置的记录不参与下一趟排序？

设 bound 位置的记录是无序区的最后一个记录，则每趟起泡排序的范围是［0～ bound］。在一趟排序后，exchange 位置之后的记录一定是有序的，所以下一趟起泡排序中无序区的最后一个记录的位置是 exchange，即 bound＝exchange。\\
（3）如何判别起泡排序的结束？\\
判别起泡排序的结束条件应是在一趟排序过程中没有进行交换记录的操作。为此，在每趟起泡排序开始之前，设 exchange 的初值为 0 ，在一趟比较完毕，若 exchange 的值为 0 ，或者该趟没有交换记录，或者只是交换了 data［0］和 data［1］，因此，可以通过 exchange的值是否为 0 来判别整个起泡排序是否结束。\\
（4）在进人循环之前，exchange 的初值应如何设置呢？\\
第一趟起泡排序的范围是 $[0 \sim$ length -1$]$ ，所以，exchange 的初值应该为 length -1 。下面给出起泡排序的成员函数定义。

\begin{verbatim}
void Sort :: BubbleSort()
l
    int j, exchange, bound, temp;
    exchange = length-1; //第一趟起泡排序的区间是 [0~length-1]
    while (exchange != 0)
    \
        bound = exchange; exchange = 0;
        for (j= 0; j<bound; j++) // 一趟起泡排序的区间是[0~bound]
            if (data[j] > data[j+1]) {
                temp = data[j]; data[j] = data[j+1]; data[j+1] = temp;
                exchange = j; //记载每一次记录交换的位置
            )
    }
)
\end{verbatim}

起泡排序的执行时间取决于排序的趟数。最好情况下，待排序记录序列为正序，算法只执行一趟，进行了 $n-1$ 次比较，不需要移动记录，时间复杂度为 $O(n)$ ；最坏情况下，待排序记录序列为反序，每趟排序在无序序列中只有一个最大的记录被交换到最终位置，故算法执行 $n-1$ 趟，第 $i(1 \leqslant i<n)$ 趟排序执行了 $n-i$ 次比较和 $n-i$ 次交换，则记录的比较次数为 $\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}$ ，记录的移动次数为 $3 \sum_{i=1}^{n-1}(n-i)=\frac{3 n(n-1)}{2}$ ，因此，时间复杂度为 $O\left(n^{2}\right)$ ；平均情况下，起泡排序的时间复杂度与最坏情况同数量级。起泡排序只需要一个记录的辅助空间，用来作为记录交换的暂存单元。起泡排序是一种稳定的排序方法。

\section*{8．3．2 快速排序}
快速排序 ${ }^{(1)}$（quick sort）是对起泡排序的一种改进，改进的着眼点是：在起泡排序中，记录的比较和移动是在相邻位置进行的，记录每次交换只能后移一个位置，因而总的比较次数和移动次数较多。在快速排序中，记录的比较和移动从两端向中间进行，值较大的记录一次就能从前面移动到后面，值较小的记录一次就能从后面移动到前面，记录移动的距离较远，从而减少了总的比较次数和移动次数。

快速排序的基本思想是：首先选定一个轴值（pivot，即比较的基准），将待排序记录划分成两部分，左侧记录均小于或等于轴值，右侧记录均大于或等于轴值，然后分别对这两部分重复上述过程，直到整个序列有序，如图 8－6 所示。显然，快速排序是一个递归的过程。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-277}

图 8－6 快速排序的基本思想图解

在快速排序中，需解决的关键问题是：\\
（1）如何选择轴值？\\
（2）在待排序序列中如何进行划分（通常叫作一次划分）？\\
（3）如何处理划分得到的两个待排序子序列？\\
（4）如何判别快速排序的结束？\\
问题（1）的解决：选择轴值有多种方法，最简单的方法是选取第一个记录，但是，如果待排序记录是正序或者逆序，就会将除轴值以外的所有记录分到轴值的一边，这是快速排序的最坏情况。还可以在每次划分之前比较待排序序列的第一个记录、最后一个记录和中间记录，选取值居中的记录作为轴值并调换到第一个记录的位置。在下面的讨论中，选取第一个记录作为轴值。

问题（2）的解决：设待划分记录存储在 data［first］～data［last］中，一次划分算法用伪代码描述如下：

算法：Partition（first，last）\\
输人：待划分的记录序列 data［first］～data［last］\\
输出：轴值的位置\\
1．设置划分区间：$i=f i r s t ; ~ j=l a s t ;$\\
2．重复下述过程，直到 $i$ 等于 $j$\\
2.1 右侧扫描，直到 data［j］小于 data［i］；将 data［j］与 data［i］交换，i＋＋；\\
2.2 左侧扫描，直到 data［i］大于 data［j］；将 data［i］与 data［j］交换，j－－；

3．返回 i 的值；\\
【例 8－4】对于记录序列 $\{23,13,35,6,19,50,28\}$ ，一次划分的过程如图 8－7所示。

\footnotetext{（1）快速排序的发明者是1980年图灵奖的获得者、牛津大学计算机科学家查尔斯•霍尔（Charles Hoare）。霍尔在程序设计语言的定义和设计、数据结构和算法、操作系统等许多方面都有一系列的发明创造。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-278}

图 8－7 一次划分的过程示例\\
一次划分算法的成员函数定义如下：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-278(1)}

问题（3）和（4）的解决：对待排序序列进行一次划分之后，再分别对左右两个子序列进行快速排序，直到每个分区都只有一个记录为止。下面看一个快速排序的例子。

【例 8－5】 对于记录序列 $\{23,13,35,6,19,50,28\}$ ，快速排序的执行过程如图 8－8所示。整个快速排序的过程可递归进行。若待排序序列中只有一个记录，则结束递归，否则进行一次划分后，再分别对划分得到的两个子序列进行快速排序（即递归处理）。

下面给出快速排序的成员函数定义。

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
待排序记录序列 & 23 & 13 & 35 & 6 & 19 & 50 & 28 \\
\hline
第1趟排序结果 & 19 & 13 & 6 & 23 & 35 & 50 & 28 \\
\hline
第2趟排序结果 & 6 & 13 & 19 & 23 & 28 & 35 & 50 \\
\hline
第3趟排序结果 & 6 & 13 & 19 & 23 & 28 & 35 & 50 \\
\hline
第4趟排序结果 & 6 & 13 & 19 & 23 & 28 & 35 & 50 \\
\hline
\end{tabular}
\end{center}

图8－8 快速排序的执行过程

\begin{verbatim}
void Sort :: QuickSort(int first, int last)
l
    if (first >= last) return; //区间长度为 1,递归结束
    else {
        int pivot = Partition(first, last); //一次划分
        QuickSort (first, pivot-1); //对左侧子序列进行快速排序
        QuickSort (pivot+1,last) ; //对右侧子序列进行快速排序
\end{verbatim}

从快速排序的执行过程可以看出，快速排序的执行时间取决于递归的深度。最好情况下，每次划分对一个记录定位后，该记录的左侧子序列与右侧子序列的长度相同。在具有 $n$ 个记录的序列中，将一个记录定位要对整个待划分序列扫描一遍，所需时间为 $O(n)$ 。设 $T(n)$ 是对 $n$ 个记录的序列进行排序的时间，每次划分后，正好把待划分区间划分为长度相等的两个子序列，则有；

$$
\begin{aligned}
T(n) & \leqslant 2 T(n / 2)+n \\
& \leqslant 2(2 T(n / 4)+n / 2)+n=4 T(n / 4)+2 n \\
& \leqslant 4(2 T(n / 8)+n / 4)+2 n=8 T(n / 8)+3 n \\
& \vdots \\
& \leqslant n T(1)+n \log _{2} n=O\left(n \log _{2} n\right)
\end{aligned}
$$

最坏情况下，待排序记录序列正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一个子序列为空。此时，必须经过 $n-1$ 次递归调用才能将所有记录定位，而且第 $i$ 趟划分需要经过 $n-i$ 次比较才能找到第 $i$ 个记录的轴值位置，因此，总的比较次数为：$\sum_{i=1}^{n-1}(n-i)=\frac{1}{2} n(n-1)=O\left(n^{2}\right)$ ，记录的移动次数小于等于比较次数。因此，时间复杂度为 $O\left(n^{2}\right)$ 。

平均情况下，设轴值记录的关键码是待排序序列的第 $k$ 小 $(1 \leqslant k \leqslant n)$ 记录，则有：

$$
T(n)=\frac{1}{n} \sum_{k=1}^{n}(T(n-k)+T(k-1))+n=\frac{2}{n} \sum_{k=1}^{n} T(k)+n
$$

这是快速排序的平均时间性能。可以用归纳法证明，其数量级为 $O\left(n \log _{2} n\right)$ 。

由于快速排序是递归进行的，需要一个工作栈来存放每一层递归调用的执行环境，其最大容量与递归调用的深度一致。最好情况下为 $O\left(\log _{2} n\right)$ ；最坏情况下要进行 $n-1$ 次递归调用，所以，栈的深度为 $O(n)$ ；平均情况下，栈的深度为 $O\left(\log _{2} n\right)$ 。快速排序是一种不稳定的排序方法。

快速排序的平均时间性能是迄今为止所有内排序算法中最好的，因此得到广泛应用，例如 UNIX 系统的 qsort 函数就采用了快速排序。

\section*{8.4 选 择 排 序}
选择排序的主要思想是：每趟排序在当前待排序序列中选出最小的记录，添加到有序序列中。选择排序的特点是记录移动的次数较少。

\section*{8．4．1 简单选择排序}
简单选择排序（simple selection sort）是选择排序中最简单的排序方法，其基本思想是：第 $i$ 趟排序在待排序序列 $r_{i} \sim r_{n}(1 \leqslant i \leqslant n-1)$ 中选取最小的记录，并和第 $i$ 个记录交换作为有序序列的第 $i$ 个记录，如图 8－9所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-280}

图 8－9 简单选择排序的基本思想\\
在简单选择排序中，需解决的关键问题是：\\
（1）如何在待排序序列中选出最小的记录？\\
（2）如何确定待排序序列中最小的记录在有序序列中的位置？\\
【例 8－6】对于记录序列 $\{38,27,50,13,45\}$ ，简单选择排序的过程如图 8－10 所示，具体排序过程如下：\\
（1）将整个记录序列划分为有序区和无序区，初始时有序区为空，无序区含有待排序的所有记录。\\
（2）在无序区中选取最小的记录，将它与无序区中的第一个记录交换，使得有序区增加一个记录，同时无序区减少一个记录。\\
（3）不断重复步骤（2），直到无序区只剩下一个记录。\\
从以上排序过程，可以得到上述关键问题的解决方法：\\
问题（1）的解决：设置一个整型变量 index，用于记载一趟比较过程中最小记录的位置。将 index 初始化为当前无序区的第一个位置，然后用 data［index］与无序区中其他记录进行比较，如果有比 data［index］小的记录，就将 index 修改为这个新的最小记录的位置，一趟比较结束后，index 中保留的就是本趟排序最小记录的位置。

\begin{center}
\begin{tabular}{llllll}
待排序记录序列 & 38 & 27 & 50 & 13 & 45 \\
第1趟排序结果 & 13 & 27 & 50 & 38 & 45 \\
第2趙排序结果 & 13 & 27 & 50 & 38 & 45 \\
第3趟排序结果 & 13 & 27 & 38 & 50 & 45 \\
第4趟排序结果 & 13 & 27 & 38 & 45 & 50 \\
\end{tabular}
\end{center}

图 8－10 简单选择排序的过程示例\\
问题（2）的解决：第 $i$ 趟简单选择排序的待排序区间是 data［i］～data［length－1］，则 data［i］是无序区第一个记录，所以，将记录 data［index］与 data［i］进行交换。

下面给出简单选择排序的成员函数定义。

\begin{verbatim}
void Sort :: SelectSort()
{
    int i, j, index, temp;
    for(i = 0; 1 < length-1; 1 + +) //进行 length-1趟简单选择排序
    {
        index = 1;
        for (j=1+1; j < length; j++) //在无序区中选取最小记录
            if(data[j] < data[index]) index = j;
        if(index != i) {
            temp = data[i]; data[i] = data[index]; data[index] = temp;
        }
    }
)
\end{verbatim}

容易看出，在简单选择排序中记录的移动次数较少。待排序序列为正序时，记录的移动次数最少，为 0 次；待排序序列为逆序时，记录的移动次数最多，为 $3(n-1)$ 次。无论记录的初始排列如何，记录的比较次数相同，第 $i$ 趟排序需进行 $n-i$ 次比较，简单选择排序需进行 $n-1$ 趟排序，则总的比较次数为：

$$
\sum_{i=1}^{n-1}(n-i)=\frac{1}{2} n(n-1)=O\left(n^{2}\right)
$$

所以，简单选择排序最好、最坏和平均的时间性能均为 $O\left(n^{2}\right)$ 。在简单选择排序过程中，只需要一个用作记录交换的暂存单元。由于记录交换不是在相邻单元中进行，简单选择排序是一种不稳定的排序方法 ${ }^{(1)}$ 。

\footnotetext{（1）例如待排序序列 $\left\{2,2^{*}, 1\right\}$ ，排序结果是 $\left\{1,2^{*}, 2\right\}$ ，两个 2 的相对位置发生了改变。
}\section*{8．4．2 堆排序}
堆排序（heap sort）${ }^{(1)}$ 是简单选择排序的一种改进，改进的着眼点是：如何减少记录的比较次数。简单选择排序在一趟排序中仅选出最小记录，没有把一趟的比较结果保存下来，因而记录的比较次数较多。堆排序在选出最小记录的同时，也找出较小记录，减少了选择的比较次数，从而提高整个排序的效率。

\section*{1．堆的定义}
堆（heap）是具有下列性质的完全二叉树 ${ }^{(2)}$ ：每个结点的值都小于或等于其左右孩子结点的值（称为小根堆）；或者每个结点的值都大于或等于其左右孩子结点的值（称为大根堆）。如果将堆按层序从 1 开始编号，则结点之间满足如下关系：\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-282(2)}

$$
\left\{\begin{array} { l } 
{ k _ { i } \leqslant k _ { 2 i } } \\
{ k _ { i } \leqslant k _ { 2 i + 1 } }
\end{array} \quad \text { 或 } \left\{\begin{array}{l}
k_{i} \geqslant k_{2 i} \\
k_{i} \geqslant k_{2 i+1}
\end{array} \quad 1 \leqslant i \leqslant\lfloor n / 2\rfloor\right.\right.
$$

从堆的定义可以看出，一个完全二叉树如果是堆，则根结点（称为堆顶）一定是当前所有结点的最大者（大根堆）或最小者（小根堆）。以结点的编号作为下标，将堆用顺序存储结构存储，则堆对应于一组序列，如图 8－11 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-282}\\
（a）大根堆及其对应的序列\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-282(1)}

\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
18 & 30 & 22 & 40 & 32 & 45 & 36 & 50 \\
\hline
\end{tabular}
\end{center}

（b）小根堆及其对应的序列

图 8－11 堆的示例\\
下面讨论堆调整的问题；在一棵完全二叉树中，根结点的左右子树均是堆，如何调整根结点，使整个完全二叉树成为一个堆？以下讨论以大根堆为例。

【例 8－7】 图 8－12（a）所示完全二叉树，根结点 28 的左右子树均是堆，调整根结点的过程如图 8－12 所示。首先将根结点 28 与其左右孩子比较，根据堆的定义，应将 28 与 35交换。经过这一次交换，破坏了原来左子树的堆结构，需要对左子树再进行调整，调整后的堆如图8－12（c）所示。

由这个例子可以看出，在堆调整的过程中，总是将根结点（即被调整结点）与左右孩子进行比较，若不满足堆的条件，则将根结点与左右孩子的较大者进行交换。这个调整过程一直

\footnotetext{（1）堆排序是由罗伯特•弗洛伊德和威廉姆斯在1964年共同发明的。\\
（2）有些参考书将堆直接定义为序列，但是，从逻辑结构上讲，还是将堆定义为完全二又树更好。虽然堆的典型实现方法是使用数组，但是从逻辑的角度来看，堆实际上是一种树结构。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-283}

图 8－12 堆调整的过程示例\\
进行到所有子树均为堆或将被调整结点交换到叶子为止。堆调整算法用伪代码描述如下：

算法：Sift（k，last）\\
输人：待调整的记录 data［k］$\sim$ data［last］，且 data［k＋1］$\sim$ data［last］满足堆的条件输出：无

1．设变量 i 和 j 分别指向当前要调整的结点和要调整结点的左孩子；\\
2．若结点 i 已是叶子，则算法结束；否则，执行下述操作：\\
2.1 将 j 指向结点 i 的左右孩子中的较大者；\\
2.2 如果 data［i］大于 data［j］，则调整完毕，算法结束；\\
2.3 如果 data［i］小于 data［j］，则将 data［i］与 data［j］交换；

令 $i=j, j=i$ 的左孩子，转步骤 2 继续调整；\\
将完全二叉树存储到 data［0］～data［length－1］中，则结点 data［ i ］的左孩子是 $\operatorname{data}[2 * i+1]$ ，右孩子是 $\operatorname{data}[2 * i+2]$ ，堆调整算法的成员函数定义如下：

\begin{verbatim}
void Sort : : Sift (int k, int last)
1
    int i, j, temp;
    $i=k ; j=2 * i+1 ; \quad$ // $i$ 是被调整结点, $j$ 是 $i$ 的左孩子
    while ( $j<=$ last) //还没有进行到旪子
    \{
        if $(j<1 a s t \& \& \operatorname{data}[j]<\operatorname{data}[j+1]) j++; \quad / / j$ 指向左有孩子的较大者
        if (data[i] > data[j]) break; //已经是堆
        else \{
            temp $=\operatorname{data}[i] ; \operatorname{data}[i]=\operatorname{data}[j] ; \operatorname{data}[j]=\operatorname{temp} ;$
            $i=j ; j=2 * i+1 ; \quad / /$ 被调整结点位于结点 $j$ 的位置
        )
    1
\end{verbatim}

\section*{2．堆排序}
堆排序是基于堆（假设用大根堆）的特性进行排序的方法，其基本思想是：首先将待排序序列调整成一个堆，此时，选出了堆中所有记录的最大者即堆顶记录，然后将堆顶记录移走，并将剩余记录再调整成堆，这样

又找出了次大记录，以此类推，直到堆中只有一个记录，如图 8－13 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-284}

图8－13 堆排序的基本思想图解\\
在堆排序中，需解决的关键问题是：\\
（1）如何将待排序序列调整成一个堆（即初始建堆）？\\
（2）如何处理堆顶记录？\\
（3）如何调整剩余记录，成为一个新的堆（即重建堆）？\\
【例 8－8】 将记录序列 $\{36,30,18,40,32,45,22,50\}$ 调整为一个大根堆，是从编号最大的分支结点开始进行调整，直至根结点，具体过程如图 8－14 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-284(1)}

图 8－14 初始建堆的过程示例\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-285(1)}\\
（g）继续调整 36\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-285}\\
（h）初始建堆完成

图 8－14（续）\\
由如上初始建堆的过程，可以得到关键问题的解决方法。\\
问题（1）的解决：初始建堆的过程就是反复调用堆调整的过程。因为序列对应完全二叉树的顺序存储，所有叶子结点都已经是堆，只需从最后一个分支结点到根结点，执行堆调整。

问题（2）的解决：初始建堆后，将待排序序列分成无序区和有序区两部分，其中，无序区对应一个大根堆，且包括全部待排序记录，有序区为空。将堆顶与堆中最后一个记录交换，则堆中减少了一个记录，有序区增加了一个记录。一般情况下，第 $i$ 趟 $(1 \leqslant i \leqslant l e n g t h$ －1）堆排序对应的堆中最后一个记录是 data［length－i］，将 data［0］与 data［length－i］相交换。

问题（3）的解决：第 $i$ 趟 $(1 \leqslant i \leqslant$ length－1）排序后，无序区有 length－$i$ 个记录，在无序区对应的完全二叉树中，只需调整根结点即可重新建堆。

【例 8－9】对于记录序列 $\{36,30,18,40,32,45,22,50\}$ 进行堆排序，首先将记录序列调整为大根堆，然后将堆顶与堆中最后一个记录交换，再重新建堆，这个过程一直进行到堆中只有一个记录为止，具体过程如图 8－15 所示，序列中阴影部分表示有序区。图中只给出了前两趟堆排序的结果，其余部分请读者自行给出。

将完全二叉树存储到 $\operatorname{data}[0] \sim \operatorname{data}[$ length -1$]$ 中，则最后一个分支结点是 data［ceil （length／2）－1］${ }^{\text {® }}$ 。下面给出堆排序的成员函数定义。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-285(2)}

图 8－15 堆排序的过程示例

\footnotetext{（1）函数调用 $\operatorname{ceil}(\mathrm{x})$ 实现对实数 $x$ 的向上取整操作，即返回大于或等于 $x$ 的最小整数。
}
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-286(1)}\\
（50）

\begin{center}
\begin{tabular}{|lllllll|l|}
\hline
30 & 40 & 45 & 36 & 32 & 18 & 22 & 50 \\
\hline
\end{tabular}
\end{center}

（c）调整 30 ，重建堆\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-286}\\
（50）

\begin{center}
\begin{tabular}{|llllll|l|l|}
\hline
22 & 40 & 30 & 36 & 32 & 18 & 45 & 50 \\
\hline
\end{tabular}
\end{center}

（e）调整 22 ，重建堆\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-286(2)}\\
（d）将 45 与 22 交换\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-286(3)}\\
（f）将 40 与 18 交换

图 8－15（续）\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-286(4)}

堆排序的运行时间主要消耗在初始建堆和重建堆时进行的堆调整上。初始建堆需要 $O\left(n \log _{2} n\right)$ 时间，第 $i$ 次取堆顶记录重建堆需要用 $O\left(\log _{2} i\right)$ 时间，并且需要取 $n-1$ 次堆顶记录，因此总的时间复杂度为 $O\left(n \log _{2} n\right)$ ，这是堆排序最好、最坏和平均的时间代价。堆排序对待排序序列的初始状态并不敏感，相对于快速排序，这是堆排序最大的优点。在堆排序算法中，只需要一个用来交换的暂存单元。堆排序是一种不稳定的排序方法。

\section*{8.5 归 并 排 序}
归并排序 ${ }^{(1)}$（merge sort）的主要思想是：将若干个有序序列逐步归并，最终归并为一个有序序列。二路归并排序（2－way merge sort）是归并排序中最简单的排序方法。

\section*{8．5．1 二路归并排序的递归实现}
二路归并排序的基本思想是：将待排序序列 $\left\{r_{1}, r_{2}, \cdots, r_{n}\right\}$ 划分为两个长度相等的子序列 $\left\{r_{1}, r_{2}, \cdots, r_{n / 2}\right\}$ 和 $\left\{r_{n / 2+1}, r_{n / 2+2}, \cdots, r_{n}\right\}$ ，分别对这两个子序列进行排序，得到两个有序子序列，再将这两个有序子序列合并成一个有序序列，如图 8－16 所示。\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-287(1)}

图 8－16 归并排序的基本思想\\
两个有序子序列的合并过程可能会破坏原来的有序序列，所以，合并不能就地进行。设两个相邻的有序子序列为 data［first1］～data［last1］和 data［last1＋1］～data［last2］，合并成一个有序序列 temp［first1］～temp［last2］。为此，设三个参数 $\mathrm{i} 、 \mathrm{j}$ 和 k 分别指向两个待合并的有序子序列和最终有序序列的当前记录，初始时 $i, j$ 分别指向两个有序子序列的第一个记录，即 $i=f i r s t 1, j=l a s t 1+1, k$ 指向存放合并结果的位置，即 $k=f i r s t 1$ 。然后，比较 i 和 j 所指记录，取出较小者作为归并结果存人 k 所指位置，直至两个有序子序列之一的所有记录都取完，再将另一个有序子序列的剩余记录顺序送到合并后的有序序列中。合并两个相邻有序子序列的成员函数定义如下；\\
\includegraphics[max width=\textwidth, center]{2025_06_06_704745ea57b15b2333e5g-287}

\footnotetext{（1）归并排序由冯•诺依曼于1945年在 EDVAC 方案（该方案确立了计算机的体系结构）中首次提出，是第一个可以在最坏情况下依然保持 $O\left(n \log _{2} n\right)$ 运行时间的确定性算法。
}\begin{verbatim}
while (i <= last1)
    temp[k++]= data[i++];
while (j<= last2) //对第二个子序列进行收尾处理
    temp[k++]= data[j++];
for (i = firstl; i <= last2; i + +)
    data[i] = temp[i];
delete[] temp;
\end{verbatim}

设二路归并排序的记录区间是［first～last］，当待排序区间只有一个记录时递归结束，二路归并排序的递归算法如下：

\begin{verbatim}
void Sort :: MergeSort1(int first, int last)
f
    if (first == last) return; //只有 1 个记录,递归结束
    else {
        int mid = (first+last)/2;
        MergeSort1(first, mid); //朋并排序前半个子序列
        MergeSort1(mid+1, last); //归并排序后半个子序列
        Merge(first, mid, last); //将两个已排序的子序列合并

二路归并排序需要进行 $\left\lceil\log _{2} n\right.$ 趟，合并两个子序列的时间性能为 $O(n)$ ，因此，二路归并排序的时间复杂度是 $O\left(n \log _{2} n\right)$ ，这是归并排序算法最好、最坏、平均的时间性能。二路归并排序在归并过程中需要与待排序序列同样数量的存储空间，空间复杂度为 $O(n)$ 。二路归并排序是一种稳定的排序方法。

\section*{8．5．2 二路归并排序的非递归实现}

归并排序的递归实现是一种自顶向下的方法，形式简洁但效率相对较差。归并排序的非递归实现是一种自底向上的方法，算法效率较高，但算法较复杂。分析二路归并排序的递归执行过程，如图8－17所示，可以将具有 $n$ 个记录的待排序序列看成是 $n$ 个长度为 1 的有序子序列，然后
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-288.jpg?height=241&width=243&top_left_y=1598&top_left_x=1347)

电子课件进行两两合并，得到 $[n / 2]$ 个长度为 2 （最后一个有序序列的长度可能是 1 ）的有序子序列，再进行两两归并，得到 $[n / 47$ 个长度为 4 的有序序列（最后一个有序序列的长度可能小于 4），以此类推，直至得到一个长度为 $n$ 的有序序列。

二路归并排序的非递归实现需解决的关键问题是：
（1）如何构造初始的有序子序列？
（2）如何实现有序子序列的两两合并从而完成一趟归并？
（3）如何控制二路归并的结束？
问题（1）的解决：设待排序序列含有 length 个记录，则可将整个序列看成是 length 个长度为 1 的有序子序列。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-289.jpg?height=759&width=1353&top_left_y=207&top_left_x=216)

图 8－17 归并排序的递归和非递归执行过程
问题（2）的解决：在一趟归并中，除最后一个有序序列外，其他有序序列中记录的个数 （称为序列长度）相同，用 $h$ 表示。现在的任务是把若干个相邻的长度为 $h$ 的有序序列和最后一个长度有可能小于 $h$ 的有序序列进行两两合并，将结果存放到 temp［length］中。为此，设参数 $i$ 指向待归并序列的第一个记录，初始时 $i=0$ ，显然合并的步长应是 $2 h$ 。在归并过程中，有以下三种情况：
－若 $i+2 h \leqslant$ length，表示待合并的两个相邻有序子序列的长度均为 $h$ ，如图 8－18 所示，执行一次合并，完成后 $i$ 加 $2 h$ ，准备进行下一次合并。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-289.jpg?height=174&width=847&top_left_y=1481&top_left_x=474)

图 8－18 $\quad i+2 h \leqslant n$ 情况示意图
－若 $i+h<$ length，则表示仍有两个相邻有序子序列，一个长度为 $h$ ，另一个长度小于 $h$ ，如图 8－19 所示，则执行这两个有序序列的合并，完成后退出一趟归并。
－若 $i+h \geqslant$ length，则表明只剩下一个有序子序列，如图 8－20 所示，不用合并。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-289.jpg?height=167&width=584&top_left_y=1941&top_left_x=269)

图 8－19 $i+h<n$ 情况示意图
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-289.jpg?height=169&width=533&top_left_y=1940&top_left_x=988)

图 8－20 $i+h \geqslant n$ 情况示意图

综上，一趟归并排序的成员函数定义如下：
\end{verbatim}

void Sort : : MergePass (int h)\\
l

\begin{verbatim}

\end{verbatim}

int $i=0$;\\
while $(i+2 * h<=$ length) $\quad / /$ 有两个长度为 $h$ 的子序列\\
1\\
Merge ( $i, i+h-1, i+2 * h-1$ ):\\
$i=i+2 * h$;\\
1\\
if $(i+h<1$ ength $) \quad / /$ 两个子序列一个长度小于 $h$\\
Merge(1, $i+h-1$, length-1):

\begin{verbatim}

问题（3）的解决：开始时，有序子序列的长度为 1 ，结束时，有序子序列的长度为 length，因此，可以用有序子序列的长度来控制排序过程的结束。二路归并排序非递归算法的成员函数定义如下：
\end{verbatim}

void Sort : : MergeSort2()\\
(\\
int $\mathrm{h}=1$; //初姶时子序列长度为 1\\
while ( $h<l e n g t h$ )\\
1\\
MergePass (h) ; //一趟归并排序\\
$\mathrm{h}=2$ * h;\\
3\\
1

\begin{verbatim}

\section*{8.6 各种排序方法的比较}

\section*{8．6．1 各种排序技术的使用范例}

在定义了排序类 Sort 并实现了各种排序技术后，程序中就可以使用 Sort 类来定义对象，可以调用实现各种排序技术的函数来完成相应的排序功能。范例程序如下：
\end{verbatim}

\section*{inciude <iostream>}
\#include <cmath>\\
using namespace std;\\
//將排序类定义和各个排序算法的成员函数定义放到这里\\
int main()\\
|\\[0pt]
int select, r[10] = \{2,5,1,7,9,4,3,6,5,8\};\\
Sort L\{x, 10):\\
cout <<"1.直接插入排序 2.希尔排序"<<endl;\\
cout <<"3.起泡排序 4.快速排序"<<endl;\\
cout <<"5.简单选择排序 6. 堆排序" <<endl;

\begin{verbatim}

\end{verbatim}

cout<<"7. 二路归并递归排序 8. 二路归并非递归排序"<<endl;\\
cout <<"请输人使用的排序技术编号:";\\
cin>>select;\\
switch (select)\\
S\\
case 1: L. InsertSort(); break; case 2: L. Shel1Sort(); break;\\
case 3:L.BubbleSort(); break; case 4:L.QuickSort(0,9);break;\\
case 5:L.SelectSort ();break; case 6:L.HeapSort(); break;\\
case 7:L.MergeSort1(0, 9); break; case 8: L.MergeSort2(); break;\\
default: cout <<"输人排序编号错误" <<endl; break;\\
\}\\
L.Print();\\
return 0;\\
\}

\begin{verbatim}

\section*{8．6．2 各种排序方法的综合比较}

迄今为止，已有的排序方法远远不止上面讨论的几种。人们之所以热衷于研究排序方法，一方面是由于排序在数据处理中所处的重要地位；另一方面，由于这些方法各有优缺点，排序方法的选用应该根据具体情况而定。

\section*{1．时间复杂度}

本章介绍的各种排序方法的时间性能和空间性能如表 8－1 所示。
表 8－1 各种排序方法的时空性能
\begin{tabular}{|l|l|l|l|l|}
\hline \multirow{2}{*}{\backslashbox{排序方法}{时空性能}} & \multicolumn{3}{|c|}{时间性能} & 空间性能 \\
\hline & 平均情况 & 最好情况 & 最坏情况 & 辅助空间 \\
\hline 直接插入排序 & $O\left(n^{2}\right)$ & $O(n)$ & $O\left(n^{2}\right)$ & O（1） \\
\hline 希尔排序 & $O\left(n \log _{2} n\right) \sim O\left(n^{2}\right)$ & $O\left(n^{1,3}\right)$ & $O\left(n^{2}\right)$ & O（1） \\
\hline 起泡排序 & $O\left(n^{2}\right)$ & $O(n)$ & $O\left(n^{2}\right)$ & O（1） \\
\hline 快速排序 & $O\left(n \log _{2} n\right)$ & $O\left(n \log _{2} n\right)$ & $O\left(n^{2}\right)$ & $O\left(\log _{2} n\right) \sim O(n)$ \\
\hline 简单选择排序 & $O\left(n^{2}\right)$ & $O\left(n^{2}\right)$ & $O\left(n^{2}\right)$ & O（1） \\
\hline 堆排序 & $O\left(n \log _{2} n\right)$ & $O\left(n \log _{2} n\right)$ & $O\left(n \log _{2} n\right)$ & $O(1)$ \\
\hline 归并排序 & $O\left(n \log _{2} n\right)$ & $O\left(n \log _{2} n\right)$ & $O\left(n \log _{2} n\right)$ & $O(n)$ \\
\hline
\end{tabular}

从平均情况看，有三类排序方法：
（1）直接插人排序、简单选择排序和起泡排序属于一类，时间复杂度为 $O\left(n^{2}\right)$ ，其中以直接插人排序方法最常用，特别是对于基本有序的记录序列。
（2）堆排序、快速排序和归并排序属于一类，时间复杂度为 $O\left(n \log _{2} n\right)$ ，其中快速排序目前被认为是最快的一种排序方法，在待排序记录个数较多的情况下，归并排序较堆排序更快。
（3）希尔排序介于 $O\left(n^{2}\right)$ 和 $O\left(n \log _{2} n\right)$ 之间。
从最好情况看，直接插人排序和起泡排序最好，时间复杂度为 $O(n)$ ，其他排序算法的最好情况与平均情况相同；从最坏情况看，快速排序的时间复杂度为 $O\left(n^{2}\right)$ ，直接插人排序和起泡排序虽然与平均情况相同，但系数大约增加一倍，所以运行速度将降低一半，最坏情况对简单选择排序、堆排序和归并排序影响不大。

由此可知，在最好情况下，直接插人排序和起泡排序最快；在平均情况下，快速排序最快；在最坏情况下，堆排序和归并排序最快。

\section*{2．空间复杂度}

从空间性能看，所有排序方法分为三类：归并排序属于一类，空间复杂度为 $O(n)$ ；快速排序属于一类，空间复杂度为 $O\left(\log _{2} n\right) \sim O(n)$ ；其他排序方法归为一类，空间复杂度为 $O(1)$ 。

\section*{3．稳定性}

所有排序方法可分为两类，一类是稳定的，包括直接插人排序、起泡排序和归并排序；另一类是不稳定的，包括希尔排序、快速排序、简单选择排序和堆排序。

\section*{4．算法简单性}

从算法简单性看，一类是简单算法，包括直接插入排序、简单选择排序和起泡排序，另一类是改进算法，包括希尔排序、堆排序、快速排序和归并排序，这些算法都很复杂。

\section*{5．待排序的记录个数}

从待排序的记录个数 $n$ 的大小看，$n$ 越小，采用简单排序方法越合适，$n$ 越大，采用改进的排序方法越合适。因为 $n$ 越小，$O\left(n^{2}\right)$ 同 $O\left(n \log _{2} n\right)$ 的差距越小，并且输人和调试简单算法比输人和调试改进算法要少用很多时间。

\section*{6．记录本身信息量的大小}

从记录本身信息量的大小看，记录本身信息量越大，表明占用的存储空间就越多，移动记录所花费的时间就越多，所以对记录的移动次数较多的算法不利。表 8－2 中给出了三种简单排序算法中记录的移动次数的比较。当记录本身的信息量较大时，对简单选择排序算法有利，而对其他两种排序算法不利。记录本身信息量的大小对改进算法的影响不大。

表 8－2 三种简单排序算法记录的移动次数
\begin{tabular}{|l|l|l|l|}
\hline 排 序 方 法 & 最好情况 & 最坏情况 & 平 均 情 况 \\
\hline 直接插人排序 & $O(n)$ & $O\left(n^{2}\right)$ & $O\left(n^{2}\right)$ \\
\hline 起泡排序 & 0 & $O\left(n^{2}\right)$ & $O\left(n^{2}\right)$ \\
\hline 简单选择排序 & 0 & $O(n)$ & $O(n)$ \\
\hline
\end{tabular}

\section*{7．初始记录的分布情况}

当待排序序列为正序时，直接插人排序和起泡排序能达到 $O(n)$ 的时间复杂度；而对于快速排序而言，这是最坏的情况，此时的时间性能蜕化为 $O\left(n^{2}\right)$ ；简单选择排序、堆排序和归并排序的时间性能不随序列中的记录分布而改变。

\section*{8.7 扩展与提高}

\section*{8．7．1 排序问题的时间下界}

算法是问题的解决方法，针对一个问题可以设计出不同的算法，不同算法的时间复杂度可能不同。能否确定某个算法是求解该问题的最优算法？是否还存在更有效的算法？如果能够知道一个问题的计算时间下界，也就是求解该问题的任何算法（包括尚未发现的算法）所需的时间下界，就可以较准确地评价解决该问题的各种算法的效率，进而确定已有算法还有多少改进的余地。

基于比较的排序算法是通过对输人元素两两比较进行的，可以用判定树来研究排序算法的时间性能。判定树（decision tree）是满足如下条件的二叉树：
（1）每一个内部结点对应一个形如 $x \leqslant y$ 的比较，如果关系成立，则控制转移到该结点的左子树，否则，控制转移到该结点的右子树；
（2）每一个叶子结点表示问题的一个结果。
在用判定树模型建立问题的时间下界时，通常忽略求解问题的所有算术运算，只考虑执行分支的转移次数。例如，对三个元素进行排序的判定树如图8－21所示，判定树中每一个内部结点代表一次比较，每一个叶子结点表示算法的一个输出。显然，最坏情况下的时间复杂度不超过判定树的高度。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-293.jpg?height=393&width=1108&top_left_y=1573&top_left_x=351)

图 8－21 对三个数进行排序的判定树
由判定树模型不难看出，可以把排序算法的输出解释为待排序序列下标的一个全排列，使得序列中的元素按照升序排列。例如，待排序序列 $\left\{a_{1}, a_{2}, a_{3}\right\}$ 下标的一个全排列 321 满足 $a_{3}<a_{2}<a_{1}$ ，且对应判定树中一个叶子结点。因此，将一个具有 $n$ 个记录的序列排序后，可能的输出有 $n!$ 个。注意到，由于相同的输出可以通过不同的比较路径得到，因此，判定树中叶子结点的个数可能大于问题的输出个数。

对于一个问题规模为 $n$ 的输人实例，排序算法可以沿着判定树中一条从根结点到叶

子结点的路径来完成，比较次数等于该叶子结点在判定树的层数。那么，至少具有 $n!$ 个叶子结点的判定树的高度是多少呢？

定理 8－1 若 $T$ 是至少具有 $n$ ！个叶子结点的二叉树，则 $T$ 的高度至少是 $n \log _{2} n-$ $1.5 n$ 。

证明：设 $m$ 是二叉树 $T$ 中的叶子结点的个数，$h$ 为二叉树 $T$ 的高度，由于高度为 $h$的满二叉树具有 $2^{h-1}$ 个叶子，则有下式成立：

$$
\begin{equation*}
n!\leqslant m \leqslant 2^{h} \tag{8-1}
\end{equation*}
$$


因此

$$
h \geqslant \log _{2} n!=\sum_{j=1}^{n} \log _{2} j \geqslant n \log _{2} n-n \log _{2} \mathrm{e}+\log _{2} \mathrm{e} \geqslant n \log _{2} n-1.5 n
$$


定理 8－1 说明，任何基于比较的对 $n$ 个元素进行排序的算法，判定树的高度都不会大于 $n \log _{2} n$ 。因此，$O\left(n \log _{2} n\right)$ 是这些算法的时间下界。

\section*{8．7．2 基数排序}

基数排序（radix sort）是借助对多关键码进行分配和收集的思想对单关键码进行排序，首先给出多关键码排序的定义。

给定记录序列 $\left\{r_{1}, r_{2}, \cdots, r_{n}\right\}$ ，每个记录 $r_{i}$ 含有 $d$ 个关键码 $k_{i}^{0}, k_{i}^{1}, \cdots, k_{i}^{d-1}$ ，多关键码排序是将这些记录排列成顺序为 $\left\{r_{s 1}, r_{s 2}, \cdots, r_{s n}\right\}$ 的一个序列，使得对于序列中的任意两个记录 $r_{i}$ 和 $r_{j}$ 都满足 $k_{i}^{0} k_{i}^{1} \cdots k_{i}^{d-1} \leqslant k_{j}^{0} k_{j}^{1} \cdots k_{j}^{d-1}$ ，其中 $k^{0}$ 称为最主位关键码，$k^{d-1}$ 称为最次位关键码。

例如，对 52 张扑克牌进行排序，每张牌有两个关键码：花色和点数，假设有如下次序关系：

花色：红桃＜梅花＜黑桃＜方块
点数： $2<3<4<5<6<7<8<9<10<\mathrm{J}<\mathrm{Q}<\mathrm{K}<\mathrm{A}$
在对扑克牌进行排序时，可以先按花色将扑克牌分成 4 堆，每堆具有相同的花色且按点数排序，然后按花色将 4 堆整理到一起。也可以采用另一种方法：先按点数将扑克牌分成 13 堆，每堆具有相同的点数且按花色排序，然后按点数将 13 堆整理到一起。因此，对多关键码进行排序可以有如下两种基本的方法。

\section*{1．最主位优先 MSD（Most Significant Digit First）}

先按最主位关键码 $k^{0}$ 进行排序，将序列分割成若干子序列，每个子序列中的记录具有相同的 $k^{0}$ 值；再分别对每个子序列按关键码 $k^{1}$ 进行排序，将子序列分割成若干个更小的子序列，每个更小的子序列中的记录具有相同的 $k^{1}$ 值；以此类推，直至按最次位关键码 $k^{\alpha-1}$ 排序，最后将所有子序列收集在一起得到一个有序序列。

\section*{2．最次位优先 LSD（Least Significant Digit First）}

从最次位关键码 $k^{\alpha-1}$ 起进行排序，然后再按关键码 $k^{\alpha-2}$ 排序，依次重复，直至对最主位关键码 $k^{\circ}$ 进行排序，得到一个有序序列。LSD 方法无须分割序列但要求按关键码
$k^{d-1} \sim k^{1}$ 进行排序时采用稳定的排序方法。
基数排序将待排序记录看成由若干个子关键码复合而成，采用 LSD 方法进行排序，其主要过程是：从最次位关键码到最主位关键码进行 $d$ 趟排序，第 $i(1 \leqslant i \leqslant d)$ 趟排序按子关键码 $k^{d-i}$ 将具有相同值的记录分配到一个队列中，然后再依次收集起来，得到一个按子关键码 $k^{d-i}$ 有序的序列。

【例 8－10】 对于记录序列 $\{61,98,12,15,20,24,31,23,35\}$ 进行基数排序，由于记录都是两位十进制数，所以基数排序共执行两趟。首先按个位将记录分配到相应队列中，将队列首尾相接收集起来，再按十位将记录分配到相应队列中，将队列首尾相接收集起来，得到排序结果，具体过程如图 8－22 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-295.jpg?height=598&width=1289&top_left_y=744&top_left_x=253)

图 8－22 基数排序的过程示例
基数排序将待排序序列按某个子关键码的值分配到相应队列中，每个队列的长度不确定，收集时要将所有队列依次首尾相接，因此，待排序序列和队列均采用链接存储。设待排序记录均为十进制整数，存储在不带头结点的单链表 first 中，数组 front［10］和 rear［10］分别存储十个链队列的队头指针和队尾指针，链队列不带头结点，单链表的结点结构请参见 2．4．1节，基数排序算法用 C ++ 语言描述如下：
\end{verbatim}

void RadixSort (Node<int>*first, int d) //d 是记录的最大位数\\
i\\
Node<int> * front[10], * rear[10], * tail; //tail 用于首尾相接时指向队尾\\
int i, j, k, base = 1; //base 是被除数\\
for (i = 1; i <= d; i ++) //进行 d 趟基数排序\\
\}\\
for (j= 0; j< 10; j++)\\[0pt]
front[j] = rear[j] = nul1ptr; //清空每一个队列\\
while (first != nullptr) //分配,将记录分配到队列中\\
l\\
k = (first->data / base) \% 10;\\[0pt]
if (front [k] == nullptr) front[k] = rear[k] = first;\\[0pt]
else rear [k] = rear [k] ->next = first;

\begin{verbatim}

\end{verbatim}

\begin{verbatim}
    first = first - >next;
}
for (j=0; j<10; j++) //收集,将队列首尾相接
{
    if (front[j] == nullptr) continue;
    if(first ==nullptr) first = front[j];
    else tail->next = front[j];
    tail = rear[j];
}
tail->next = nullptr; //收集后单链表加尾标志
base = base * 10;
\end{verbatim}

\}

\begin{verbatim}

假设将待排序记录看成是由 $d$ 个子关键码复合而成，每个子关键码的取值范围为 $m$个，则基数排序的时间复杂度为 $O(d(n+m))$ ，其中每一趟分配的时间复杂度是 $O(n)$ ，每一趟收集的时间复杂度为 $O(m)$ ，整个排序需要执行 $d$ 趟。基数排序共需要 $m$ 个队列，需要存储 $m$ 个队列的队头指针和队尾指针，因此空间复杂度为 $O(m)$ 。由于采用队列作为存储结构，因此基数排序是稳定的。

\section*{思想火花——学会＂盒子以外的思考＂}

一个球静静地躺在一个方形的盒子里。球被撞击了一下，然后无限地在盒子里运动起来。问题是：什么条件下小球会作循环运动？

人们通常会采用这样的方法：将思维限制在盒子里并试图在这个方形盒子＂内＂进行推理。然而，当球反射的次数很多并且球的运动轨迹包含许多段时，就很难看到球运动的任何模式。

可以扩展问题的推理空间，不去想球在盒子里来来去去的反射，而是想球在直线上运动而来考虑盒子的折射！图 8－23 展示了这一思想。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-296.jpg?height=302&width=888&top_left_y=1805&top_left_x=413)

图 8－23 将球在盒子里的反射想象成盒子的相应折射
每一次当球撞到盒子边，我们就沿这条边作出盒子的一次折射。注意，现在球只能撞击上面和右面的盒子边，如果它回到初始位置，也就完成了一次循环。

假设球确实作循环运动，这意味着球经过了一定数目的＂上面的＂盒子（设为 $p$ ）和一定数目的＂右面＂的盒子（设为 $q$ ）回到了起点，如图 8－24 所示。当且仅当 $\alpha=\pi / 2$ 或者 $\alpha$ 的正
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-297.jpg?height=450&width=883&top_left_y=229&top_left_x=494)

图 8－24 得到一个循环，球经过盒子的一系列的折射回到了起点
切（即 $\tan (\alpha)=p / q$ ）是个有理数时，球会在盒子里作循环运动。

\section*{习 题 8}

\section*{1．选择题}
（1）将待排序的 $n$ 个记录分为 $n / k$ 组，每组包含 $k$ 个记录，且任一组内的记录大于前一组内的所有记录且小于后一组内的所有记录，若采用基于比较的排序方法，其时间下界为（ ）。
A．$O\left(k \log _{2} k\right)$
B．$O\left(k \log _{2} n\right)$
C．$O\left(n \log _{2} k\right)$
D．$O\left(n \log _{2} n\right)$
（2）数据序列 $\{8,9,10,4,5,6,20,1,2\}$ 只能是（ ）的两趟排序后的结果。
A．选择排序
B．冒泡排序
C．插人排序
D．堆排序
（3）下述排序方法中，时间性能与待排序记录的初始状态无关的是 。
A．插人排序和快速排序
B．归并排序和快速排序
C．选择排序和归并排序
D．插入排序和归并排序
（4）下列排序算法中，（）可能会出现下面情况：在最后一趟开始之前，所有元素都不在最终位置上。
A．起泡排序
B．插入排序
C．快速排序
D．堆排序
（5）下列序列中，（ ）是执行第一趟快速排序的结果。
A．［da，ax，eb，de，bb］ff［ha，gc］
B．［cd，eb，ax，da］ff［ha，gc，bb］
C．［gc，ax，eb，cd，bb］ff［da，ha］
D．［ax，bb，cd，da］ff［ eb，gc，ha］
（6）对以下数据序列利用快速排序进行排序，速度最快的是（ ）。
A．$\{21,25,5,17,9,23,30\}$
B．$\{25,23,30,17,21,5,9\}$
C．$\{21,9,17,30,25,23,5\}$
D．$\{5,9,17,21,23,25,30\}$
（7）对初始状态为递增有序的序列进行排序，最省时间的是（ ），最费时间的是 （ ）。已知数据表中每个元素距其最终位置不远，则采用（ ）方法最节省时间。
A．堆排序
B．插人排序
C．快速排序
D．直接选择排序
（8）堆的形状是一棵（ ）。
A．二叉排序树
B．满二叉树
C．完全二叉树
D．判定树
（9）对关键码序列 $\{23,17,72,60,25,8,68,71,52\}$ 进行堆排序，输出两个最小关键码后的剩余堆是 。
A．$\{23,72,60,25,68,71,52\}$
B．$\{23,25,52,60,71,72,68\}$
C．$\{71,25,23,52,60,72,68\}$
D．$\{23,25,68,52,60,72,71\}$
（10）当待排序序列基本有序或个数较小的情况下，最佳的内部排序方法是（ ，就平均时间而言， ）最佳。
A．直接插人排序
B．冒泡排序
C．简单选择排序
D．快速排序
（11）在 5000 个元素中用最快的速度挑选出前 10 个最大的元素，采用 ）方法最好。
A．快速排序
B．堆排序
C．希尔排序
D．归并排序
（12）设要将序列（ $\mathrm{Q}, \mathrm{H}, \mathrm{C}, \mathrm{Y}, \mathrm{P}, \mathrm{A}, \mathrm{M}, \mathrm{S}, \mathrm{R}, \mathrm{D}, \mathrm{F}, \mathrm{X}$ ）中的关键码按升序排列，则（ 是冒泡排序一趟扫描的结果， ）是增量为 4 的希尔排序一趟扫描的结果 归并排序一趟扫描的结果， ）是以第一个元素为轴值的快速排序一趟扫描的结果，
）是堆排序初始建堆的结果。
A．$(F, H, C, D, P, A, M, Q, R, S, Y, X)$
B．（P，A，C，S，Q，D，F，X，R，H，M，Y）
C．（A，D，C，R，F，Q，M，S，Y，P，H，X）
D．$(H, C, Q, P, A, M, S, R, D, F, X, Y)$
E．（H，Q，C，Y，A，P，M，S，D，R，F，X）
（13）快速排序在 ）情况下最不利于发挥其长处。
A．待被排序的数据量太大
B．待排序的数据中含有多个相同值
C．待排序的数据已基本有序
D．待排序的数据数量为奇数
（14） ）方法是从未排序序列中挑选元素，并将其放人已排序序列的一端。
A．归并排序
B．插入排序
C．快速排序
D．选择排序
（15）已知关键码序列 $\{78,19,63,30,89,84,55,69,28,83\}$ 采用基数排序，第一趟排序后的关键码序列为 。
A．$\{19,28,30,55,63,69,78,83,84,89\}$
B．$\{28,78,19,69,89,63,83,30,84,55\}$
C．$\{30,63,83,84,55,78,28,19,89,69\}$
D．$\{30,63,83,84,55,28,78,19,69,89\}$

\section*{2．解答下列问题}
（1）已知数据序列为 $(12,5,9,20,6,31,24)$ ，对该数据序列进行排序，写出插人排序、冒泡排序、快速排序、简单选择排序、堆排序以及二路归并排序每趟的结果。
（2）对 $n=7$ ，给出快速排序一个最好情况和最坏情况的初始排列的实例。
（3）对 50 个整数进行快速排序需进行的关键码之间的比较次数可能达到的最大值和最小值分别是多少？
（4）判别下列序列是否为堆，如不是，按照堆排序思想把它调整为堆。
（1）$(1,5,7,25,21,8,8,42)$
（2）$(3,9,5,8,4,17,21,6)$

\section*{3．算法设计}
（1）设待排序的记录序列用单链表作存储结构，写出直接插入排序算法。
（2）设待排序的记录序列用单链表作存储结构，写出简单选择排序算法。
（3）分析直接插人排序算法，由于寻找插人位置的操作是在有序区进行，因此可以通过折半查找来实现，称为折半插人排序（binary insertion sort），请设计算法完成折半插入排序。
（4）对给定的序号 $k(1<k<n)$ ，要求在无序记录 $r[n]$ 中查找第 $k$ 小的记录，利用快速排序的划分思想设计算法实现上述查找。
（5）写出快速排序的非递归调用算法。
（6）已知记录序列（ $k_{1}, k_{2}, \cdots, k_{n}$ ）是堆，要求将记录序列（ $k_{1}, k_{2}, \cdots, k_{n}, k_{n+1}$ ）调整为堆。
（7）将有序序列 $A[n]$ 和有序序列 $B[m]$ 归并为一个有序序列并存放在 $C[m+n]$ 中。
（8）已知记录序列 $\mathrm{A}[\mathrm{n}]$ 中的关键码各不相同，可按如下方法实现计数排序：另设一个数组 $\mathrm{C}[\mathrm{n}]$ ，对每个记录 $\mathrm{A}[\mathrm{i}]$ ，统计序列中关键码比它小的记录个数 $\mathrm{C}[\mathrm{i}]$ ，则 $\mathrm{C}[\mathrm{i}]=0$的记录必为关键码最小的记录，$C[i]=1$ 的记录必为关键码次小的记录，以此类推，即按 $C[i]$ 值的大小对 A 中记录进行重新排列。试编写算法实现上述计数排序。
（9）最小最大堆是一种特殊的堆，其最小层和最大层交替出现，并且根结点总是最小层。如图 8－25 所示是一个最小最大堆的示例。试编写算法实现在最小最大堆中插人一个元素。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-299.jpg?height=312&width=743&top_left_y=1491&top_left_x=552)

图 8－25 最小最大堆示例

\section*{实 验 题 8}

【实验 1】双向起泡排序。在起泡排序中，若待排序序列为正序，只需一趟扫描，而待排序序列为反序时，需进行 $n-1$ 趟扫描。对于初始序列（ $94,10,12,18,42,44,67$ ）只需扫描 2 趟，而对于初始关键字序列（ $12,18,42,44,67,94,10$ ）就需扫描 6 趟。造成这种不对称的原因是：每趟扫描仅能使最小数据下沉一个位置，如果改变扫描方向，情况正好相反，即每趟从后往前扫描，都能使当前无序区中最大数据上浮一个位置。为了改变上述两

种情况下的不对称性，可以在排序过程中交替改变扫描方向，称之为双向起泡排序。设计双向起泡排序的算法，并将其时间性能与起泡排序算法的时间性能进行对比。

【实验 2】测算排序算法的比较次数和移动次数。在排序算法中的适当位置插人计数器，可以统计在算法执行过程中记录的比较次数和移动次数，请测算至少三种排序算法在相同数据状态下的比较次数和移动次数，并分析实验数据。

【实验 3】测算排序算法的执行时间。在执行排序算法前后分别获取当前的系统时钟（调用 clock 函数），可以测算排序算法的具体执行时间，请测算至少三种排序算法在相同数据状态下的执行时间，并分析实验数据。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-301.jpg?height=49&width=852&top_left_y=223&top_left_x=135)
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-301.jpg?height=50&width=853&top_left_y=393&top_left_x=170) 11. （ ）
＊ ，
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-301.jpg?height=49&width=363&top_left_y=506&top_left_x=173) lui 11 ＂等＂ $\qquad$ $=-9.4$ $\qquad$
    届尔鸣"血"
＂三是司
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-301.jpg?height=55&width=1033&top_left_y=559&top_left_x=167)
$\qquad$
$\qquad$ － 1.97 $\qquad$ ．等 F．Follo ＊ 1是

＋+ 一 + ．

\section*{뿐출 $A$}

\section*{预 备 知 识}

\section*{A． 1 数 学 术 语}

序列：一个长度为 $n$ 的序列是将 $n$ 个元素按线性顺序组织起来，其特点是：（1）序列中的元素有固定的顺序和位置；（2）序列中的元素可以重复。例如，$(8,3,5,2,9,10,5,9)$ 是一个长度为 8 的序列。

向下取整：实数 $x$ 的向下取整操作（记为 $L x\rfloor$ ）得到小于或等于 $x$ 的最大整数，例如，$\lfloor 3.4\rfloor=3$ 。在 C ++ 语言中用函数 floor 实现向下取整，例如 floor（3．4）。

向上取整：实数 $x$ 的向上取整操作（记为 $\lceil x\rceil$ ）得到大于或等于 $x$ 的最小整数，例如，$\lceil 3.4\rceil=4$ 。在 $C++$ 语言中用函数 ceil 实现向上取整，例如 ceil（3．4）。

取模：取模是对整数进行的操作，其结果是整除后非负的余数，用 $a \bmod b$ 表示，其中 $b$ 为正整数，所得结果在 $0 \sim b-1$ 之间，例如： 8 mod $5=3,-8 \bmod 5=2$ 。在 $\mathrm{C}++$ 语言中用运算符 $\%$ 实现取模运算，且运算符 $\%$ 的两个操作数均可以是负数。如果运算符 $\%$ 的任何一个操作数为负数，运算结果将随着编译器的不同而不同。例如，－8 \％5 有的编译器给出结果 2 ，而有的编译器给出结果－3。如果运算符 $\%$ 的两个操作数均为正数，则结果是唯一的。

\section*{A． 2 级数求和}

级数求和就是把函数在一定范围内的值累加起来，通常表示为 $\sum_{i=1}^{n} f(i)$ ，其含义是对作用于某个整数范围内的参数 $i$ 的函数 $f(i)$ 之值求和，函数 $f(i)$ 的参数和它的初值写在符号 $\sum$ 的下面，符号 $\sum$ 的上面表示参数的最大值。例如，$\sum_{i=1}^{n} f(i)$ 表示当 $i$ 的取值范围是 $[1, n]$ 时对函数
$f(i)$ 的值求和，也可以表示为：$\sum_{i=1}^{n} f(i)=f(1)+f(2)+\cdots+f(n)$ 。
能直接计算级数求和的等式称为闭合形式解，下面是本书中常用的闭合形式解：

$$
\begin{array}{ll}
\sum_{i=1}^{n} i=\frac{n(n+1)}{2} & \sum_{i=1}^{n}(n-i)=\frac{n(n-1)}{2} \\
\sum_{i=1}^{n} i^{2}=\frac{2 n^{3}+3 n^{2}+n}{6} & \sum_{i=1}^{\log _{2} n} n=n \log _{2} n \\
\sum_{i=1}^{n} 2^{i}=2\left(2^{n}-1\right) & \sum_{i=1}^{\log _{2} n} 2^{i}=2\left(2^{\log _{2} n}-1\right)=2(n-1)
\end{array}
$$


\section*{A． 3 集 合}

定义 1 集合是由互不相同的元素构成的一个整体。如果 $x$ 是集合 $S$ 的一个元素，记作 $x \in S$ ，读作 $x$ 属于 $S$ ；如果 $y$ 不是集合 $S$ 的一个元素，记作 $y \notin S$ ，读作 $y$ 不属于 $S$ 。

由集合的定义可以看出，集合具有下列特性。
（1）互异性：集合中没有重复的元素，即每个元素只出现一次。
（2）无序性：集合中的元素可以没有固定顺序，即集合的表示形式不唯一。
（3）确定性：任一元素要么属于某集合，要么不属于某集合。
集合有多种表示方法，常用的表示方法有以下三种。
（1）列举法：将组成集合的所有元素全部列举出来并置于花括弧内，元素之间用逗号分隔，空集记为 $\left\}\right.$ 或 $\phi_{\text {。 }}$ 在上下文意义明确的情况下，可以用省略号表示多个元素。例如：

$$
\begin{aligned}
& A=\{1,2,3,4, \cdots, 99\} \\
& B=\{a, e, i, o, u\}
\end{aligned}
$$

（2）描述法：通过刻画元素的性质来界定集合的成员。通常，由满足性质 $P(x)$ 的所有元素组成的集合可记为 $\{x \mid P(x)\}$ 。例如：

$$
\begin{aligned}
& C=\{x \mid x \text { 是实数 }\} \\
& D=\{x \mid x \text { 是素数并且 } x<20\}
\end{aligned}
$$

（3）图示法：集合还可以用文氏图来表示，文氏图用圆表示一个集合，用结点表示集合的元素。例如，集合 $B=\{a, e, i, o, u\}$ 的文氏图如图 A－1 所示。

定义2 集合 $A$ 中含有元素的个数称为集合 $A$ 的基，记为 $|A|$ 。若集合 $A$ 的基是有限数，则称 $A$ 为有限集，否则称 $A$为无限集。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-303.jpg?height=226&width=398&top_left_y=1904&top_left_x=1206)

图 A－1 集合的文氏图表示

例如，集合 $A=\{3,4,5\}$ ，则 $|A|=3$ 。
定义 3 对集合 $A$ 和 $B$ ，如果 $A$ 中的每个元素都属于 $B$ ，则称 $A$ 是 $B$ 的子集，记作 $A \subseteq B$ ；如果 $A$ 中至少有一个元素不属于 $B$ ，则称 $A$ 不是 $B$ 的子集，记作 $A \not \subset B$ ；如果 $A$

是 $B$ 的子集，但 $A$ 和 $B$ 不相等，则称 $A$ 是 $B$ 的真子集，记作 $A \subset B$ 。
例如，集合 $P=\{1,2,3,4,5\}, Q=\{1,3,5\}, R=\{2,4\}$ ，则集合 $Q$ 和 $R$ 都是 $P$ 的子集且都是真子集，但集合 $Q$ 不是 $R$ 的子集，集合 $R$ 也不是 $Q$ 的子集。

定义4 一个集合的幂集是指由该集合的所有可能子集组成的集合。
例如，若集合 $A=\{a, b, c\}$ ，则 $A$ 的幂集为 $\{\phi,\{a\},\{b\},\{c\},\{a, b\},\{a, c\},\{b, c\}$ ， $\{a, b, c\}\}$ 。

\section*{A． 4 关 系}

定义5 由两个具有固定次序的元素组成的序列称为序偶，记作 $(a, b)$ 。
例如，在笛卡儿坐标系中，二维平面上一个点的坐标 $(x, y)$ 就是一个序偶。
定义 6 集合 $A_{1}, A_{2}, \cdots, A_{n}$ 的笛卡儿积 $A_{1} \times A_{2} \times \cdots \times A_{n}$ 的任意一个子集，称为 $A_{1}$ ， $A_{2}, \cdots, A_{n}$ 上的一个 $n$ 元关系。特别地，$A_{1} \times A_{2}$ 的任意一个子集称为 $A_{1}$ 和 $A_{2}$ 的一个二元关系，记作 $R \subseteq A_{1} \times A_{2}$ 。

定义7 设 $R$ 是集合 $A$ 上的二元关系，对于 $a \in A, b \in A$ ，若 $(a, b) \in R$ ，则称 $a$ 是 $b$ 的前驱，$b$ 是 $a$ 的后继；若不存在 $a \in A$ ，使 $(a, b) \in R$ ，则 $b$ 无前驱，称为始端；若不存在 $b \in$ $A$ ，使 $(a, b) \in R$ ，则 $a$ 无后继，称为终端。

例如，$A=\{1,2,3,4,5\}, R \subseteq A \times A, R=\{(1,2),(2,3),(3,4),(4,5)\}$ ，则元素 1 为始端，元素 5 为终端，元素 2 的前驱是 1 ，元素 2 的后继是 3 。

定义 8 设 $R$ 是集合 $A$ 上的二元关系，
（1）对于任意的 $a \in A$ ，都有 $(a, a) \in R$ ，则称 $R$ 是自反的。
（2）对于任意的 $a \in A$ ，都有 $(a, a) \notin R$ ，则称 $R$ 是反自反的。
（3）对于任意的 $a \in A, b \in A$ ，若 $(a, b) \in R$ 且 $(b, a) \in R$ ，则称 $R$ 是对称的。
（4）对于任意的 $a \in A, b \in A$ ，若 $(a, b) \in R$ 且 $(b, a) \in R$ ，必有 $a=b$ ，则称 $R$ 是反对称的。
（5）对于任意的 $a \in A, b \in A, c \in A$ ，若 $(a, b) \in R$ 且 $(b, c) \in R$ ，必有 $(a, c) \in R$ ，则称 $R$是可传递的。

例如，对于自然数，＂$\leqslant$＂是自反的、反对称的和可传递的，＂$<$＂是反自反的和可传递的，＂$=$＂是自反的、反对称的和可传递的。

定义 9 设 $R$ 是集合 $A$ 上的二元关系，如果它是自反、对称且可传递的，则称 $R$ 是 $A$上的等价关系，此时，若 $(a, b) \in R$ ，则称 $a$ 与 $b$ 等价。

定义 10 设 $R$ 是集合 $A$ 上的等价关系，对任意 $a \in A$ ，在 $A$ 中与 $a$ 等价的全体元素所组成的集合，称为由 $a$ 生成的等价类，记作 $[a]_{R}$ 。

例如，$A=\{1,2,3,4,5,6,7\}, R$ 是 $A$ 上的模 3 同余关系。显然 $R$ 是 $A$ 上的等价关系，$A$ 中各元素关于 $R$ 的等价类分别是：$[1]_{R}=\{1,4,7\} ;[2]_{R}=\{2,5\} ;[3]_{R}=\{3,6\}$ 。

定义 11 设 $R$ 是集合 $A$ 上的二元关系，如果 $R$ 是自反、反对称且可传递的，则称 $R$是 $A$ 上的偏序关系，通常记作＂$\leqslant$＂。

例如，设 $A$ 为正整数集合，整除关系是 $A$ 上的一个偏序关系。
定义 12 设 $R$ 是集合 $A$ 上的偏序关系，对任意 $a \in A, b \in A$ ，都有 $(a, b) \in R$ 或 $(b$ ， $a) \in R$ ，则称 $R$ 是 $A$ 上的全序关系或线性序关系。

全序关系中的任意两个元素均存在某种比较关系。例如，实数集合上的＂$<$＂＂$\leqslant$＂ $">"$＂$\geqslant$＂等关系是全序，而正整数集合上的整除关系不是全序关系。

빠준준제

\section*{C＋＋语言基本语法}

\section*{B． 1 程 序 结 构}

一个 C＋＋程序可由若干个文件组成，C＋＋的程序文件分为头文件和源文件两种。头文件以 h 为后缀，用于存放常量定义、类型定义和函数原型等。有些头文件是系统定义的 ${ }^{(1)}$ ，有些头文件是用户定义的。可通过预处理指令 \＃include 将头文件包含在源文件中。源文件以 cpp 为后缀，用于存放 C ++ 的源代码。下面是一个典型的 C ++ 程序。
\end{verbatim}

/* MyFirstPro.cpp\\
\#include <iostream> //含有 cout 函数原型\\
using namespace std; //iostream 在 std 名字空间\\
int GetMax (int x, int y) //函数定义\\
f\\
if (x >= y) return x;\\
else return y;\\
\}\\
int main()\\
f\\
cout <<GetMax (5, 8); //调用函数GetMax 并输出结果\\
return 0;\\
)

\begin{verbatim}

在写 C＋＋程序时，要养成给程序加注释的习惯。C＋＋有两种注释方法：（1）多行注释，包含在定界符＂／$*$＂和＂$* /$＂之间的所有文本内容均为注释；（2）单行注释，在符号＂／／＂之后至本行末的所有文本内容均为注释。

\footnotetext{
（1）系统定义的头文件有些带． h 有些不带． h ，例如＜iostream＞和＜iostream． $\mathrm{h}>$ ，二者有什么关系呢？C＋＋ 98 标准规定，系统头文件不带后缀名，原有 C 语言系统头文件标准化后，头文件名前带字母 c，例如 cstdio、cmath、cstring 等。
}

\section*{B． 2 数 据 类 型}

\section*{1．标识符}

标识符是用来标识变量、函数、类型等程序要素的有效字符序列。简单地说，标识符就是一个名字，如变量名、函数名等。C＋＋语言中标识符的命名规则如下：
（1）由字母、数字或下画线组成；
（2）字母或下画线作为第一个字符，其后跟零个或多个字母、数字或下画线；
（3）区分大小写。

\section*{2．基本数据类型}

基本数据类型是 C＋＋语言预定义的数据类型，共有 3 种类型；整型（int）、浮点型（单精度 float、双精度 double）和字符型（char）。另外，C＋＋语言还提供了 4 个修饰符：signed （有符号）、unsigned（无符号）、short（短型）和 long（长型），用来作为前缀修饰整型。

\section*{3．常量}

在程序运行过程中不允许改变的数据称为常量。C＋＋语言提供了两种类型的常量：文字常量和符号常量。
（1）文字常量
文字常量就是以文字形式出现的常量，也称为字面常量，其数据类型由其表示方法决定。例如， 8 代表一个整型常量，-5.6 代表一个实型常量，＂teacher＂代表一个字符串常量。
（2）符号常量
用标识符表示的常量称为符号常量。符号常量用常量名来访问，使用前必须定义并且赋初值，而且在初始化后不能再改变。定义符号常量的一般格式如下：
\end{verbatim}

const 数据类型 常量名=常量值;

\begin{verbatim}

例如：
\end{verbatim}

const int MaxSize = 100;

\begin{verbatim}

\section*{4．变量}

在程序运行过程中可以改变的数据称为变量，在内存中对应一块连续的存储单元。在 C＋＋语言中，使用变量前必须对变量进行定义，其一般格式如下：

\section*{数据类型变量名 1 ，变量名 $2, \cdots$ ，变量名 $n$ ；}

例如：
\end{verbatim}

int length, width;

\begin{verbatim}

定义变量后，编译器根据所属的数据类型，为变量分配一定数量的连续内存单元，并将变量名与这块存储单元绑定在一起。

\section*{5．自定义数据类型}
（1）数组——批量同类型数据的组织
数组是类型相同、数目一定的变量的有序集合，组成数组的变量称为数组元素。定义数组的一般格式如下：

\section*{数据类型数组名［常量表达式 11 ［常量表达式 2］$\cdots$［常量表达式 n ］；}

其中，数据类型给出了数组元素的类型；数组名是一个标识符，代表数组在内存中的起始地址；方括号的个数代表数组的维数；方括号中的常量表达式是数组某一维的长度；方括号中常量表达式的值的乘积是数组元素的个数。

对数组元素的访问是通过数组名和下标实现的，其一般格式如下：

\section*{数组名［下标表达式 1 ］［下标表达式 2］$\cdots$［下标表达式 $n$ ］}

其中，下标表达式的个数与定义数组时的维数相同，下标表达式的值从 0 开始。
例如，＂int $\mathrm{a}[5], \mathrm{b}[2][4]$ ；＂定义了一维数组 a 共有 5 个元素，分别是 $\mathrm{a}[0], \mathrm{a}[1]$ ， $\mathrm{a}[2], \mathrm{a}[3], \mathrm{a}[4]$ ，定义了二维数组 b 共有 8 个元素，分别是 $\mathrm{b}[0][0], \mathrm{b}[0][1]$ ， $\mathrm{b}[0][2], \mathrm{b}[0][3], \mathrm{b}[1][0], \mathrm{b}[1][1], \mathrm{b}[1][2], \mathrm{b}[1][3]$ 。
（2）结构体类型——不同类型数据的组织
结构体将逻辑上构成一个整体的变量组织在一起，组成结构体的变量称为成员（或域），所有成员在内存中连续存储。定义结构体变量需要先定义结构体类型，其一般格式如下：
\end{verbatim}

struct 结构体类型名\\
\{\\
数据类型 成员 1;\\
数据类型 成员 2;\\
数据类型 成员 n;

\begin{verbatim}

定义一个结构体类型并不进行内存分配，内存分配发生在定义这个结构体类型的变量时。定义结构体变量的一般格式如下：

\section*{结构体类型名 结构体变量 1 ，结构体变量 $2, \cdots$ ，结构体变量 $n$ ；}

定义了结构体变量，分配了内存空间，就可以使用运算符＂．＂来访问结构体中的成员，左操作元为结构体变量，右操作元为结构体的成员；还可以使用操作符＂$->$＂来访问结构体的成员，左操作元为指向结构体的指针，右操作元为结构体的成员。例如：
\end{verbatim}

struct Node\\
l\\
int data;\\
Node * next;\\
\};\\
Node t, * s;

\begin{verbatim}

上述语句首先定义了结构体类型 Node，然后定义了结构体变量 t 和结构体指针变量 s ，则 t 。 data 表示访问结构体变量 t 的 data 成员， $\mathrm{s} \rightarrow>$ data 表示访问结构体指针变量 s 指向存储单元的 data 成员，如图 B－1 所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-309.jpg?height=215&width=736&top_left_y=716&top_left_x=522)

图 B－1 结构体变量和指向结构体的指针

\section*{B． 3 控制语句}

\section*{1．表达式语句和空语句}

表达式语句由表达式加分号组成，例如赋值表达式语句：＂ $\mathrm{x}=3+6$ ；＂，表达式语句是 C＋＋程序最基本的语句。空语句仅由分号组成，在程序中不做任何操作。

\section*{2．复合语句}

复合语句也称块语句，是用花括号括起来的一条或多条语句的组合，在语法上相当于一条语句。例如：
\end{verbatim}

if(x >= 0) \{\\
if (x>0) x=0;\\
\}\\
else \{\\
x++;\\
\}\\
//块语可解决了 else 配对问题

\begin{verbatim}

\section*{3．选择语句}

选择结构包括单分支、双分支和多分支等结构，单分支和双分支的选择结构一般由逻辑值控制，根据给定的逻辑表达式成立与否决定是否执行某个程序段；多分支的选择结构一般由算术值控制，根据算术表达式的值选择执行某个程序段。
> （1）if（逻辑表达式）语句
> （2）if（逻辑表达式）语句 1
> else 语句 2
\end{verbatim}

(3) switch (算术表达式)\\
f\\
case 常量表达式 1:语句 1\\
;\\
case 常量表达式 n:语可 n\\
default:语句 n+1

\begin{verbatim}

\section*{4．循环语句}

循环结构的基本特点是：当给定的条件成立时，重复执行某程序段，给定的条件称为循环条件，重复执行的程序段称为循环体。通常情况下，循环结构利用某个变量来控制循环条件，通过改变这个变量的值最终结束循环，这个变量称为循环变量。C＋＋语言提供了当型循环（while）、直到型循环（do－while）和计数型循环（for）。
\end{verbatim}

(1) while (表达式)\\
循环体\\
(2) do\\
循环体\\
while(表达式);\\
(3) for (表达式 1;表达式 2; 表达式 3)\\
循环体

\begin{verbatim}

\section*{5．转移语句}
（1）break 语句
break 语句仅用在以下两种情况：用在 switch 中，退出 switch 语句；用在循环体中，退出 break 所在的那层循环。
（2）continue 语句
continue 语句只能用在循环体中。在执行循环的过程中，如果遇到 continue 语句，将结束本次循环，开始下一次的循环。

\section*{B． 4 输入与输出}

在 C ++ 程序中要执行输人输出操作，必须用 \＃include 预处理指令包含 $<$ iostream $>$头文件并加载 using namespace std 名字空间。

标准输人流 $\operatorname{cin}$（与标准输人设备键盘相关联）用于获得来自键盘的输入，操作符 ＂＞＞＞＂用于分开输人的变量。标准输出流cout（与标准输出设备显示器相关联）用于将要输出的内容输出到显示器上，操作符＂$\ll$＂用于分开将被输出的每一个内容。例如：
\end{verbatim}

cin >>a >>b;\\
cout <<"x="<<x<<endl; //endl 的作用是输出换行符并清空流

\begin{verbatim}

\section*{B． 5 动态存储分配}

所谓动态存储分配是指在程序的运行过程中根据实际需要随时申请内存空间，并在不需要时释放。C＋＋语言通过指针实现动态存储分配，在进行动态存储分配时需要使用运算符 new 和 delete，相应地，把申请和释放内存的过程称为创建和删除。

\section*{1．指针}

指针变量是保存内存地址的变量，简称指针，定义指针变量的一般格式如下：
数据类型＊指针变量名；
其中，数据类型是该指针变量所指向存储单元的数据类型，即该指针所指向的内存单元可以存放什么类型的数据。

如何将一个指针变量指向某个内存单元呢？可以使用取地址运算符＂\＆＂来获取某变量的地址，并将内存地址存储在指针变量中，其结果是指针变量指向了该内存地址，就可以使用间接引用运算符＂＊＂来访问指针所指内存单元。例如：
\begin{tabular}{ll} 
int $x=1, * p ;$ & $/ /$ 定义整型变量 $x$ 和指向整型单元的指针变量 $p$ \\
$p=\varepsilon x ;$ & $/ /$ 将变量 $x$ 的存储地址账给变量 $p$ ，其结果是指针 $p$ 指向变量 $x$ \\
cout $\ll * p ;$ & $/ /$ 输出指针 $p$ 所指内存单元的值，即输出 1
\end{tabular}

\section*{2．运算符 new}

运算符 new 以数据类型为参数，向内存申请该数据类型大小的存储空间，并返回该存储空间的首地址，如果申请不成功，则返回一个空指针。运算符 new 的一般格式如下：
\end{verbatim}

指针变量 = new 数据类型;

\begin{verbatim}

例如，要为一个整数动态分配存储空间，可以先定义一个指针变量＂int＊p；＂，如图 B－2（a）所示。当需要使用该整数时，再为其分配存储空间：＂$p=$ new int；＂，则系统分配一个整型大小的存储空间，并使指针 p 指向该存储空间，如图 B－2（b）所示。语句 $" * p=10$ ；＂实现在动态分配的内存空间中存储整数 10 ，如图 B－2（c）所示。
p
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-311.jpg?height=65&width=86&top_left_y=1946&top_left_x=523)
（a）为指针变量 $p$ 分配内存
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-311.jpg?height=136&width=471&top_left_y=2099&top_left_x=430)
p
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-311.jpg?height=70&width=263&top_left_y=1949&top_left_x=1077)
（b）创建内存空间并使 $p$ 指向它
p $\square$
（d）释放由new创建的内存空间

图 B－2 动态存储分配示意图

\section*{3．运算符 delete}

运算符 delete 释放由 new 创建的存储空间，其一般格式如下：
\end{verbatim}

delete 指针变量名;\\
//释放非数组内存单元\\[0pt]
delete[]指针变量名;\\
//桻放数组内存单元

\begin{verbatim}

其中，指针变量指向需要释放的内存单元，但是指针变量本身并不被删除。例如，＂delete p ；＂释放用 new 运算符创建的内存空间，即指针 p 所指向的存储单元，但指针变量 p 依然存在，如图 B－2（d）所示。

\section*{B． 6 函 数}

\section*{1．函数定义}

C ++ 程序中有两种函数：成员函数和普通函数，其中成员函数用于类方法的定义；普通函数不属于某个类，用于完成一个特定的功能。不论哪种函数，其定义都包括 4 个部分：返回值类型、函数名、形参表和函数体。从函数是否有返回值的角度，可以将函数分为有返回值函数和无返回值函数。
（1）函数有返回值时，函数体中要有 return 语句，形式为：
\end{verbatim}

return 表达式;

\begin{verbatim}

此时，return 语句的作用是返回表达式的值，并终止函数的运行。
（2）函数没有返回值时，函数体中可以没有 return 语句；如果有 return 语句，形式为：
\end{verbatim}

return;

\begin{verbatim}

此时，return 语句的作用只是终止函数的运行。

\section*{2．函数声明}

函数声明又称为函数原型或签名，一般格式如下：
\end{verbatim}

返回值类型 函数名 (形参表);

\begin{verbatim}

函数声明就是在函数头后面加上一个分号，它给出了函数的名称、形参的个数和类型以及函数的返回类型，在函数声明中可以省略形参的名字。

\section*{3．函数调用}

在 C＋＋程序中，除主函数 main 由操作系统调用外，其他函数都是由主函数直接或间接调用的。函数调用的一般格式如下：

\section*{函数名（实参表）}

其中实参表与形参表在参数的类型、个数以及顺序上要保持一致。

\section*{4．参数传递}

在函数没有被调用之前，形参只是一个符号。函数调用时，需要进行参数传递，也就是用实参去初始化对应的形参。在 C＋＋程序中，参数的传递方式有以下三种。
（1）传值：系统为形参（通常为简单变量）分配内存空间，并将实参的值按位置一一对应赋值给形参。此后在被调用函数中形参的任何改变都不会影响到实参。
（2）传指针：系统为形参（通常为指针变量）分配内存空间，并将实参的地址传递给形参，从而使得形参指针指向实参变量。因此，被调用函数中对形参指针所指向存储单元的任何改变都会影响到实参。
（3）传引用：引用是变量的一个别名。在传引用方式下，需要将形参声明为引用类型，即在参数名前加＂\＆＂。当实参与形参结合时，形参作为实参的别名，即形参和实参共用一个存储单元。因此，任何对形参的改变也就是对实参的改变。

下面给出一个例子说明参数传递的三种方式。
\end{verbatim}

void Swap1 (int a, int b) //形参声明为然通变量,传值方式\\
\{\\
int temp;\\
temp = a; a = b; b = temp;\\
\}\\
void Swap2(int *a, int *b) //形参声明为指针,传指钨方式\\
\{\\
int temp;\\
temp = *a; *a= *b; *b= temp;\\
\}\\
void Swap3(int \&a, int \&b) //形参声明为引用类型,传引用方式\\
\{\\
int temp;\\
temp = a; a = b; b = temp;\\
)\\
int main()\\
\{\\
int x = 10, y = 20;\\
Swap1 (x, y); //传值方式,实参为普通变量\\
Swap2(\&x, \&y); //传指针方式,实参为变量的地址\\
Swap3 (x, y); 1/传引用方式,实参为普通变量\\
return 0;\\
\}

\begin{verbatim}

在函数调用之前 $x=10 、 y=20$ ，调用 Swapl 时，$x$ 的值传给对应的形参 $a, y$ 的值传给对应的形参 b，见图 B－3（a），然后执行 Swap1 函数，将 $a 、 b$ 中的值交换，见图 B－3（b），但 x、
y 中的值并未改变；调用 Swap2时，将变量 x 的地址传给对应的形参 a ，变量 y 的地址传给对应的形参 $b$ ，则指针 $a$ 指向变量 $x$ ，指针 $b$ 指向变量 $y$ ，见图 B－4（a），然后执行 Swap2函数，将 $a$ 指向的存储单元中的值与 $b$ 指向的存储单元中的值交换，见图 B－4（b），即交换了 x 和 y 的值；调用 Swap3 时，将变量 x 起了一个别名 a ，变量 y 起了一个别名 b ，见图 B－5（a），然后执行 Swap3 函数，将 $a$ 和 $b$ 的存储单元中的值交换，见图 B－5（b），即交换了 x 和 y 的值。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-314.jpg?height=340&width=1003&top_left_y=590&top_left_x=116)

图 B－3 参数传值示意图
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-314.jpg?height=211&width=478&top_left_y=713&top_left_x=1133)

图 B－5 参数传引用示意图
（4）数组参数的传递。
在 C ++ 中，数组参数的传递方式属于特殊情形，数组作为形参按传值方式声明，但实际传递的是数组的首地址（即数组名），使得形参数组和实参数组共用同一组内存单元。因此，对形参数组所做的任何改变相当于在实参数组中进行相应处理。例如：
\end{verbatim}

void Add(int a [ ], int n)\\
//数组以传值方式声明\\
1\\
for(int i = 0; i <n; i + +)\\[0pt]
a[i]++;\\
\}\\
int main()\\
\{\\[0pt]
int b[5] = \{1, 2, 3, 4, 5\};\\
Add (b, 5) ;\\
return 0;\\
)

\begin{verbatim}

在调用函数 Add 之前数组 b 的状态如图 B－6（a）所示。调用 Add 时，将数组 b 的首地址传给数组 $a$ ，则数组 $a$ 和数组 $b$ 共用同一组内存单元，如图 B－6（b）所示。函数执行后，数组 $b$ 的状态如图 B－6（c）所示。
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-314.jpg?height=133&width=442&top_left_y=2116&top_left_x=146)
（a）参数传递前
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-314.jpg?height=205&width=447&top_left_y=2050&top_left_x=664)
（b）将 b 的值传给 a
![](https://cdn.mathpix.com/cropped/2025_06_06_704745ea57b15b2333e5g-314.jpg?height=131&width=442&top_left_y=2122&top_left_x=1156)
（c）函数调用后

图 B－6 数组参数的传递示意图

\section*{5．函数重载}

函数重载是指函数名相同但函数的形参表不相同，这里的不相同是指形参的个数、类型或顺序不同。例如：
\end{verbatim}

int Fun(int, int);\\
int Fun(int);\\
long Fun(int, long);\\
long Fun(long, int);

\begin{verbatim}

函数重载又称为函数的多态性，它通过改变形参的个数、类型或顺序，使多个函数共用一个函数名，在调用一个重载函数时，编译器通过检查参数的个数、类型和顺序自动选择一个合适的函数。

\section*{B． 7 类与对象}

\section*{1．类的定义}

类是一组变量及其相关函数的封装体，类中的变量称为成员变量或数据成员，用于描述类的特征或状态；类中的函数称为成员函数或方法，用于处理成员变量，从而描述类的行为。为了达到对数据封装的目的，类成员按访问控制权限分为三类：public（公有）、 private（私有）和 protected（保护）。在 public 域中声明的成员可以在程序的任何部分访问；在 private 域中声明的成员只能被类自身的成员函数访问；在 protected 域中声明的成员允许被类自身的成员函数和该类的子类访问。在类定义中一般只声明成员函数，在类外定义成员函数。定义成员函数的一般格式如下：
\end{verbatim}

返回值类型 类名:成员函数名(形参表)\\
\{\\
函数体\\
\}

\begin{verbatim}

其中，＂：：＂叫作作用域运算符，指明所要定义的函数属于哪个类。

\section*{2．对象变量的定义}

在 C＋＋语言中，类被当作一个自定义的数据类型，相应地，一个类的对象就可以看成是该类的一个变量，称为对象变量。同普通变量一样，对象变量也要先定义后使用，在定义了类的对象变量后，就可以使用运算符＂．＂来访问对象的公有成员。下面给出类的定义与使用的例子。
\end{verbatim}

/* node.h存放 Node 类定义\\
class Node\\
\{

\begin{verbatim}

\end{verbatim}

public:\\
Node(); //无参构造函数\\
Node (int x); //有参构造函数\\
\~{}Node(): //析构函数\\
int GetData();\\
void SetData (int x) ;\\
private:\\
int data;\\
Node * next;\\
|;\\
/* node.cpp 存放 Node 类的成员函数定义 * /\\
Node :: Node()\\
\{\\
data = 0; next = nullptr;\\
)\\
Node :: Node(int x)\\
\{\\
data = x; next = nullptr;\\
\}\\
int. Node :: GetData()\\
1\\
return data;\\
)\\
void Node :: SetData(int x)\\
\{\\
data = x;\\
)\\
/* example.cpp 应用程序使用 Node 类 * /\\
\#include <node.h>\\
int main()\\
1\\
Node t\{ \}; / / 由系统自动调用无参构造函数,将 data 初始化为 0\\
Node s\{5\}; //由系统自动週用有参构造函数,将 data 初始化为 5\\
t.SetData(3); //将变量 t 的 data 域赋值为 0\\
s.GetData(); // 获取变量 s 的 data 域,值为 5\\
return 0;\\
\}

\begin{verbatim}

\section*{3．构造函数和析构函数}

构造函数在定义一个类的对象变量时由系统自动调用，其作用是初始化一个对象的成员变量。构造函数有如下要求：必须与类名相同；必须声明为类的公有成员函数；不可以有返回值也不得指明返回类型。可以重载构造函数以便使用各种方法来初始化类的对

象。如果没有为类定义构造函数，那么编译器就会为该类添加一个默认的构造函数。默认构造函数并不做任何初始化工作。

析构函数用于在一个对象变量被撤销时释放其成员变量，标志是在类的名字前面加上＂～＂。当类的对象变量退出作用域时，该类的析构函数就自动被调用，在系统回收对象所占用的内存空间之前先做一些清理工作，尤其是当类的操作包含动态存储分配时，一定要为类提供析构函数。析构函数没有参数和返回值，并且一个类只能有一个析构函数。

\section*{4．友元函数}

在 C ++ 语言中，类的私有成员不允许被外部函数访问，但有时某个特定的函数需要访问类的私有成员。为了解决这个问题，C＋＋语言允许将这个函数定义为该类的友元函数，即在类定义中，在关键字 friend 后列出友元函数。显然，一个友元函数不是该类的成员函数，它可以是其他类的成员函数，也可以是一个普通函数。例如：
\end{verbatim}

class Node\\
l\\
public:\\
friend int Max (int x); //将普通函数 Max 声明为类 Node 的友元函数\\
//其他与上述Node类定义相同\\
private:\\
int data;\\
Node * next;\\
\};\\
int Max(int x)\\
\{\\
Node s\{5\};\\
if(x > s.data) s.data = x; // 在普通函数中访问对象 s 的私有成员 data\\
\}

\begin{verbatim}

\section*{B． 8 模 板}

模板是 C＋＋语言提供的参数多态化的工具，用于增强函数和类的可重用性。使用模板可以使函数的参数、返回值或类中的某些成员取得任意类型。

\section*{1．模板函数}

在重载函数中，有些重载函数的功能几乎完全一样，只是返回值或形参的类型不同。例如，函数 Max 要返回两个 int 类型参数中的最大者，如果还要返回两个 double 类型参数中的最大者，就需要重载函数 Max。通过使用模板，可以定义一个具有通用功能的函数 Max，支持不同类型的参数和返回值。

\footnotetext{
template＜typename T＞
$1 /$ 模板函数需要在函数头前面加上模板标志
$T \operatorname{Max}(T x, T y)$
}
\end{verbatim}

\{\\
return x >= y ? x : y;\\
\}

\begin{verbatim}

上述模板函数定义了一个 Max 函数系列，分别对应不同的数据类型 T。在函数调用时，编译器根据需要创建适当的 Max 函数。例如：
\end{verbatim}

int i = Max (1, 2);\\
/1用 int 替换抽象数据类型 T\\
double x = Max (1.2, 2,5);\\
//用 double 替换抽象数据类型 T

\begin{verbatim}

\section*{2．模板类}

假如一个类包含类型不确定的成员变量，或成员函数的返回类型、形参的类型不能确定，就可以用模板类来解决这个问题。例如：
\end{verbatim}

template <typename T> //模板类需要在类声明前面加上模板标志\\
class Compare\\
\{\\
public:\\
Compare (T x, T y) \{item1 = x; item2 = y;\}\\
T Max() \{return item1 >= item2 ? item1: item2; \}\\
private:\\
T item1, item2;\\
);

\begin{verbatim}

使用模板类来定义对象变量，其一般格式如下：

\section*{模板类名＜模板参数＞对象名 1 ，对象名 $2, \cdots$ ，对象名 $n$ ；}

其中，模板参数是确定的数据类型，编译器根据模板参数创建相应类型的对象变量，并以适当的形式调用模板函数。例如：
\end{verbatim}

Compare<int> intp (3, 5);\\
//定义对象变量 intp 用 int 替换 T\\
Compare<double> dblp(8.5, 3.8);\\
//定义对象变量 dblp 用 double 替换 I\\
cout <<intp.Max() <<endl; //输出5\\
cout <<dblp.Max() <<endl; //输出 8.5

\begin{verbatim}

\section*{B． 9 异 常 处 理}

异常是指在程序运行中，由于运行环境、数据输人或操作不当，导致程序不能运行。异常的一个重要特征是：不能通过静态程序发现异常，而只能在运行程序的过程中才能发现。例如，用户调用函数时，参数设置不正确；申请、使用内存或外存时，存储空间不能

满足要求；读软盘时，软盘末插人、盘片损坏或驱动器故障等。C＋＋的异常处理分为两个方面：抛出异常和捕获异常。
（1）抛出异常。在可能产生异常的函数中，用 if 检测异常，如果异常产生的条件成立，则用 throw 语句抛出该异常。例如：
\end{verbatim}

void FuncExcep(int i)\\
\{\\
if(i==0) throw "this is a exception"; //如果条件满足则拋出异常\\
\}

\begin{verbatim}
（2）捕获异常。在调用带有异常的函数时，将有可能抛出异常的函数放到 try 中，以监控是否抛出异常，同时用 catch 捕获并处理异常。需要强调的是，throw 的作用与 return类似，也是函数返回，但 throw 的返回值（即异常）只能用 catch 捕获。例如：
\end{verbatim}

try\\
l\\
FuncExcep(0); //函数 FuncExcep 可能会拋出异常\\
\}\\
catch (string * str) //捕获函数 FuncExcep 拋出的异常\\
l\\
cout <<str<<endl; //处理捕获的异常,这里只是示意性地输出异常信息\\
\}

\begin{verbatim}

\section*{附录词汇索引}
\begin{tabular}{|l|l|}
\hline \multirow{2}{*}{字母} & 程序（program） \\
\hline & 冲突（collision） \\
\hline AOE 网（activity on edge network） & 抽象（abstract） \\
\hline AOV 网（activity on vertex network） & 抽象数据类型（abstract data type） \\
\hline $\mathrm{B}^{+}$树（ $\mathrm{B}^{+}$tree） & 稠密图（dense graph） \\
\hline B 树（B－tree） & 出度（out－degree） \\
\hline BF 算法 & 次关键码（second key） \\
\hline Dijkstra 算法 & 存储结构（storage structure） \\
\hline Floyd 算法 & 存储密度（storage density） \\
\hline KMP 算法 & \\
\hline Kruskal算法 & D \\
\hline Prim 算法 & 带权路径长度（weighted path length） \\
\hline B & 单链表（singly linked list） \\
\hline & 等长编码（equal length code） \\
\hline 遍历（traverse） & 递增子序列（incremental subsequence） \\
\hline 边集数组（edge set array） & 顶点（vertex） \\
\hline 编码（coding） & 动态查找（dynamic search） \\
\hline 并查集（union find set） & 度（degree） \\
\hline 不等长编码（unequal length code） & 堆（heap） \\
\hline 不稳定（unstable） & 堆积（mass） \\
\hline C & 堆排序（heap sort） \\
\hline & 队列（queue） \\
\hline 插值查找（interpolation search） & \\
\hline 层（level） & E \\
\hline 层序编号（level code） & 二叉链表（binary linked list） \\
\hline 查找（search） & 二叉排序树（binary sort tree） \\
\hline 查找结构（search structure） & 二叉树（binary tree） \\
\hline
\end{tabular}

二路归并排序（2－way merge sort）

\section*{F}

反序（anti－order）
分块查找（blocking search）
分块有序（blocking order）
分支结点（branch node）

\section*{G}

概率算法（probabilistic algorithm）
根（root）
关键活动（critical activity）
关键路径（critical path）
关键码（key）
广度优先遍历（breadth－first traverse）
广义表（lists）

\section*{H}

哈夫曼编码（huffman code）
哈夫曼树（huffman tree）
孩子表示法（child expression）
孩子结点（children node）
孩子兄弟表示法（child brother expression）
后进先出（last in first out）
环（ring）
回路（circuit）
活动（activity）

\section*{J}

基本语句（basic statement）
基数排序（radix sort）
记录（record）
假溢出（false overflow）
简单回路（simple circuit）
简单路径（simple path）
简单选择排序（simple selection sort）
渐进复杂度（asymptotic complexity）
键值（keyword）

结点（node）
解码（decoding）
静态查找（static search）
静态链表（static linked list）

\section*{K}

开放定址法（open addressing）
空间复杂度（space complexity）
快速排序（quick sort）
宽度（breadth）
扩展二叉树（extended binary tree）

\section*{L}

拉链法（chaining）
懒惰删除（lazy deletion）
类（class）
连通分量（connected component）
连通图（connected graph）
链队列（linked queue）
链栈（linked stack）
邻接（adjacent）
邻接表（adjacency list）
邻接多重表（adjacency multi－list）
邻接矩阵（adjacency matrix）
路径（path）
路径长度（path length）
逻辑结构（logical structure）

\section*{M}

满二叉树（full binary tree）
模式（pattern）
模式匹配（pattern matching）

\section*{N}

逆波兰式（reverse Polish notation）
逆序（inverse order）

\section*{P}

排序（sort）
平衡二叉树（balance binary tree）
平衡因子（balance factor）
平均查找长度（average search length）

\section*{Q}

起泡排序（bubble sort）
前缀编码（prefix code）
强连通分量（strongly connected component）
强连通图（strongly connected graph）
权值（weight）

\section*{R}

人度（in－degree）
二叉树（binary tree）

\section*{S}

三叉链表（trident linked list）
三元组表（list of 3－tuples）
三元组顺序表（sequential list of 3－tuples）
散列表（hash table）
散列地址（hash address）
散列函数（hash function）
森林（forest）
深度（depth）
深度优先遍历（depth－first traverse）
生成树（spanning tree）
十字链表（orthogonal list）
时间复杂度（time complexity）
树（tree）
数据（data）
数据结构（data structure）
数据类型（data type）
数据项（data item）
数据元素（data element）
数组（array）

双端队列（double－ended queue）
双链表（doubly linked list）
双亲表示法（parent expression）
双亲孩子表示法（parent children expression）
双亲结点（parent node）
顺序表（sequential list）
顺序队列（sequential queue）
顺序查找（sequential search）
顺序存取（sequential access）
顺序栈（sequential stack）
算法（algorithm）
随机存取（random access）

\section*{T}

趟（pass）
特殊矩阵（special matrix）
同义词（synonym）
同义词子表（synonym table）
头结点（head node）
头尾表示法（head tail expression）
头指针（head pointer）
图（graph）
拓扑排序（topological sort）
拓扑序列（topological order）

\section*{W}

完全二叉树（complete binary tree）
网图（network graph）
伪代码（pseudo－code）
尾标志（tail mark）
尾指针（rear pointer）
稳定（stable）
问题规模（problem scope）
无向图（undirected graph）
无向完全图（undirected complete graph）
位置（location）
\begin{tabular}{|l|l|}
\hline x & 折半插入排序（binary insertion sort）折半查找（binary search） \\
\hline 希尔排序（shell sort） & 折半查找判定树（bisearch decision tree） \\
\hline 稀疏矩阵（sparse matrix） & 正序（exact order） \\
\hline 稀疏图（sparse graph） & 正则二叉树（regular binary tree） \\
\hline 先进先出（first in first out） & 直接插人排序（straight insertion sort） \\
\hline 线索（thread） & 终点（destination） \\
\hline 线索二叉树（thread binary tree） & 轴值（pivot） \\
\hline 线索链表（thread linked list） & 主串（primary string） \\
\hline 线性表（linear list） & 主关键码（primary key） \\
\hline 斜树（oblique tree） & 装填因子（load factor） \\
\hline 兄弟结点（brother node） & 子串（substring） \\
\hline 循环队列（circular queue） & 子树（subtree） \\
\hline 循环单链表（circular singly linked list） & 子孙（descendant） \\
\hline 循环双链表（circular double linked list） & 子图（subgraph） \\
\hline Y & 祖先（ancestor） \\
\hline 叶子结点（leaf node） & 最次位优先（least significant digit first） \\
\hline 依附（adhere） & 最短路径（shortest path） \\
\hline 以列序为主序（column major order） & 最小不平衡子树（minimal unbalance subtree） \\
\hline 以行序为主序（row major order） & 最小不平衡点（minimal unbalance node） \\
\hline 优先队列（priority queue） & 最小生成树（minimal spanning tree） \\
\hline 有向图（directed graph） & 最优二叉树（optimal binary tree） \\
\hline 有向完全图（directed complete graph） & 最主位优先（most significant digit first） \\
\hline 右斜树（right oblique tree） & 左斜树（left oblique tree） \\
\hline 右子树（right subtree） & 指针（pointer） \\
\hline 源点（source） & 左子树（left subtree） \\
\hline
\end{tabular}

\section*{Z}

栈（stack）

\section*{参 考 文 献}
［1］Knuth D E．The Art of Computer Programming［M］．Addison－Wesley， 1981.
［2］Weiss M A．Data Structure and Algorithm Analysis in C＋＋［M］．4nd ed．Addison－Wesley， 2016.
［3］Cormen T H，et al．算法导论［M］． 3 版．殷建平，等译．北京：机械工业出版社， 2012.
［4］Childs J S．C＋＋类和数据结构［M］．张杰良，译．北京：清华大学出版社， 2009.
［5］严蔚敏，等．数据结构［M］．北京：清华大学出版社，1997．
［6］邓俊辉．数据结构（C＋＋语言版）［M］．3版．北京：清华大学出版社，2013．
［7］王红梅，等．数据结构——从概念到 C 实现［M］．北京：清华大学出版社，2017．
［8］王红梅，等．算法设计与分析［M］． 2 版．北京：清华大学出版社， 2013.
［9］王红梅，等．数据结构（C＋＋版）［M］． 2 版．北京：清华大学出版社，2011．
［10］涂子沛．数据之巅——大数据革命、历史、现实与未来［M］．北京：中信出版社， 2014.
\end{verbatim}


\end{document}